<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>LibPython-CLJ Design Notes</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">tech.ml.dataset</span> <span class="project-version">1.47-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="Usage.html"><div class="inner"><span>Usage</span></div></a></li><li class="depth-1  current"><a href="design.html"><div class="inner"><span>LibPython-CLJ Design Notes</span></div></a></li><li class="depth-1 "><a href="new-to-clojure.html"><div class="inner"><span>So Many Parenthesis!</span></div></a></li><li class="depth-1 "><a href="scopes-and-gc.html"><div class="inner"><span>Scopes And Garbage Collection</span></div></a></li><li class="depth-1 "><a href="slicing.html"><div class="inner"><span>Slicing And Slices</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1 "><a href="libpython-clj.python.html"><div class="inner"><span>libpython-clj.python</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#libpython-clj-design-notes" name="libpython-clj-design-notes"></a>LibPython-CLJ Design Notes</h1>
<h2><a href="#key-design-points" name="key-design-points"></a>Key Design Points</h2>
<h3><a href="#code-organization" name="code-organization"></a>Code Organization</h3>
<p>There are 3 rough sections of code: 1. A JNA layer which is a 1-1 mapping most of the C API with no changes and full  documentation. The docstrings on the functions match the documentation if you lookup  the 3.7 API documentation. Users must manually manage the GIL when using this API  layer.</p>
<ol>
  <li>
  <p>An API implementation layer which knows about things like interpreters and type  symbol tables. Users must know how to manipulate the GIL and how the two garbage  collectors work with each other to add to this layer.</p></li>
  <li>
  <p>A public API layer. Details like managing the GIL or messing with garbage collection  in general do not leak out to this layer.</p></li>
</ol>
<h3><a href="#interpreters" name="interpreters"></a>Interpreters</h3>
<p>Interpreters are global objects. After initialize!, there is a main interpreter which is used automatically from any thread. Access to the interpreters relies on thread local variables and interpreter locking so you can do things like:</p>
<pre><code class="clojure">(with-interpreter interpreter
  some code)
</code></pre>
<p>You don’t have to do this, however. If you don’t care what context you run in you can just use the public API which under the covers simple does:</p>
<pre><code class="clojure">(with-gil
  some code)
</code></pre>
<p>This type of thing grabs the GIL if it hasn’t already been claimed by the current thread and off you go. When the code is finished, it saves the interpreter thread state back into a global atom and thus releases the GIL. Interpreters have both shared and per-interpreter state named <code>:shared-state</code> and <code>:interpreter-state</code> respectively. Shared state would be the global type symbol table. Interpreter state contains things like a map of objects to their per-interpreter python bridging class.</p>
<p>If the interpreter isn’t specified it uses the main interpreter. The simplest way to ensure you have the gil is <code>with-gil</code>. You may also use <code>(ensure-bound-interpreter)</code> if you wish to penalize users for using a function incorrectly. This returns the interpreter currently bound to this thread or throws.</p>
<h3><a href="#garbage-collection" name="garbage-collection"></a>Garbage Collection</h3>
<p>The system uses the <a href="https://github.com/techascent/tech.resource">tech.resource</a> library to attach a GC hook to appropriate java object that releases the associated python object if the java object goes out of scope. Bridges use a similar technique to unregister the bridge on destruction of their python counterpart. There should be no need for manual addref/release calls in any user code aside from potentially (and damn rarely) a <code>(System/gc)</code> call.</p>
<h3><a href="#copying-vs-bridging" name="copying-vs-bridging"></a>Copying Vs. Bridging</h3>
<p>Objects either in python or in java may be either copied or bridged into the other ecosystem. Bridging allows sharing complex and potentially changing datastructures while copying allows a cleaner partitioning of concerns and frees both garbage collection systems to act more independently. Numeric buffers that have a direct representation as a C-ptr (the datatype native-buffer type) have a zero-copy pathway via numpy. If you want access to object functionality that object needs to be bridged; so for example if you want to call numpy functions then you need to bridge that object. Tensors are always represented in python as numpy objects using zero-copy where possible in all cases.</p>
<h3><a href="#bridging" name="bridging"></a>Bridging</h3>
<p>Python Callables implement <code>clojure.lang.IFn</code> along with a python specific interface so in general you can call them like any other function but you also can use keyword arguments if you know you are dealing with a python function. Python dicts implement <code>java.util.Map</code> and <code>clojure.lang.IFn</code> and lists are <code>java.util.List</code>, <code>java.util.RandomAccess</code>, and <code>clojure.lang.IFn</code>. This allows fluid manipulation of the datastructures (even mutation) from both languages.</p>
<p>You can create a python function from a clojure function with create-function. You can create a new bridge type by implementing the <code>libpython_clj.jna.JVMBridge</code> interface:</p>
<pre><code class="java">public interface JVMBridge extends AutoCloseable
{
  public Pointer getAttr(String name);
  public void setAttr(String name, Pointer val);
  public String[] dir();
  public Object interpreter();
  public Object wrappedObject();
  // Called from python when the python mirror is deleted.
  // This had better not throw anything.
  public default void close() {}
}
</code></pre>
<p>If all you want to do is override the attribute map that is simple. Here is the bridge for java.util.Map:</p>
<pre><code class="clojure">(defn jvm-map-&gt;python
  ^Pointer [^Map jvm-data]
  (with-gil
    (let [att-map
          {"__contains__" (jvm-fn-&gt;python #(.containsKey jvm-data %))
           "__eq__" (jvm-fn-&gt;python #(.equals jvm-data %))
           "__getitem__" (jvm-fn-&gt;python #(.get jvm-data %))
           "__setitem__" (jvm-fn-&gt;python #(.put jvm-data %1 %2))
           "__hash__" (jvm-fn-&gt;python #(.hashCode jvm-data))
           "__iter__" (jvm-fn-&gt;python #(.iterator ^Iterable jvm-data))
           "__len__" (jvm-fn-&gt;python #(.size jvm-data))
           "__str__" (jvm-fn-&gt;python #(.toString jvm-data))
           "clear" (jvm-fn-&gt;python #(.clear jvm-data))
           "keys" (jvm-fn-&gt;python #(seq (.keySet jvm-data)))
           "values" (jvm-fn-&gt;python #(seq (.values jvm-data)))
           "pop" (jvm-fn-&gt;python #(.remove jvm-data %))}]
      (create-bridge-from-att-map jvm-data att-map))))
</code></pre>
<h3><a href="#io" name="io"></a>IO</h3>
<p><code>sys.stdout</code> and <code>sys.stderr</code> are redirected to <code>*out*</code> and <code>*err*</code> respectively. This rerouting is done using a bridge that is then set as <code>sys.stdout</code> or <code>sys.stderr</code>:</p>
<pre><code class="clojure">(defn create-var-writer
  "Returns an unregistered bridge"
  ^Pointer [writer-var]
  (with-gil
    (create-bridge-from-att-map
     writer-var
     {"write" (-&gt;python (fn [&amp; args]
                          (.write ^Writer @writer-var (str (first args)))))
      "flush" (-&gt;python (fn [&amp; args]))
      "isatty" (-&gt;python (fn [&amp; args]
                           (libpy/Py_False)))
      })))

(defn setup-std-writer
  [writer-var sys-mod-attname]
  (with-gil
    (let [sys-module (import-module "sys")
          std-out-writer (get-or-create-var-writer writer-var)]
      (py-proto/set-attr! sys-module sys-mod-attname std-out-writer)
      :ok)))


(defn initialize!
  [&amp; {:keys [program-name no-io-redirect?]}]
  (when-not @pyinterp/*main-interpreter*
    (pyinterp/initialize! program-name)
    ;;setup bridge mechansim and io redirection
    (pyinterop/register-bridge-type!)
    (when-not no-io-redirect?
      (pyinterop/setup-std-writer #'*err* "stderr")
      (pyinterop/setup-std-writer #'*out* "stdout")))
  :ok)
</code></pre></div></div></div></body></html>