<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Scopes And Garbage Collection</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">libpython-clj</span> <span class="project-version">2.00-alpha-8-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="Usage.html"><div class="inner"><span>Usage</span></div></a></li><li class="depth-1 "><a href="design.html"><div class="inner"><span>LibPython-CLJ Design Notes</span></div></a></li><li class="depth-1 "><a href="new-to-clojure.html"><div class="inner"><span>So Many Parenthesis!</span></div></a></li><li class="depth-1  current"><a href="scopes-and-gc.html"><div class="inner"><span>Scopes And Garbage Collection</span></div></a></li><li class="depth-1 "><a href="slicing.html"><div class="inner"><span>Slicing And Slices</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>libpython-clj2</span></div></div></li><li class="depth-2"><a href="libpython-clj2.python.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>python</span></div></a></li><li class="depth-3"><a href="libpython-clj2.python.np-array.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>np-array</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#scopes-and-garbage-collection" name="scopes-and-garbage-collection"></a>Scopes And Garbage Collection</h1>
<p>libpython-clj now supports stack-based scoping rules so you can guarantee all python objects created during a section of code will be released by a certain point.</p>
<p>Using the stack-based scoping looks like:</p>
<pre><code class="clojure">user&gt; (require '[libpython-clj.python :as py])
nil
user&gt; (py/initialize!)
... (logging elided)
:ok
user&gt; (py/stack-resource-context
       (-&gt; (py/-&gt;py-dict {:a 1 :b 2})
           ;;Note - Without this call you guarantee a crash.
           (py/-&gt;jvm)))
{"a" 1, "b" 2}
</code></pre>
<p>You must either call -&gt;jvm or return a keyword at the end of your scope.</p>
<p>In the case where you are processing a batch of items (which we recommend for perf reasons), you can also grab the GIL at the top of your thing:</p>
<pre><code class="clojure">user&gt; (def dict-seq (py/as-jvm (py/-&gt;py-list (repeat 1000 (py/-&gt;py-dict {:a 1 :b 2})))))
#'user/dict-seq


user&gt; (def ignored (time (mapv py/-&gt;jvm dict-seq)))
"Elapsed time: 2200.556506 msecs"
#'user/ignored
user&gt; (def ignored (time (py/with-gil (mapv py/-&gt;jvm dict-seq))))
"Elapsed time: 2095.815518 msecs"
#'user/ignored
</code></pre>
<p>The hidden thing above, regardless of if you grab the gil or not is that you are actually holding onto a lot of python objects that could be released. Hence if you aren’t disciplined about calling System/gc or if the jvm gc just decides not to run you could be allocating a lot of native-heap objects. Plus what you don’t see is that if you call System/gc the resource thread dedicated to releasing things will have a lot of work to do.</p>
<p>For production use cases where you need a bit more assurance that things get released, please consider both grabbing the gil <em>and</em> opening a resource context:</p>
<pre><code class="clojure">user&gt; (def ignored (time (py/with-gil-stack-rc-context
                           (-&gt;&gt; (repeatedly 1000 #(py/-&gt;py-dict {:a 1 :b 2}))
                                (py/-&gt;py-list)
                                (py/as-jvm)
                                (mapv py/-&gt;jvm)))))

"Elapsed time: 3246.847595 msecs"
#'user/ignored
</code></pre>
<p>This took a second longer! But, you <em>know</em> that all python objects allocated within that scope are released. Before, you would be in essence hoping that things would be released soon enough.</p>
<p>Again, for production contexts we recommend batch processing objects <em>and</em> using the <code>with-gil-stack-rc-context</code> function call that correctly grabs the gil, opens a resource context and then releases anything allocated within that context.</p></div></div></div></body></html>