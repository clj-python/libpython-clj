<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Usage</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">tech.ml.dataset</span> <span class="project-version">2.00-alpha-2</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1  current"><a href="Usage.html"><div class="inner"><span>Usage</span></div></a></li><li class="depth-1 "><a href="design.html"><div class="inner"><span>LibPython-CLJ Design Notes</span></div></a></li><li class="depth-1 "><a href="new-to-clojure.html"><div class="inner"><span>So Many Parenthesis!</span></div></a></li><li class="depth-1 "><a href="scopes-and-gc.html"><div class="inner"><span>Scopes And Garbage Collection</span></div></a></li><li class="depth-1 "><a href="slicing.html"><div class="inner"><span>Slicing And Slices</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>libpython-clj</span></div></div></li><li class="depth-2"><a href="libpython-clj.python.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>python</span></div></a></li><li class="depth-3"><a href="libpython-clj.python.np-array.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>np-array</span></div></a></li><li class="depth-2"><a href="libpython-clj.require.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>require</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#usage" name="usage"></a>Usage</h1>
<p>Python objects are essentially two dictionaries, one for ‘attributes’ and one for ‘items’. When you use python and use the ‘.’ operator, you are referencing attributes. If you use the ‘[]’ operator, then you are referencing items. Attributes are built in, item access is optional and happens via the <code>__getitem__</code> and <code>__setitem__</code> attributes. This is important to realize in that the code below doesn’t look like python because we are referencing the item and attribute systems by name and not via ‘.’ or ‘[]’.</p>
<p>This would result in the following analogous code (full example <a href="#dataframe-access-full-example">further on</a>):</p>
<pre><code class="python">table.loc[row_date]
</code></pre>
<pre><code class="clojure">(get-item (get-attr table :loc) row-date)
</code></pre>
<h3><a href="#installation" name="installation"></a>Installation</h3>
<h4><a href="#ubuntu" name="ubuntu"></a>Ubuntu</h4>
<pre><code class="console">sudo apt install libpython3.6
# numpy and pandas are required for unit tests.  Numpy is required for
# zero copy support.
python3.6 -m pip install numpy pandas --user
</code></pre>
<h4><a href="#macosx" name="macosx"></a>MacOSX</h4>
<p>Python installation instructions <a href="https://docs.python-guide.org/starting/install3/osx/">here</a>.</p>
<h3><a href="#initialize-python" name="initialize-python"></a>Initialize python</h3>
<pre><code class="clojure">user&gt;

user&gt; (require '[libpython-clj.python
                 :refer [as-python as-jvm
                         -&gt;python -&gt;jvm
                         get-attr call-attr call-attr-kw
                         get-item att-type-map
                         call call-kw initialize!
                         as-numpy as-tensor -&gt;numpy
                         run-simple-string
                         add-module module-dict
                         import-module
                         python-type]])
nil

; Mac and Linux
user&gt; (initialize!)
Jun 30, 2019 4:47:39 PM clojure.tools.logging$eval7369$fn__7372 invoke
INFO: executing python initialize!
Jun 30, 2019 4:47:39 PM clojure.tools.logging$eval7369$fn__7372 invoke
INFO: Library python3.6m found at [:system "python3.6m"]
Jun 30, 2019 4:47:39 PM clojure.tools.logging$eval7369$fn__7372 invoke
INFO: Reference thread starting
:ok

; Windows with Anaconda
(initialize! ; Python executable
             :python-executable "C:\\Users\\USER\\AppData\\Local\\Continuum\\anaconda3\\python.exe"
             ; Python Library
             :library-path "C:\\Users\\USER\\AppData\\Local\\Continuum\\anaconda3\\python37.dll"
             ; Anacondas PATH environment to load native dlls of modules (numpy, etc.)
             :windows-anaconda-activate-bat "C:\\Users\\USER\\AppData\\Local\\Continuum\\anaconda3\\Scripts\\activate.bat"
             )
...
:ok
</code></pre>
<p>This dynamically finds the python shared library and loads it using output from the python3 executable on your system. For information about how that works, please checkout the code <a href="https://github.com/cnuernber/libpython-clj/blob/master/src/libpython_clj/python/interpreter.clj#L30">here</a>.</p>
<h3><a href="#execute-some-python" name="execute-some-python"></a>Execute Some Python</h3>
<p><code>*out*</code> and <code>*err*</code> capture python stdout and stderr respectively.</p>
<pre><code class="clojure"><br />user&gt; (run-simple-string "print('hey')")
hey
{:globals
 {'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__spec__': None, '__annotations__': {}, '__builtins__': &lt;module 'builtins' (built-in)&gt;},
 :locals
 {'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__spec__': None, '__annotations__': {}, '__builtins__': &lt;module 'builtins' (built-in)&gt;}}
</code></pre>
<p>The results have been ‘bridged’ into java meaning they are still python objects but there are java wrappers over the top of them. For instance, <code>Object.toString</code> forwards its implementation to the python function <code>__str__</code>.</p>
<pre><code class="clojure">(def bridged (run-simple-string "print('hey')"))
(instance? java.util.Map (:globals bridged))
true
user&gt; (:globals bridged)
{'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__spec__': None, '__annotations__': {}, '__builtins__': &lt;module 'builtins' (built-in)&gt;}
</code></pre>
<p>We can get and set global variables here. If we run another string, these are in the environment. The globals map itself is the global dict of the main module:</p>
<pre><code class="clojure">(def main-globals (-&gt; (add-module "__main__")
                            (module-dict)))
#'user/main-globals

user&gt; main-globals
{'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__spec__': None, '__annotations__': {}, '__builtins__': &lt;module 'builtins' (built-in)&gt;}
user&gt; (keys main-globals)
("__name__"
 "__doc__"
 "__package__"
 "__loader__"
 "__spec__"
 "__annotations__"
 "__builtins__")
user&gt; (get main-globals "__name__")
"__main__"
user&gt; (.put main-globals "my_var" 200)
nil

user&gt; (run-simple-string "print('your variable is:' + str(my_var))")
your variable is:200
{:globals
 {'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__spec__': None, '__annotations__': {}, '__builtins__': &lt;module 'builtins' (built-in)&gt;, 'my_var': 200},
 :locals
 {'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__spec__': None, '__annotations__': {}, '__builtins__': &lt;module 'builtins' (built-in)&gt;, 'my_var': 200}}
</code></pre>
<p>Running Python isn’t ever really necessary, however, although it may at times be convenient. You can call attributes from clojure easily:</p>
<pre><code class="clojure">user&gt; (def np (import-module "numpy"))
#'user/np
user&gt; (def ones-ary (call-attr np "ones" [2 3]))
#'user/ones-ary
user&gt; ones-ary
[[1. 1. 1.]
 [1. 1. 1.]]
user&gt; (call-attr ones-ary "__len__")
2
user&gt; (vec ones-ary)
[[1. 1. 1.] [1. 1. 1.]]
user&gt; (type (first *1))
:pyobject
user&gt; (get-attr ones-ary "shape")
(2, 3)
user&gt; (vec (get-attr ones-ary "shape"))
[2 3]

user&gt; (att-type-map ones-ary)
{"T" :ndarray,
 "__abs__" :method-wrapper,
 "__add__" :method-wrapper,
 "__and__" :method-wrapper,
 "__array__" :builtin-function-or-method,
 "__array_finalize__" :none-type,
 "__array_function__" :builtin-function-or-method,
 "__array_interface__" :dict,
 "__array_prepare__" :builtin-function-or-method,
 "__array_priority__" :float,
 "__array_struct__" :py-capsule,
 "__array_ufunc__" :builtin-function-or-method,
 "__array_wrap__" :builtin-function-or-method,
 "__bool__" :method-wrapper,
 "__class__" :type,
 "__complex__" :builtin-function-or-method,
 "__contains__" :method-wrapper,
 ...
 "std" :builtin-function-or-method,
 "strides" :tuple,
 "sum" :builtin-function-or-method,
 "swapaxes" :builtin-function-or-method,
 "take" :builtin-function-or-method,
 "tobytes" :builtin-function-or-method,
 "tofile" :builtin-function-or-method,
 "tolist" :builtin-function-or-method,
 "tostring" :builtin-function-or-method,
 "trace" :builtin-function-or-method,
 "transpose" :builtin-function-or-method,
 "var" :builtin-function-or-method,
 "view" :builtin-function-or-method}
</code></pre>
<h3><a href="#att-type-map" name="att-type-map"></a>att-type-map</h3>
<p>It can be extremely helpful to print out the attribute name-&gt;attribute type map:</p>
<pre><code class="clojure">user&gt; (att-type-map ones-ary)
{"T" :ndarray,
 "__abs__" :method-wrapper,
 "__add__" :method-wrapper,
 "__and__" :method-wrapper,
 "__array__" :builtin-function-or-method,
 "__array_finalize__" :none-type,
 "__array_function__" :builtin-function-or-method,
 "__array_interface__" :dict,
 ...
  "real" :ndarray,
 "repeat" :builtin-function-or-method,
 "reshape" :builtin-function-or-method,
 "resize" :builtin-function-or-method,
 "round" :builtin-function-or-method,
 "searchsorted" :builtin-function-or-method,
 "setfield" :builtin-function-or-method,
 "setflags" :builtin-function-or-method,
 "shape" :tuple,
 "size" :int,
 "sort" :builtin-function-or-method,
 ...
}
</code></pre>
<h3><a href="#dataframe-access-full-example" name="dataframe-access-full-example"></a>DataFrame access full example</h3>
<p>Here’s how to create Pandas DataFrame and accessing its rows via <code>loc</code> in both Python and Clojure:</p>
<pre><code class="python"># Python
import numpy as np
import pandas as pan

dates = pan.date_range("1/1/2000", periods=8)
table = pan.DataFrame(np.random.randn(8, 4), index=dates, columns=["A", "B", "C", "D"])
row_date = pan.date_range(start="2000-01-01", end="2000-01-01")
table.loc[row_date]
</code></pre>
<pre><code class="clojure">; Clojure
(require-python '[numpy :as np])
(require-python '[pandas :as pan])

(def dates (pan/date_range "1/1/2000" :periods 8))
(def table (pan/DataFrame (call-attr np/random :randn 8 4) :index dates :columns ["A" "B" "C" "D"]))
(def row-date (pan/date_range :start "2000-01-01" :end "2000-01-01"))
(get-item (get-attr table :loc) row-date)
</code></pre>
<h3><a href="#errors" name="errors"></a>Errors</h3>
<p>Errors are caught and an exception is thrown. The error text is saved verbatim in the exception:</p>
<pre><code class="clojure">user&gt; (run-simple-string "print('syntax errrr")
Execution error (ExceptionInfo) at libpython-clj.python.interpreter/check-error-throw (interpreter.clj:260).
  File "&lt;string&gt;", line 1
    print('syntax errrr
                      ^
SyntaxError: EOL while scanning string literal
</code></pre>
<h3><a href="#some-syntax-sugar" name="some-syntax-sugar"></a>Some Syntax Sugar</h3>
<pre><code class="clojure">user&gt; (py/from-import numpy linspace)
#'user/linspace
user&gt; (linspace 2 3 :num 10)
[2.         2.11111111 2.22222222 2.33333333 2.44444444 2.55555556
 2.66666667 2.77777778 2.88888889 3.        ]
user&gt; (doc linspace)
-------------------------
user/linspace

    Return evenly spaced numbers over a specified interval.

    Returns `num` evenly spaced samples, calculated over the
    interval [`start`, `stop`].

</code></pre>
<ul>
  <li><code>from-import</code> - sugar around python <code>from a import b</code>. Takes multiple b’s.</li>
  <li><code>import-as</code> - surgar around python <code>import a as b</code>.</li>
  <li><code>$a</code> - call an attribute using symbol att name. Keywords map to kwargs</li>
  <li><code>$c</code> - call an object mapping keywords to kwargs</li>
</ul>
<h4><a href="#experimental-sugar" name="experimental-sugar"></a>Experimental Sugar</h4>
<p>We are trying to find the best way to handle attributes in order to shorten generic python notebook-type usage. The currently implemented direction is:</p>
<ul>
  <li><code>$.</code> - get an attribute. Can pass in symbol, string, or keyword</li>
  <li><code>$..</code> - get an attribute. If more args are present, get the attribute on that result.</li>
</ul>
<pre><code class="clojure">user&gt; (py/$. numpy linspace)
&lt;function linspace at 0x7fa6642766a8&gt;
user&gt; (py/$.. numpy random shuffle)
&lt;built-in method shuffle of numpy.random.mtrand.RandomState object at 0x7fa66410cca8&gt;
</code></pre>
<h5><a href="#new-sugar-fixme-" name="new-sugar-fixme-"></a>New sugar (fixme)</h5>
<p><code>libpython-clj</code> offers syntactic forms similar to those offered by Clojure for interacting with Python classes and objects. </p>
<p><strong>Class/object methods</strong> Where in Clojure you would use <code>(. obj method arg1 arg2 ... argN)</code>, you can use <code>(py. pyobj method arg1 arg2 ... argN)</code>. </p>
<p>In Python, this is equivalent to <code>pyobj.method(arg1, arg2, ..., argN)</code>. Concrete examples are shown below.</p>
<p><strong>Class/object attributes</strong> Where in Clojure you would use <code>(.- obj attr)</code>, you can use <code>(py.- pyobj attr)</code>.</p>
<p>In Python, this is equivalent to <code>pyobj.attr</code>. Concrete examples shown below.</p>
<p><strong>Nested attribute access</strong> To achieve a chain of method/attribute access, use the <code>py..</code> for.</p>
<pre><code class="clojure ">(py.. (requests/get "http://www.google.com") 
      -content
      (decode "latin-1"))
</code></pre>
<p>(**Note**: requires Python <code>requests</code> module installled)</p>
<p><strong>Examples</strong></p>
<pre><code class="clojure ">user=&gt; (require '[libpython-clj.python :as py :refer [py. py.. py.-]])
nil
user=&gt; (require '[libpython-clj.require :refer [require-python]])

... debug info ...

user=&gt; (require-python '[builtins :as python])
WARNING: AssertionError already refers to: class java.lang.AssertionError in namespace: builtins, being replaced by: #'builtins/AssertionError
WARNING: Exception already refers to: class java.lang.Exception in namespace: builtins, being replaced by: #'builtins/Exception
nil
user=&gt; (def xs (python/list))
#'user/xs
user=&gt; (py. xs append 1)
nil
user=&gt; xs
[1]
user=&gt; (py. xs extend [1 2 3])
nil
user=&gt; xs
[1, 1, 2, 3]
user=&gt; (py. xs __len__)
4
user=&gt; ((py.- xs __len__)) ;; attribute syntax to get then call method
4
user=&gt; (py. xs pop)
3
user=&gt; (py. xs clear)
nil
;; requires Python requests module installed
user=&gt; (require-python 'requests)
nil
user=&gt; (def requests (py/import-module "requests"))
#'user/requests
user=&gt; (py.. requests (get "http://www.google.com") -content (decode "latin-1"))
"&lt;!doctype html&gt;&lt;html itemscope=\"\" ... snip ... "
</code></pre>
<h3><a href="#numpy" name="numpy"></a>Numpy</h3>
<p>Speaking of numpy, you can move data between numpy and java easily.</p>
<pre><code class="clojure">user&gt; (def tens-data (as-tensor ones-ary))
#'user/tens-data
user&gt; (println tens-data)
#tech.v2.tensor&lt;float64&gt;[2 3]
[[1.000 1.000 1.000]
 [1.000 1.000 1.000]]
nil


user&gt; (require '[tech.v2.datatype :as dtype])
nil
user&gt; (def ignored (dtype/copy! (repeat 6 5) tens-data))
#'user/ignored
user&gt; (.put main-globals "ones_ary" ones_ary)
Syntax error compiling at (*cider-repl cnuernber/libpython-clj:localhost:39019(clj)*:191:7).
Unable to resolve symbol: ones_ary in this context
user&gt; (.put main-globals "ones_ary" ones-ary)
nil

user&gt; (run-simple-string "print(ones_ary)")
[[5. 5. 5.]
 [5. 5. 5.]]
{:globals
 {'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__spec__': None, '__annotations__': {}, '__builtins__': &lt;module 'builtins' (built-in)&gt;, 'my_var': 200, 'ones_ary': array([[5., 5., 5.],
       [5., 5., 5.]])},
 :locals
 {'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': &lt;class '_frozen_importlib.BuiltinImporter'&gt;, '__spec__': None, '__annotations__': {}, '__builtins__': &lt;module 'builtins' (built-in)&gt;, 'my_var': 200, 'ones_ary': array([[5., 5., 5.],
       [5., 5., 5.]])}}
</code></pre>
<p>So heavy data has a zero-copy route. Anything backed by a <code>:native-buffer</code> has a zero copy pathway to and from numpy. For more information on how this happens, please refer to the datatype library <a href="https://github.com/techascent/tech.datatype/tree/master/docs">documentation</a>.</p>
<p>Just keep in mind, careless usage of zero copy is going to cause spooky action at a  distance.</p></div></div></div></body></html>