<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>python.numpy documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="highlight/solarized-light.css" /><script type="text/javascript" src="highlight/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a> with <a href="https://github.com/xsc/codox-theme-rdash">RDash UI</a> theme</h2><h1><a href="index.html"><span class="project-title"><span class="project-name">libpython-clj</span> <span class="project-version">2.00-beta-5</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="Usage.html"><div class="inner"><span>Usage</span></div></a></li><li class="depth-1 "><a href="design.html"><div class="inner"><span>LibPython-CLJ Design Notes</span></div></a></li><li class="depth-1 "><a href="environments.html"><div class="inner"><span>Python Environments</span></div></a></li><li class="depth-1 "><a href="new-to-clojure.html"><div class="inner"><span>So Many Parenthesis!</span></div></a></li><li class="depth-1 "><a href="scopes-and-gc.html"><div class="inner"><span>Scopes And Garbage Collection</span></div></a></li><li class="depth-1 "><a href="slicing.html"><div class="inner"><span>Slicing And Slices</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>libpython-clj2</span></div></div></li><li class="depth-2 branch"><a href="libpython-clj2.codegen.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>codegen</span></div></a></li><li class="depth-2"><a href="libpython-clj2.python.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>python</span></div></a></li><li class="depth-3"><a href="libpython-clj2.python.np-array.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>np-array</span></div></a></li><li class="depth-2"><a href="libpython-clj2.require.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>require</span></div></a></li><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree" style="top: -145px;"><span class="top" style="height: 154px;"></span><span class="bottom"></span></span><span>python</span></div></div></li><li class="depth-2 branch"><a href="python.builtins.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>builtins</span></div></a></li><li class="depth-2 current"><a href="python.numpy.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>numpy</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="python.numpy.html#var-__all__"><div class="inner"><span>__all__</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-__builtins__"><div class="inner"><span>__builtins__</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-__cached__"><div class="inner"><span>__cached__</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-__config__"><div class="inner"><span>__config__</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-__dir__"><div class="inner"><span>__dir__</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-__doc__"><div class="inner"><span>__doc__</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-__file__"><div class="inner"><span>__file__</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-__getattr__"><div class="inner"><span>__getattr__</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-__git_revision__"><div class="inner"><span>__git_revision__</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-__loader__"><div class="inner"><span>__loader__</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-__name__"><div class="inner"><span>__name__</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-__package__"><div class="inner"><span>__package__</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-__path__"><div class="inner"><span>__path__</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-__spec__"><div class="inner"><span>__spec__</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-__version__"><div class="inner"><span>__version__</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-_add_newdoc_ufunc"><div class="inner"><span>_add_newdoc_ufunc</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-_distributor_init"><div class="inner"><span>_distributor_init</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-_globals"><div class="inner"><span>_globals</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-_mat"><div class="inner"><span>_mat</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-_NoValue"><div class="inner"><span>_NoValue</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-_pytesttester"><div class="inner"><span>_pytesttester</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-_UFUNC_API"><div class="inner"><span>_UFUNC_API</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-abs"><div class="inner"><span>abs</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-absolute"><div class="inner"><span>absolute</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-absolute_import"><div class="inner"><span>absolute_import</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-add"><div class="inner"><span>add</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-add_docstring"><div class="inner"><span>add_docstring</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-add_newdoc"><div class="inner"><span>add_newdoc</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-add_newdoc_ufunc"><div class="inner"><span>add_newdoc_ufunc</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-alen"><div class="inner"><span>alen</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-all"><div class="inner"><span>all</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-allclose"><div class="inner"><span>allclose</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-ALLOW_THREADS"><div class="inner"><span>ALLOW_THREADS</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-alltrue"><div class="inner"><span>alltrue</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-amax"><div class="inner"><span>amax</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-amin"><div class="inner"><span>amin</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-angle"><div class="inner"><span>angle</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-any"><div class="inner"><span>any</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-append"><div class="inner"><span>append</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-apply_along_axis"><div class="inner"><span>apply_along_axis</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-apply_over_axes"><div class="inner"><span>apply_over_axes</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-arange"><div class="inner"><span>arange</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-arccos"><div class="inner"><span>arccos</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-arccosh"><div class="inner"><span>arccosh</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-arcsin"><div class="inner"><span>arcsin</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-arcsinh"><div class="inner"><span>arcsinh</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-arctan"><div class="inner"><span>arctan</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-arctan2"><div class="inner"><span>arctan2</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-arctanh"><div class="inner"><span>arctanh</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-argmax"><div class="inner"><span>argmax</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-argmin"><div class="inner"><span>argmin</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-argpartition"><div class="inner"><span>argpartition</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-argsort"><div class="inner"><span>argsort</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-argwhere"><div class="inner"><span>argwhere</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-around"><div class="inner"><span>around</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-array"><div class="inner"><span>array</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-array2string"><div class="inner"><span>array2string</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-array_equal"><div class="inner"><span>array_equal</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-array_equiv"><div class="inner"><span>array_equiv</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-array_repr"><div class="inner"><span>array_repr</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-array_split"><div class="inner"><span>array_split</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-array_str"><div class="inner"><span>array_str</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-asanyarray"><div class="inner"><span>asanyarray</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-asarray"><div class="inner"><span>asarray</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-asarray_chkfinite"><div class="inner"><span>asarray_chkfinite</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-ascontiguousarray"><div class="inner"><span>ascontiguousarray</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-asfarray"><div class="inner"><span>asfarray</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-asfortranarray"><div class="inner"><span>asfortranarray</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-asmatrix"><div class="inner"><span>asmatrix</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-asscalar"><div class="inner"><span>asscalar</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-atleast_1d"><div class="inner"><span>atleast_1d</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-atleast_2d"><div class="inner"><span>atleast_2d</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-atleast_3d"><div class="inner"><span>atleast_3d</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-average"><div class="inner"><span>average</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-AxisError"><div class="inner"><span>AxisError</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-bartlett"><div class="inner"><span>bartlett</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-base_repr"><div class="inner"><span>base_repr</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-binary_repr"><div class="inner"><span>binary_repr</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-bincount"><div class="inner"><span>bincount</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-bitwise_and"><div class="inner"><span>bitwise_and</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-bitwise_not"><div class="inner"><span>bitwise_not</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-bitwise_or"><div class="inner"><span>bitwise_or</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-bitwise_xor"><div class="inner"><span>bitwise_xor</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-blackman"><div class="inner"><span>blackman</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-block"><div class="inner"><span>block</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-bmat"><div class="inner"><span>bmat</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-bool"><div class="inner"><span>bool</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-bool8"><div class="inner"><span>bool8</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-bool_"><div class="inner"><span>bool_</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-broadcast"><div class="inner"><span>broadcast</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-broadcast_arrays"><div class="inner"><span>broadcast_arrays</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-broadcast_to"><div class="inner"><span>broadcast_to</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-BUFSIZE"><div class="inner"><span>BUFSIZE</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-busday_count"><div class="inner"><span>busday_count</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-busday_offset"><div class="inner"><span>busday_offset</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-busdaycalendar"><div class="inner"><span>busdaycalendar</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-byte"><div class="inner"><span>byte</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-byte_bounds"><div class="inner"><span>byte_bounds</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-bytes0"><div class="inner"><span>bytes0</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-bytes_"><div class="inner"><span>bytes_</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-c_"><div class="inner"><span>c_</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-can_cast"><div class="inner"><span>can_cast</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-cast"><div class="inner"><span>cast</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-cbrt"><div class="inner"><span>cbrt</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-cdouble"><div class="inner"><span>cdouble</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-ceil"><div class="inner"><span>ceil</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-cfloat"><div class="inner"><span>cfloat</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-char"><div class="inner"><span>char</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-character"><div class="inner"><span>character</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-chararray"><div class="inner"><span>chararray</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-choose"><div class="inner"><span>choose</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-CLIP"><div class="inner"><span>CLIP</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-clip"><div class="inner"><span>clip</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-clongdouble"><div class="inner"><span>clongdouble</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-clongfloat"><div class="inner"><span>clongfloat</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-column_stack"><div class="inner"><span>column_stack</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-common_type"><div class="inner"><span>common_type</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-compare_chararrays"><div class="inner"><span>compare_chararrays</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-compat"><div class="inner"><span>compat</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-complex"><div class="inner"><span>complex</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-complex128"><div class="inner"><span>complex128</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-complex256"><div class="inner"><span>complex256</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-complex64"><div class="inner"><span>complex64</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-complex_"><div class="inner"><span>complex_</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-complexfloating"><div class="inner"><span>complexfloating</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-ComplexWarning"><div class="inner"><span>ComplexWarning</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-compress"><div class="inner"><span>compress</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-concatenate"><div class="inner"><span>concatenate</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-conj"><div class="inner"><span>conj</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-conjugate"><div class="inner"><span>conjugate</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-convolve"><div class="inner"><span>convolve</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-copy"><div class="inner"><span>copy</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-copysign"><div class="inner"><span>copysign</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-copyto"><div class="inner"><span>copyto</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-core"><div class="inner"><span>core</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-corrcoef"><div class="inner"><span>corrcoef</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-correlate"><div class="inner"><span>correlate</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-cos"><div class="inner"><span>cos</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-cosh"><div class="inner"><span>cosh</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-count_nonzero"><div class="inner"><span>count_nonzero</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-cov"><div class="inner"><span>cov</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-cross"><div class="inner"><span>cross</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-csingle"><div class="inner"><span>csingle</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-ctypeslib"><div class="inner"><span>ctypeslib</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-cumprod"><div class="inner"><span>cumprod</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-cumproduct"><div class="inner"><span>cumproduct</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-cumsum"><div class="inner"><span>cumsum</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-DataSource"><div class="inner"><span>DataSource</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-datetime64"><div class="inner"><span>datetime64</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-datetime_as_string"><div class="inner"><span>datetime_as_string</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-datetime_data"><div class="inner"><span>datetime_data</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-deg2rad"><div class="inner"><span>deg2rad</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-degrees"><div class="inner"><span>degrees</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-delete"><div class="inner"><span>delete</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-deprecate"><div class="inner"><span>deprecate</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-deprecate_with_doc"><div class="inner"><span>deprecate_with_doc</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-diag"><div class="inner"><span>diag</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-diag_indices"><div class="inner"><span>diag_indices</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-diag_indices_from"><div class="inner"><span>diag_indices_from</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-diagflat"><div class="inner"><span>diagflat</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-diagonal"><div class="inner"><span>diagonal</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-diff"><div class="inner"><span>diff</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-digitize"><div class="inner"><span>digitize</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-disp"><div class="inner"><span>disp</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-divide"><div class="inner"><span>divide</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-division"><div class="inner"><span>division</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-divmod"><div class="inner"><span>divmod</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-dot"><div class="inner"><span>dot</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-double"><div class="inner"><span>double</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-dsplit"><div class="inner"><span>dsplit</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-dstack"><div class="inner"><span>dstack</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-dtype"><div class="inner"><span>dtype</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-e"><div class="inner"><span>e</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-ediff1d"><div class="inner"><span>ediff1d</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-einsum"><div class="inner"><span>einsum</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-einsum_path"><div class="inner"><span>einsum_path</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-emath"><div class="inner"><span>emath</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-empty"><div class="inner"><span>empty</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-empty_like"><div class="inner"><span>empty_like</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-equal"><div class="inner"><span>equal</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-ERR_CALL"><div class="inner"><span>ERR_CALL</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-ERR_DEFAULT"><div class="inner"><span>ERR_DEFAULT</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-ERR_IGNORE"><div class="inner"><span>ERR_IGNORE</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-ERR_LOG"><div class="inner"><span>ERR_LOG</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-ERR_PRINT"><div class="inner"><span>ERR_PRINT</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-ERR_RAISE"><div class="inner"><span>ERR_RAISE</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-ERR_WARN"><div class="inner"><span>ERR_WARN</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-errstate"><div class="inner"><span>errstate</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-euler_gamma"><div class="inner"><span>euler_gamma</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-exp"><div class="inner"><span>exp</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-exp2"><div class="inner"><span>exp2</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-expand_dims"><div class="inner"><span>expand_dims</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-expm1"><div class="inner"><span>expm1</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-extract"><div class="inner"><span>extract</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-eye"><div class="inner"><span>eye</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-fabs"><div class="inner"><span>fabs</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-fastCopyAndTranspose"><div class="inner"><span>fastCopyAndTranspose</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-fft"><div class="inner"><span>fft</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-fill_diagonal"><div class="inner"><span>fill_diagonal</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-find_common_type"><div class="inner"><span>find_common_type</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-finfo"><div class="inner"><span>finfo</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-fix"><div class="inner"><span>fix</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-flatiter"><div class="inner"><span>flatiter</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-flatnonzero"><div class="inner"><span>flatnonzero</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-flexible"><div class="inner"><span>flexible</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-flip"><div class="inner"><span>flip</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-fliplr"><div class="inner"><span>fliplr</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-flipud"><div class="inner"><span>flipud</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-float"><div class="inner"><span>float</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-float128"><div class="inner"><span>float128</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-float16"><div class="inner"><span>float16</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-float32"><div class="inner"><span>float32</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-float64"><div class="inner"><span>float64</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-float_"><div class="inner"><span>float_</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-float_power"><div class="inner"><span>float_power</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-floating"><div class="inner"><span>floating</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-FLOATING_POINT_SUPPORT"><div class="inner"><span>FLOATING_POINT_SUPPORT</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-floor"><div class="inner"><span>floor</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-floor_divide"><div class="inner"><span>floor_divide</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-fmax"><div class="inner"><span>fmax</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-fmin"><div class="inner"><span>fmin</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-fmod"><div class="inner"><span>fmod</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-format_float_positional"><div class="inner"><span>format_float_positional</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-format_float_scientific"><div class="inner"><span>format_float_scientific</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-format_parser"><div class="inner"><span>format_parser</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-FPE_DIVIDEBYZERO"><div class="inner"><span>FPE_DIVIDEBYZERO</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-FPE_INVALID"><div class="inner"><span>FPE_INVALID</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-FPE_OVERFLOW"><div class="inner"><span>FPE_OVERFLOW</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-FPE_UNDERFLOW"><div class="inner"><span>FPE_UNDERFLOW</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-frexp"><div class="inner"><span>frexp</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-frombuffer"><div class="inner"><span>frombuffer</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-fromfile"><div class="inner"><span>fromfile</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-fromfunction"><div class="inner"><span>fromfunction</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-fromiter"><div class="inner"><span>fromiter</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-frompyfunc"><div class="inner"><span>frompyfunc</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-fromregex"><div class="inner"><span>fromregex</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-fromstring"><div class="inner"><span>fromstring</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-full"><div class="inner"><span>full</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-full_like"><div class="inner"><span>full_like</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-fv"><div class="inner"><span>fv</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-gcd"><div class="inner"><span>gcd</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-generic"><div class="inner"><span>generic</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-genfromtxt"><div class="inner"><span>genfromtxt</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-geomspace"><div class="inner"><span>geomspace</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-get_array_wrap"><div class="inner"><span>get_array_wrap</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-get_include"><div class="inner"><span>get_include</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-get_printoptions"><div class="inner"><span>get_printoptions</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-getbufsize"><div class="inner"><span>getbufsize</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-geterr"><div class="inner"><span>geterr</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-geterrcall"><div class="inner"><span>geterrcall</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-geterrobj"><div class="inner"><span>geterrobj</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-gradient"><div class="inner"><span>gradient</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-greater"><div class="inner"><span>greater</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-greater_equal"><div class="inner"><span>greater_equal</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-half"><div class="inner"><span>half</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-hamming"><div class="inner"><span>hamming</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-hanning"><div class="inner"><span>hanning</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-heaviside"><div class="inner"><span>heaviside</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-histogram"><div class="inner"><span>histogram</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-histogram2d"><div class="inner"><span>histogram2d</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-histogram_bin_edges"><div class="inner"><span>histogram_bin_edges</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-histogramdd"><div class="inner"><span>histogramdd</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-hsplit"><div class="inner"><span>hsplit</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-hstack"><div class="inner"><span>hstack</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-hypot"><div class="inner"><span>hypot</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-i0"><div class="inner"><span>i0</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-identity"><div class="inner"><span>identity</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-iinfo"><div class="inner"><span>iinfo</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-imag"><div class="inner"><span>imag</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-in1d"><div class="inner"><span>in1d</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-index_exp"><div class="inner"><span>index_exp</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-indices"><div class="inner"><span>indices</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-inexact"><div class="inner"><span>inexact</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-Inf"><div class="inner"><span>Inf</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-inf"><div class="inner"><span>inf</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-Infinity"><div class="inner"><span>Infinity</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-info"><div class="inner"><span>info</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-infty"><div class="inner"><span>infty</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-inner"><div class="inner"><span>inner</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-insert"><div class="inner"><span>insert</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-int"><div class="inner"><span>int</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-int0"><div class="inner"><span>int0</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-int16"><div class="inner"><span>int16</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-int32"><div class="inner"><span>int32</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-int64"><div class="inner"><span>int64</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-int8"><div class="inner"><span>int8</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-int_"><div class="inner"><span>int_</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-int_asbuffer"><div class="inner"><span>int_asbuffer</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-intc"><div class="inner"><span>intc</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-integer"><div class="inner"><span>integer</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-interp"><div class="inner"><span>interp</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-intersect1d"><div class="inner"><span>intersect1d</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-intp"><div class="inner"><span>intp</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-invert"><div class="inner"><span>invert</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-ipmt"><div class="inner"><span>ipmt</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-irr"><div class="inner"><span>irr</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-is_busday"><div class="inner"><span>is_busday</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-isclose"><div class="inner"><span>isclose</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-iscomplex"><div class="inner"><span>iscomplex</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-iscomplexobj"><div class="inner"><span>iscomplexobj</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-isfinite"><div class="inner"><span>isfinite</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-isfortran"><div class="inner"><span>isfortran</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-isin"><div class="inner"><span>isin</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-isinf"><div class="inner"><span>isinf</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-isnan"><div class="inner"><span>isnan</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-isnat"><div class="inner"><span>isnat</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-isneginf"><div class="inner"><span>isneginf</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-isposinf"><div class="inner"><span>isposinf</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-isreal"><div class="inner"><span>isreal</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-isrealobj"><div class="inner"><span>isrealobj</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-isscalar"><div class="inner"><span>isscalar</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-issctype"><div class="inner"><span>issctype</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-issubclass_"><div class="inner"><span>issubclass_</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-issubdtype"><div class="inner"><span>issubdtype</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-issubsctype"><div class="inner"><span>issubsctype</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-iterable"><div class="inner"><span>iterable</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-ix_"><div class="inner"><span>ix_</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-kaiser"><div class="inner"><span>kaiser</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-kron"><div class="inner"><span>kron</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-lcm"><div class="inner"><span>lcm</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-ldexp"><div class="inner"><span>ldexp</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-left_shift"><div class="inner"><span>left_shift</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-less"><div class="inner"><span>less</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-less_equal"><div class="inner"><span>less_equal</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-lexsort"><div class="inner"><span>lexsort</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-lib"><div class="inner"><span>lib</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-linalg"><div class="inner"><span>linalg</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-linspace"><div class="inner"><span>linspace</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-little_endian"><div class="inner"><span>little_endian</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-load"><div class="inner"><span>load</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-loads"><div class="inner"><span>loads</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-loadtxt"><div class="inner"><span>loadtxt</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-log"><div class="inner"><span>log</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-log10"><div class="inner"><span>log10</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-log1p"><div class="inner"><span>log1p</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-log2"><div class="inner"><span>log2</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-logaddexp"><div class="inner"><span>logaddexp</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-logaddexp2"><div class="inner"><span>logaddexp2</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-logical_and"><div class="inner"><span>logical_and</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-logical_not"><div class="inner"><span>logical_not</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-logical_or"><div class="inner"><span>logical_or</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-logical_xor"><div class="inner"><span>logical_xor</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-logspace"><div class="inner"><span>logspace</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-long"><div class="inner"><span>long</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-longcomplex"><div class="inner"><span>longcomplex</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-longdouble"><div class="inner"><span>longdouble</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-longfloat"><div class="inner"><span>longfloat</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-longlong"><div class="inner"><span>longlong</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-lookfor"><div class="inner"><span>lookfor</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-ma"><div class="inner"><span>ma</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-MachAr"><div class="inner"><span>MachAr</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-mafromtxt"><div class="inner"><span>mafromtxt</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-mask_indices"><div class="inner"><span>mask_indices</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-mat"><div class="inner"><span>mat</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-math"><div class="inner"><span>math</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-matmul"><div class="inner"><span>matmul</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-matrix"><div class="inner"><span>matrix</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-matrixlib"><div class="inner"><span>matrixlib</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-max"><div class="inner"><span>max</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-MAXDIMS"><div class="inner"><span>MAXDIMS</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-maximum"><div class="inner"><span>maximum</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-maximum_sctype"><div class="inner"><span>maximum_sctype</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-MAY_SHARE_BOUNDS"><div class="inner"><span>MAY_SHARE_BOUNDS</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-MAY_SHARE_EXACT"><div class="inner"><span>MAY_SHARE_EXACT</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-may_share_memory"><div class="inner"><span>may_share_memory</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-mean"><div class="inner"><span>mean</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-median"><div class="inner"><span>median</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-memmap"><div class="inner"><span>memmap</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-meshgrid"><div class="inner"><span>meshgrid</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-mgrid"><div class="inner"><span>mgrid</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-min"><div class="inner"><span>min</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-min_scalar_type"><div class="inner"><span>min_scalar_type</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-minimum"><div class="inner"><span>minimum</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-mintypecode"><div class="inner"><span>mintypecode</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-mirr"><div class="inner"><span>mirr</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-mod"><div class="inner"><span>mod</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-modf"><div class="inner"><span>modf</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-ModuleDeprecationWarning"><div class="inner"><span>ModuleDeprecationWarning</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-moveaxis"><div class="inner"><span>moveaxis</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-msort"><div class="inner"><span>msort</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-multiply"><div class="inner"><span>multiply</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-NAN"><div class="inner"><span>NAN</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-NaN"><div class="inner"><span>NaN</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-nan"><div class="inner"><span>nan</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-nan_to_num"><div class="inner"><span>nan_to_num</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-nanargmax"><div class="inner"><span>nanargmax</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-nanargmin"><div class="inner"><span>nanargmin</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-nancumprod"><div class="inner"><span>nancumprod</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-nancumsum"><div class="inner"><span>nancumsum</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-nanmax"><div class="inner"><span>nanmax</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-nanmean"><div class="inner"><span>nanmean</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-nanmedian"><div class="inner"><span>nanmedian</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-nanmin"><div class="inner"><span>nanmin</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-nanpercentile"><div class="inner"><span>nanpercentile</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-nanprod"><div class="inner"><span>nanprod</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-nanquantile"><div class="inner"><span>nanquantile</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-nanstd"><div class="inner"><span>nanstd</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-nansum"><div class="inner"><span>nansum</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-nanvar"><div class="inner"><span>nanvar</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-nbytes"><div class="inner"><span>nbytes</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-ndarray"><div class="inner"><span>ndarray</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-ndenumerate"><div class="inner"><span>ndenumerate</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-ndfromtxt"><div class="inner"><span>ndfromtxt</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-ndim"><div class="inner"><span>ndim</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-ndindex"><div class="inner"><span>ndindex</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-nditer"><div class="inner"><span>nditer</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-negative"><div class="inner"><span>negative</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-nested_iters"><div class="inner"><span>nested_iters</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-nextafter"><div class="inner"><span>nextafter</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-NINF"><div class="inner"><span>NINF</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-nonzero"><div class="inner"><span>nonzero</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-not_equal"><div class="inner"><span>not_equal</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-nper"><div class="inner"><span>nper</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-npv"><div class="inner"><span>npv</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-numarray"><div class="inner"><span>numarray</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-number"><div class="inner"><span>number</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-NZERO"><div class="inner"><span>NZERO</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-obj2sctype"><div class="inner"><span>obj2sctype</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-object"><div class="inner"><span>object</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-object0"><div class="inner"><span>object0</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-object_"><div class="inner"><span>object_</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-ogrid"><div class="inner"><span>ogrid</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-oldnumeric"><div class="inner"><span>oldnumeric</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-ones"><div class="inner"><span>ones</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-ones_like"><div class="inner"><span>ones_like</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-outer"><div class="inner"><span>outer</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-packbits"><div class="inner"><span>packbits</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-pad"><div class="inner"><span>pad</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-partition"><div class="inner"><span>partition</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-percentile"><div class="inner"><span>percentile</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-pi"><div class="inner"><span>pi</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-piecewise"><div class="inner"><span>piecewise</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-PINF"><div class="inner"><span>PINF</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-place"><div class="inner"><span>place</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-pmt"><div class="inner"><span>pmt</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-poly"><div class="inner"><span>poly</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-poly1d"><div class="inner"><span>poly1d</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-polyadd"><div class="inner"><span>polyadd</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-polyder"><div class="inner"><span>polyder</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-polydiv"><div class="inner"><span>polydiv</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-polyfit"><div class="inner"><span>polyfit</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-polyint"><div class="inner"><span>polyint</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-polymul"><div class="inner"><span>polymul</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-polynomial"><div class="inner"><span>polynomial</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-polysub"><div class="inner"><span>polysub</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-polyval"><div class="inner"><span>polyval</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-positive"><div class="inner"><span>positive</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-power"><div class="inner"><span>power</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-ppmt"><div class="inner"><span>ppmt</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-print_function"><div class="inner"><span>print_function</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-printoptions"><div class="inner"><span>printoptions</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-prod"><div class="inner"><span>prod</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-product"><div class="inner"><span>product</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-promote_types"><div class="inner"><span>promote_types</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-ptp"><div class="inner"><span>ptp</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-put"><div class="inner"><span>put</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-put_along_axis"><div class="inner"><span>put_along_axis</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-putmask"><div class="inner"><span>putmask</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-pv"><div class="inner"><span>pv</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-PZERO"><div class="inner"><span>PZERO</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-quantile"><div class="inner"><span>quantile</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-r_"><div class="inner"><span>r_</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-rad2deg"><div class="inner"><span>rad2deg</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-radians"><div class="inner"><span>radians</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-RAISE"><div class="inner"><span>RAISE</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-random"><div class="inner"><span>random</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-RankWarning"><div class="inner"><span>RankWarning</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-rate"><div class="inner"><span>rate</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-ravel"><div class="inner"><span>ravel</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-ravel_multi_index"><div class="inner"><span>ravel_multi_index</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-real"><div class="inner"><span>real</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-real_if_close"><div class="inner"><span>real_if_close</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-rec"><div class="inner"><span>rec</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-recarray"><div class="inner"><span>recarray</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-recfromcsv"><div class="inner"><span>recfromcsv</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-recfromtxt"><div class="inner"><span>recfromtxt</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-reciprocal"><div class="inner"><span>reciprocal</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-record"><div class="inner"><span>record</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-remainder"><div class="inner"><span>remainder</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-repeat"><div class="inner"><span>repeat</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-require"><div class="inner"><span>require</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-reshape"><div class="inner"><span>reshape</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-resize"><div class="inner"><span>resize</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-result_type"><div class="inner"><span>result_type</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-right_shift"><div class="inner"><span>right_shift</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-rint"><div class="inner"><span>rint</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-roll"><div class="inner"><span>roll</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-rollaxis"><div class="inner"><span>rollaxis</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-roots"><div class="inner"><span>roots</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-rot90"><div class="inner"><span>rot90</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-round"><div class="inner"><span>round</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-round_"><div class="inner"><span>round_</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-row_stack"><div class="inner"><span>row_stack</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-s_"><div class="inner"><span>s_</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-safe_eval"><div class="inner"><span>safe_eval</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-save"><div class="inner"><span>save</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-savetxt"><div class="inner"><span>savetxt</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-savez"><div class="inner"><span>savez</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-savez_compressed"><div class="inner"><span>savez_compressed</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-ScalarType"><div class="inner"><span>ScalarType</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-sctype2char"><div class="inner"><span>sctype2char</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-sctypeDict"><div class="inner"><span>sctypeDict</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-sctypeNA"><div class="inner"><span>sctypeNA</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-sctypes"><div class="inner"><span>sctypes</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-searchsorted"><div class="inner"><span>searchsorted</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-select"><div class="inner"><span>select</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-set_numeric_ops"><div class="inner"><span>set_numeric_ops</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-set_printoptions"><div class="inner"><span>set_printoptions</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-set_string_function"><div class="inner"><span>set_string_function</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-setbufsize"><div class="inner"><span>setbufsize</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-setdiff1d"><div class="inner"><span>setdiff1d</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-seterr"><div class="inner"><span>seterr</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-seterrcall"><div class="inner"><span>seterrcall</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-seterrobj"><div class="inner"><span>seterrobj</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-setxor1d"><div class="inner"><span>setxor1d</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-shape"><div class="inner"><span>shape</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-shares_memory"><div class="inner"><span>shares_memory</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-SHIFT_DIVIDEBYZERO"><div class="inner"><span>SHIFT_DIVIDEBYZERO</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-SHIFT_INVALID"><div class="inner"><span>SHIFT_INVALID</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-SHIFT_OVERFLOW"><div class="inner"><span>SHIFT_OVERFLOW</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-SHIFT_UNDERFLOW"><div class="inner"><span>SHIFT_UNDERFLOW</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-short"><div class="inner"><span>short</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-show_config"><div class="inner"><span>show_config</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-sign"><div class="inner"><span>sign</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-signbit"><div class="inner"><span>signbit</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-signedinteger"><div class="inner"><span>signedinteger</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-sin"><div class="inner"><span>sin</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-sinc"><div class="inner"><span>sinc</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-single"><div class="inner"><span>single</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-singlecomplex"><div class="inner"><span>singlecomplex</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-sinh"><div class="inner"><span>sinh</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-size"><div class="inner"><span>size</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-sometrue"><div class="inner"><span>sometrue</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-sort"><div class="inner"><span>sort</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-sort_complex"><div class="inner"><span>sort_complex</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-source"><div class="inner"><span>source</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-spacing"><div class="inner"><span>spacing</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-split"><div class="inner"><span>split</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-sqrt"><div class="inner"><span>sqrt</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-square"><div class="inner"><span>square</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-squeeze"><div class="inner"><span>squeeze</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-stack"><div class="inner"><span>stack</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-std"><div class="inner"><span>std</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-str"><div class="inner"><span>str</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-str0"><div class="inner"><span>str0</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-str_"><div class="inner"><span>str_</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-string_"><div class="inner"><span>string_</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-subtract"><div class="inner"><span>subtract</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-sum"><div class="inner"><span>sum</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-swapaxes"><div class="inner"><span>swapaxes</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-sys"><div class="inner"><span>sys</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-take"><div class="inner"><span>take</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-take_along_axis"><div class="inner"><span>take_along_axis</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-tan"><div class="inner"><span>tan</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-tanh"><div class="inner"><span>tanh</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-tensordot"><div class="inner"><span>tensordot</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-test"><div class="inner"><span>test</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-tile"><div class="inner"><span>tile</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-timedelta64"><div class="inner"><span>timedelta64</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-TooHardError"><div class="inner"><span>TooHardError</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-trace"><div class="inner"><span>trace</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-tracemalloc_domain"><div class="inner"><span>tracemalloc_domain</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-transpose"><div class="inner"><span>transpose</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-trapz"><div class="inner"><span>trapz</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-tri"><div class="inner"><span>tri</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-tril"><div class="inner"><span>tril</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-tril_indices"><div class="inner"><span>tril_indices</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-tril_indices_from"><div class="inner"><span>tril_indices_from</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-trim_zeros"><div class="inner"><span>trim_zeros</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-triu"><div class="inner"><span>triu</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-triu_indices"><div class="inner"><span>triu_indices</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-triu_indices_from"><div class="inner"><span>triu_indices_from</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-True_"><div class="inner"><span>True_</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-true_divide"><div class="inner"><span>true_divide</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-trunc"><div class="inner"><span>trunc</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-typecodes"><div class="inner"><span>typecodes</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-typeDict"><div class="inner"><span>typeDict</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-typeNA"><div class="inner"><span>typeNA</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-typename"><div class="inner"><span>typename</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-ubyte"><div class="inner"><span>ubyte</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-ufunc"><div class="inner"><span>ufunc</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-UFUNC_BUFSIZE_DEFAULT"><div class="inner"><span>UFUNC_BUFSIZE_DEFAULT</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-UFUNC_PYVALS_NAME"><div class="inner"><span>UFUNC_PYVALS_NAME</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-uint"><div class="inner"><span>uint</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-uint0"><div class="inner"><span>uint0</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-uint16"><div class="inner"><span>uint16</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-uint32"><div class="inner"><span>uint32</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-uint64"><div class="inner"><span>uint64</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-uint8"><div class="inner"><span>uint8</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-uintc"><div class="inner"><span>uintc</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-uintp"><div class="inner"><span>uintp</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-ulonglong"><div class="inner"><span>ulonglong</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-unicode"><div class="inner"><span>unicode</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-unicode_"><div class="inner"><span>unicode_</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-union1d"><div class="inner"><span>union1d</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-unique"><div class="inner"><span>unique</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-unpackbits"><div class="inner"><span>unpackbits</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-unravel_index"><div class="inner"><span>unravel_index</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-unsignedinteger"><div class="inner"><span>unsignedinteger</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-unwrap"><div class="inner"><span>unwrap</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-ushort"><div class="inner"><span>ushort</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-vander"><div class="inner"><span>vander</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-var"><div class="inner"><span>var</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-vdot"><div class="inner"><span>vdot</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-vectorize"><div class="inner"><span>vectorize</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-version"><div class="inner"><span>version</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-VisibleDeprecationWarning"><div class="inner"><span>VisibleDeprecationWarning</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-void"><div class="inner"><span>void</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-void0"><div class="inner"><span>void0</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-vsplit"><div class="inner"><span>vsplit</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-vstack"><div class="inner"><span>vstack</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-warnings"><div class="inner"><span>warnings</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-where"><div class="inner"><span>where</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-who"><div class="inner"><span>who</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-WRAP"><div class="inner"><span>WRAP</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-zeros"><div class="inner"><span>zeros</span></div></a></li><li class="depth-1"><a href="python.numpy.html#var-zeros_like"><div class="inner"><span>zeros_like</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">python.numpy</h1><div class="doc"><div class="markdown"><p>No documentation provided</p></div></div><div class="public anchor" id="var-__all__"><h3>__all__</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Built-in mutable sequence.</p>
<p>If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L9546">view source</a></div></div><div class="public anchor" id="var-__builtins__"><h3>__builtins__</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping objects  (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:  d = {}  for k, v in iterable:  d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs  in the keyword argument list. For example: dict(one=1, two=2)</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L20341">view source</a></div></div><div class="public anchor" id="var-__cached__"><h3>__cached__</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L1128">view source</a></div></div><div class="public anchor" id="var-__config__"><h3>__config__</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L1397">view source</a></div></div><div class="public anchor" id="var-__dir__"><h3>__dir__</h3><div class="usage"><code>(__dir__)</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L15418">view source</a></div></div><div class="public anchor" id="var-__doc__"><h3>__doc__</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L24488">view source</a></div></div><div class="public anchor" id="var-__file__"><h3>__file__</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L12395">view source</a></div></div><div class="public anchor" id="var-__getattr__"><h3>__getattr__</h3><div class="usage"><code>(__getattr__ attr)</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L11936">view source</a></div></div><div class="public anchor" id="var-__git_revision__"><h3>__git_revision__</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L21934">view source</a></div></div><div class="public anchor" id="var-__loader__"><h3>__loader__</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Concrete implementation of SourceLoader using the file system.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L8866">view source</a></div></div><div class="public anchor" id="var-__name__"><h3>__name__</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L25727">view source</a></div></div><div class="public anchor" id="var-__package__"><h3>__package__</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L27881">view source</a></div></div><div class="public anchor" id="var-__path__"><h3>__path__</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Built-in mutable sequence.</p>
<p>If no argument is given, the constructor creates a new empty list. The argument must be an iterable if specified.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L13526">view source</a></div></div><div class="public anchor" id="var-__spec__"><h3>__spec__</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>The specification for a module, used for loading.</p>
<p>A modules spec is the source for information about the module. For data associated with the module, including source, use the specs loader.</p>
<p><code>name</code> is the absolute name of the module. <code>loader</code> is the loader to use when loading the module. <code>parent</code> is the name of the package the module is in. The parent is derived from the name.</p>
<p><code>is_package</code> determines if the module is considered a package or not. On modules this is reflected by the <code>__path__</code> attribute.</p>
<p><code>origin</code> is the specific location used by the loader from which to load the module, if that information is available. When filename is set, origin will match.</p>
<p><code>has_location</code> indicates that a specs origin reflects a location. When this is True, <code>__file__</code> attribute of the module is set.</p>
<p><code>cached</code> is the location of the cached bytecode file, if any. It corresponds to the <code>__cached__</code> attribute.</p>
<p><code>submodule_search_locations</code> is the sequence of path entries to search when importing submodules. If set, is_package should be Trueand False otherwise.</p>
<p>Packages are simply modules that (may) have submodules. If a spec has a non-None value in <code>submodule_search_locations</code>, the import system will consider modules loaded from the spec as packages.</p>
<p>Only finders (see importlib.abc.MetaPathFinder and importlib.abc.PathEntryFinder) should modify ModuleSpec instances.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L18000">view source</a></div></div><div class="public anchor" id="var-__version__"><h3>__version__</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L21898">view source</a></div></div><div class="public anchor" id="var-_add_newdoc_ufunc"><h3>_add_newdoc_ufunc</h3><div class="usage"><code>(_add_newdoc_ufunc self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>add_ufunc_docstring(ufunc, new_docstring)</p>
<p>Replace the docstring for a ufunc with new_docstring. This method will only work if the current docstring for the ufunc is NULL. (At the C level, i.e. when ufunc-&gt;doc is NULL.)</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>ufunc : numpy.ufunc  A ufunc whose current doc is NULL. new_docstring : string  The new docstring for the ufunc.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>This method allocates memory for new_docstring on the heap. Technically this creates a mempory leak, since this memory will not be reclaimed until the end of the program even if the ufunc itself is removed. However this will only be a problem if the user is repeatedly creating ufuncs with no documentation, adding documentation via add_newdoc_ufunc, and then throwing away the ufunc.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L21334">view source</a></div></div><div class="public anchor" id="var-_distributor_init"><h3>_distributor_init</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Distributor init file</p>
<p>Distributors: you can add custom code here to support particular distributions of numpy.</p>
<p>For example, this is a good place to put any checks for hardware requirements.</p>
<p>The numpy standard source distribution will not put code in this file, so you can safely replace this file with your own version.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L28970">view source</a></div></div><div class="public anchor" id="var-_globals"><h3>_globals</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Module defining global singleton classes.</p>
<p>This module raises a RuntimeError if an attempt to reload it is made. In that way the identities of the classes defined here are fixed and will remain so even if numpy itself is reloaded. In particular, a function like the following will still work correctly after numpy is reloaded::</p>
<pre><code>def foo(arg=np._NoValue):
    if arg is np._NoValue:
        ...
</code></pre>
<p>That was not the case when the singleton classes were defined in the numpy <code>__init__.py</code> file. See gh-7844 for a discussion of the reload problem that motivated this module.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L20801">view source</a></div></div><div class="public anchor" id="var-_mat"><h3>_mat</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Sub-package containing the matrix class and related functions.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L3786">view source</a></div></div><div class="public anchor" id="var-_NoValue"><h3>_NoValue</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Special keyword value.</p>
<p>The instance of this class may be used as the default value assigned to a deprecated keyword in order to check if it has been given a user defined value.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L13726">view source</a></div></div><div class="public anchor" id="var-_pytesttester"><h3>_pytesttester</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Pytest test running.</p>
<p>This module implements the <code>test()</code> function for NumPy modules. The usual boiler plate for doing that is to put the following in the module <code>__init__.py</code> file::</p>
<pre><code>from numpy._pytesttester import PytestTester
test = PytestTester(__name__).test
del PytestTester
</code></pre>
<p>Warnings filtering and other runtime settings should be dealt with in the <code>pytest.ini</code> file in the numpy repo root. The behavior of the test depends on whether or not that file is found as follows:</p>
<ul>
  <li><code>pytest.ini</code> is present (develop mode) All warnings except those explicily filtered out are raised as error.</li>
  <li><code>pytest.ini</code> is absent (release mode) DeprecationWarnings and PendingDeprecationWarnings are ignored, other warnings are passed through.</li>
</ul>
<p>In practice, tests run from the numpy repo are run in develop mode. That includes the standard <code>python runtests.py</code> invocation.</p>
<p>This module is imported by every numpy subpackage, so lies at the top level to simplify circular import issues. For the same reason, it contains no numpy imports at module scope, instead importing numpy within function calls.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L14837">view source</a></div></div><div class="public anchor" id="var-_UFUNC_API"><h3>_UFUNC_API</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Capsule objects let you wrap a C "void *" pointer in a Python object. Theyre a way of passing data through the Python interpreter without creating your own custom type.</p>
<p>Capsules are used for communication between extension modules. They provide a way for an extension module to export a C interface to other extension modules, so that extension modules can use the Python import mechanism to link to one another.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L8207">view source</a></div></div><div class="public anchor" id="var-abs"><h3>abs</h3><div class="usage"><code>(abs self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>absolute(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Calculate the absolute value element-wise.</p>
<p><code>np.abs</code> is a shorthand for this function.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Input array. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>absolute : ndarray  An ndarray containing the absolute value of  each element in <code>x</code>. For complex input, <code>a + ib</code>, the  absolute value is :math:<code>\sqrt{ a^2 + b^2 }</code>.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.array([-1.2, 1.2]) np.absolute(x) array([ 1.2, 1.2]) np.absolute(1.2 + 1j) 1.5620499351813308</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Plot the function over <code>[-10, 10]</code>:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>import matplotlib.pyplot as plt</p>
      <p>x = np.linspace(start=-10, stop=10, num=101) plt.plot(x, np.absolute(x)) plt.show()</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Plot the function over the complex plane:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>xx = x + 1j * x[:, np.newaxis] plt.imshow(np.abs(xx), extent=[-10, 10, -10, 10], cmap=gray) plt.show()</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L20709">view source</a></div></div><div class="public anchor" id="var-absolute"><h3>absolute</h3><div class="usage"><code>(absolute self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>absolute(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Calculate the absolute value element-wise.</p>
<p><code>np.abs</code> is a shorthand for this function.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Input array. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>absolute : ndarray  An ndarray containing the absolute value of  each element in <code>x</code>. For complex input, <code>a + ib</code>, the  absolute value is :math:<code>\sqrt{ a^2 + b^2 }</code>.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.array([-1.2, 1.2]) np.absolute(x) array([ 1.2, 1.2]) np.absolute(1.2 + 1j) 1.5620499351813308</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Plot the function over <code>[-10, 10]</code>:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>import matplotlib.pyplot as plt</p>
      <p>x = np.linspace(start=-10, stop=10, num=101) plt.plot(x, np.absolute(x)) plt.show()</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Plot the function over the complex plane:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>xx = x + 1j * x[:, np.newaxis] plt.imshow(np.abs(xx), extent=[-10, 10, -10, 10], cmap=gray) plt.show()</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L27150">view source</a></div></div><div class="public anchor" id="var-absolute_import"><h3>absolute_import</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L3784">view source</a></div></div><div class="public anchor" id="var-add"><h3>add</h3><div class="usage"><code>(add self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>add(x1, x2, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Add arguments element-wise.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x1, x2 : array_like  The arrays to be added. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output). out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>add : ndarray or scalar  The sum of <code>x1</code> and <code>x2</code>, element-wise.  This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Equivalent to <code>x1</code> + <code>x2</code> in terms of array broadcasting.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.add(1.0, 4.0) 5.0 x1 = np.arange(9.0).reshape((3, 3)) x2 = np.arange(3.0) np.add(x1, x2) array(<a href="null">  0.,   2.,   4.],
       [  3.,   5.,   7.],
       [  6.,   8.,  10.</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L22784">view source</a></div></div><div class="public anchor" id="var-add_docstring"><h3>add_docstring</h3><div class="usage"><code>(add_docstring self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>add_docstring(obj, docstring)</p>
<p>Add a docstring to a built-in obj if possible. If the obj already has a docstring raise a RuntimeError If this routine does not know how to add a docstring to the object raise a TypeError</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L28981">view source</a></div></div><div class="public anchor" id="var-add_newdoc"><h3>add_newdoc</h3><div class="usage"><code>(add_newdoc place obj doc &amp; [{warn_on_python :warn_on_python}])</code><code>(add_newdoc place obj doc)</code></div><div class="doc"><div class="markdown"><p>Add documentation to an existing object, typically one defined in C</p>
<p>The purpose is to allow easier editing of the docstrings without requiring a re-compile. This exists primarily for internal use within numpy itself.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>place : str  The absolute name of the module to import from obj : str  The name of the object to add documentation to, typically a class or  function name doc : {str, Tuple[str, str], List[Tuple[str, str]]}  If a string, the documentation to apply to <code>obj</code></p>
<pre><code>If a tuple, then the first element is interpreted as an attribute of
`obj` and the second as the docstring to apply - ``(method, docstring)``

If a list, then each element of the list should be a tuple of length
two - ``[(method1, docstring1), (method2, docstring2), ...]``
</code></pre>
<p>warn_on_python : bool  If True, the default, emit <code>UserWarning</code> if this is used to attach  documentation to a pure-python object.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>This routine never raises an error if the docstring cant be written, but will raise an error if the object being documented does not exist.</p>
<p>This routine cannot modify read-only docstrings, as appear in new-style classes or built-in functions. Because this routine never raises an error the caller must check manually that the docstrings were changed.</p>
<p>Since this function grabs the <code>char *</code> from a c-level str object and puts it into the <code>tp_doc</code> slot of the type of <code>obj</code>, it violates a number of C-API best-practices, by:</p>
<ul>
  <li>modifying a <code>PyTypeObject</code> after calling <code>PyType_Ready</code></li>
  <li>calling <code>Py_INCREF</code> on the str and losing the reference, so the str  will never be released</li>
</ul>
<p>If possible it should be avoided.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L3737">view source</a></div></div><div class="public anchor" id="var-add_newdoc_ufunc"><h3>add_newdoc_ufunc</h3><div class="usage"><code>(add_newdoc_ufunc self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>add_ufunc_docstring(ufunc, new_docstring)</p>
<p>Replace the docstring for a ufunc with new_docstring. This method will only work if the current docstring for the ufunc is NULL. (At the C level, i.e. when ufunc-&gt;doc is NULL.)</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>ufunc : numpy.ufunc  A ufunc whose current doc is NULL. new_docstring : string  The new docstring for the ufunc.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>This method allocates memory for new_docstring on the heap. Technically this creates a mempory leak, since this memory will not be reclaimed until the end of the program even if the ufunc itself is removed. However this will only be a problem if the user is repeatedly creating ufuncs with no documentation, adding documentation via add_newdoc_ufunc, and then throwing away the ufunc.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L8568">view source</a></div></div><div class="public anchor" id="var-alen"><h3>alen</h3><div class="usage"><code>(alen &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return the length of the first dimension of the input array.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input array.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>alen : int  Length of the first dimension of <code>a</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>shape, size</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.zeros((7,4,5)) a.shape[0] 7 np.alen(a) 7</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L1399">view source</a></div></div><div class="public anchor" id="var-all"><h3>all</h3><div class="usage"><code>(all &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Test whether all array elements along a given axis evaluate to True.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input array or object that can be converted to an array. axis : None or int or tuple of ints, optional  Axis or axes along which a logical AND reduction is performed.  The default (<code>axis=None</code>) is to perform a logical AND over all  the dimensions of the input array. <code>axis</code> may be negative, in  which case it counts from the last to the first axis.</p>
<pre><code>.. versionadded:: 1.7.0

If this is a tuple of ints, a reduction is performed on multiple
axes, instead of a single axis or all the axes as before.
</code></pre>
<p>out : ndarray, optional  Alternate output array in which to place the result.  It must have the same shape as the expected output and its  type is preserved (e.g., if <code>dtype(out)</code> is float, the result  will consist of 0.0s and 1.0s). See <code>ufuncs-output-type</code> for more  details.</p>
<p>keepdims : bool, optional  If this is set to True, the axes which are reduced are left  in the result as dimensions with size one. With this option,  the result will broadcast correctly against the input array.</p>
<pre><code>If the default value is passed, then `keepdims` will not be
passed through to the `all` method of sub-classes of
`ndarray`, however any non-default value will be.  If the
sub-class' method does not implement `keepdims` any
exceptions will be raised.
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>all : ndarray, bool  A new boolean or array is returned unless <code>out</code> is specified,  in which case a reference to <code>out</code> is returned.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>ndarray.all : equivalent method</p>
<p>any : Test whether any element along a given axis evaluates to True.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Not a Number (NaN), positive infinity and negative infinity evaluate to <code>True</code> because these are not equal to zero.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.all(<a href="null">True,False],[True,True</a>) False</p>
      <p>np.all(<a href="null">True,False],[True,True</a>, axis=0) array([ True, False])</p>
      <p>np.all([-1, 4, 5]) True</p>
      <p>np.all([1.0, np.nan]) True</p>
      <p>o=np.array(False) z=np.all([-1, 4, 5], out=o) id(z), id(o), z (28293632, 28293632, array(True)) # may vary</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L23411">view source</a></div></div><div class="public anchor" id="var-allclose"><h3>allclose</h3><div class="usage"><code>(allclose &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Returns True if two arrays are element-wise equal within a tolerance.</p>
<p>The tolerance values are positive, typically very small numbers. The relative difference (<code>rtol</code> * abs(<code>b</code>)) and the absolute difference <code>atol</code> are added together to compare against the absolute difference between <code>a</code> and <code>b</code>.</p>
<p>NaNs are treated as equal if they are in the same place and if <code>equal_nan=True</code>. Infs are treated as equal if they are in the same place and of the same sign in both arrays.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a, b : array_like  Input arrays to compare. rtol : float  The relative tolerance parameter (see Notes). atol : float  The absolute tolerance parameter (see Notes). equal_nan : bool  Whether to compare NaNs as equal. If True, NaNs in <code>a</code> will be  considered equal to NaNs in <code>b</code> in the output array.</p>
<pre><code>.. versionadded:: 1.10.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>allclose : bool  Returns True if the two arrays are equal within the given  tolerance; False otherwise.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>isclose, all, any, equal</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>If the following equation is element-wise True, then allclose returns True.</p>
<p>absolute(<code>a</code> - <code>b</code>) &lt;= (<code>atol</code> + <code>rtol</code> * absolute(<code>b</code>))</p>
<p>The above equation is not symmetric in <code>a</code> and <code>b</code>, so that <code>allclose(a, b)</code> might be different from <code>allclose(b, a)</code> in some rare cases.</p>
<p>The comparison of <code>a</code> and <code>b</code> uses standard broadcasting, which means that <code>a</code> and <code>b</code> need not have the same shape in order for <code>allclose(a, b)</code> to evaluate to True. The same is true for <code>equal</code> but not <code>array_equal</code>.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.allclose([1e10,1e-7], [1.00001e10,1e-8]) False np.allclose([1e10,1e-8], [1.00001e10,1e-9]) True np.allclose([1e10,1e-8], [1.0001e10,1e-9]) False np.allclose([1.0, np.nan], [1.0, np.nan]) False np.allclose([1.0, np.nan], [1.0, np.nan], equal_nan=True) True</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L23992">view source</a></div></div><div class="public anchor" id="var-ALLOW_THREADS"><h3>ALLOW_THREADS</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L16466">view source</a></div></div><div class="public anchor" id="var-alltrue"><h3>alltrue</h3><div class="usage"><code>(alltrue &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Check if all elements of input array are true.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>numpy.all : Equivalent function; see for details.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L6907">view source</a></div></div><div class="public anchor" id="var-amax"><h3>amax</h3><div class="usage"><code>(amax &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return the maximum of an array or maximum along an axis.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input data. axis : None or int or tuple of ints, optional  Axis or axes along which to operate. By default, flattened input is  used.</p>
<pre><code>.. versionadded:: 1.7.0

If this is a tuple of ints, the maximum is selected over multiple axes,
instead of a single axis or all the axes as before.
</code></pre>
<p>out : ndarray, optional  Alternative output array in which to place the result. Must  be of the same shape and buffer length as the expected output.  See <code>ufuncs-output-type</code> for more details.</p>
<p>keepdims : bool, optional  If this is set to True, the axes which are reduced are left  in the result as dimensions with size one. With this option,  the result will broadcast correctly against the input array.</p>
<pre><code>If the default value is passed, then `keepdims` will not be
passed through to the `amax` method of sub-classes of
`ndarray`, however any non-default value will be.  If the
sub-class' method does not implement `keepdims` any
exceptions will be raised.
</code></pre>
<p>initial : scalar, optional  The minimum value of an output element. Must be present to allow  computation on empty slice. See <code>~numpy.ufunc.reduce</code> for details.</p>
<pre><code>.. versionadded:: 1.15.0
</code></pre>
<p>where : array_like of bool, optional  Elements to compare for the maximum. See <code>~numpy.ufunc.reduce</code>  for details.</p>
<pre><code>.. versionadded:: 1.17.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>amax : ndarray or scalar  Maximum of <code>a</code>. If <code>axis</code> is None, the result is a scalar value.  If <code>axis</code> is given, the result is an array of dimension  <code>a.ndim - 1</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>amin :  The minimum value of an array along a given axis, propagating any NaNs. nanmax :  The maximum value of an array along a given axis, ignoring any NaNs. maximum :  Element-wise maximum of two arrays, propagating any NaNs. fmax :  Element-wise maximum of two arrays, ignoring any NaNs. argmax :  Return the indices of the maximum values.</p>
<p>nanmin, minimum, fmin</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>NaN values are propagated, that is if at least one item is NaN, the corresponding max value will be NaN as well. To ignore NaN values (MATLAB behavior), please use nanmax.</p>
<p>Dont use <code>amax</code> for element-wise comparison of 2 arrays; when <code>a.shape[0]</code> is 2, <code>maximum(a[0], a[1])</code> is faster than <code>amax(a, axis=0)</code>.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.arange(4).reshape((2,2)) a array(<a href="null">0, 1],
       [2, 3</a>) np.amax(a) # Maximum of the flattened array 3 np.amax(a, axis=0) # Maxima along the first axis array([2, 3]) np.amax(a, axis=1) # Maxima along the second axis array([1, 3]) np.amax(a, where=[False, True], initial=-1, axis=0) array([-1, 3]) b = np.arange(5, dtype=float) b[2] = np.NaN np.amax(b) nan np.amax(b, where=~np.isnan(b), initial=-1) 4.0 np.nanmax(b) 4.0</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>You can use an initial value to compute the maximum of an empty slice, or to initialize it to a different value:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.max(<a href="null">-50], [10</a>, axis=-1, initial=0) array([ 0, 10])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Notice that the initial value is used as one of the elements for which the maximum is determined, unlike for the default argument Pythons max function, which is only used for empty iterables.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.max([5], initial=6) 6 max([5], default=6) 5</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L23296">view source</a></div></div><div class="public anchor" id="var-amin"><h3>amin</h3><div class="usage"><code>(amin &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return the minimum of an array or minimum along an axis.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input data. axis : None or int or tuple of ints, optional  Axis or axes along which to operate. By default, flattened input is  used.</p>
<pre><code>.. versionadded:: 1.7.0

If this is a tuple of ints, the minimum is selected over multiple axes,
instead of a single axis or all the axes as before.
</code></pre>
<p>out : ndarray, optional  Alternative output array in which to place the result. Must  be of the same shape and buffer length as the expected output.  See <code>ufuncs-output-type</code> for more details.</p>
<p>keepdims : bool, optional  If this is set to True, the axes which are reduced are left  in the result as dimensions with size one. With this option,  the result will broadcast correctly against the input array.</p>
<pre><code>If the default value is passed, then `keepdims` will not be
passed through to the `amin` method of sub-classes of
`ndarray`, however any non-default value will be.  If the
sub-class' method does not implement `keepdims` any
exceptions will be raised.
</code></pre>
<p>initial : scalar, optional  The maximum value of an output element. Must be present to allow  computation on empty slice. See <code>~numpy.ufunc.reduce</code> for details.</p>
<pre><code>.. versionadded:: 1.15.0
</code></pre>
<p>where : array_like of bool, optional  Elements to compare for the minimum. See <code>~numpy.ufunc.reduce</code>  for details.</p>
<pre><code>.. versionadded:: 1.17.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>amin : ndarray or scalar  Minimum of <code>a</code>. If <code>axis</code> is None, the result is a scalar value.  If <code>axis</code> is given, the result is an array of dimension  <code>a.ndim - 1</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>amax :  The maximum value of an array along a given axis, propagating any NaNs. nanmin :  The minimum value of an array along a given axis, ignoring any NaNs. minimum :  Element-wise minimum of two arrays, propagating any NaNs. fmin :  Element-wise minimum of two arrays, ignoring any NaNs. argmin :  Return the indices of the minimum values.</p>
<p>nanmax, maximum, fmax</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>NaN values are propagated, that is if at least one item is NaN, the corresponding min value will be NaN as well. To ignore NaN values (MATLAB behavior), please use nanmin.</p>
<p>Dont use <code>amin</code> for element-wise comparison of 2 arrays; when <code>a.shape[0]</code> is 2, <code>minimum(a[0], a[1])</code> is faster than <code>amin(a, axis=0)</code>.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.arange(4).reshape((2,2)) a array(<a href="null">0, 1],
       [2, 3</a>) np.amin(a) # Minimum of the flattened array 0 np.amin(a, axis=0) # Minima along the first axis array([0, 1]) np.amin(a, axis=1) # Minima along the second axis array([0, 2]) np.amin(a, where=[False, True], initial=10, axis=0) array([10, 1])</p>
      <p>b = np.arange(5, dtype=float) b[2] = np.NaN np.amin(b) nan np.amin(b, where=~np.isnan(b), initial=10) 0.0 np.nanmin(b) 0.0</p>
      <p>np.min(<a href="null">-50], [10</a>, axis=-1, initial=0) array([-50, 0])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Notice that the initial value is used as one of the elements for which the minimum is determined, unlike for the default argument Pythons max function, which is only used for empty iterables.</p>
<p>Notice that this isnt the same as Pythons <code>default</code> argument.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.min([6], initial=5) 5 min([6], default=5) 6</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L24071">view source</a></div></div><div class="public anchor" id="var-angle"><h3>angle</h3><div class="usage"><code>(angle &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return the angle of the complex argument.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>z : array_like  A complex number or sequence of complex numbers. deg : bool, optional  Return angle in degrees if True, radians if False (default).</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>angle : ndarray or scalar  The counterclockwise angle from the positive real axis on the complex  plane in the range <code>(-pi, pi]</code>, with dtype as numpy.float64.</p>
<pre><code>..versionchanged:: 1.16.0
    This function works on subclasses of ndarray like `ma.array`.
</code></pre>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>arctan2 absolute</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.angle([1.0, 1.0j, 1+1j]) # in radians array([ 0. , 1.57079633, 0.78539816]) # may vary np.angle(1+1j, deg=True) # in degrees 45.0</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L13817">view source</a></div></div><div class="public anchor" id="var-any"><h3>any</h3><div class="usage"><code>(any &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Test whether any array element along a given axis evaluates to True.</p>
<p>Returns single boolean unless <code>axis</code> is not <code>None</code></p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input array or object that can be converted to an array. axis : None or int or tuple of ints, optional  Axis or axes along which a logical OR reduction is performed.  The default (<code>axis=None</code>) is to perform a logical OR over all  the dimensions of the input array. <code>axis</code> may be negative, in  which case it counts from the last to the first axis.</p>
<pre><code>.. versionadded:: 1.7.0

If this is a tuple of ints, a reduction is performed on multiple
axes, instead of a single axis or all the axes as before.
</code></pre>
<p>out : ndarray, optional  Alternate output array in which to place the result. It must have  the same shape as the expected output and its type is preserved  (e.g., if it is of type float, then it will remain so, returning  1.0 for True and 0.0 for False, regardless of the type of <code>a</code>).  See <code>ufuncs-output-type</code> for more details.</p>
<p>keepdims : bool, optional  If this is set to True, the axes which are reduced are left  in the result as dimensions with size one. With this option,  the result will broadcast correctly against the input array.</p>
<pre><code>If the default value is passed, then `keepdims` will not be
passed through to the `any` method of sub-classes of
`ndarray`, however any non-default value will be.  If the
sub-class' method does not implement `keepdims` any
exceptions will be raised.
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>any : bool or ndarray  A new boolean or <code>ndarray</code> is returned unless <code>out</code> is specified,  in which case a reference to <code>out</code> is returned.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>ndarray.any : equivalent method</p>
<p>all : Test whether all elements along a given axis evaluate to True.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Not a Number (NaN), positive infinity and negative infinity evaluate to <code>True</code> because these are not equal to zero.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.any(<a href="null">True, False], [True, True</a>) True</p>
      <p>np.any(<a href="null">True, False], [False, False</a>, axis=0) array([ True, False])</p>
      <p>np.any([-1, 0, 5]) True</p>
      <p>np.any(np.nan) True</p>
      <p>o=np.array(False) z=np.any([-1, 4, 5], out=o) z, o (array(True), array(True))</p>
      <h1><a href="#check-now-that-z-is-a-reference-to-o" name="check-now-that-z-is-a-reference-to-o"></a>Check now that z is a reference to o</h1>
      <p>z is o True id(z), id(o) # identity of z and o # doctest: +SKIP (191614240, 191614240)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L13736">view source</a></div></div><div class="public anchor" id="var-append"><h3>append</h3><div class="usage"><code>(append &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Append values to the end of an array.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>arr : array_like  Values are appended to a copy of this array. values : array_like  These values are appended to a copy of <code>arr</code>. It must be of the  correct shape (the same shape as <code>arr</code>, excluding <code>axis</code>). If  <code>axis</code> is not specified, <code>values</code> can be any shape and will be  flattened before use. axis : int, optional  The axis along which <code>values</code> are appended. If <code>axis</code> is not  given, both <code>arr</code> and <code>values</code> are flattened before use.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>append : ndarray  A copy of <code>arr</code> with <code>values</code> appended to <code>axis</code>. Note that  <code>append</code> does not occur in-place: a new array is allocated and  filled. If <code>axis</code> is None, <code>out</code> is a flattened array.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>insert : Insert elements into an array. delete : Delete elements from an array.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.append([1, 2, 3], <a href="null">4, 5, 6], [7, 8, 9</a>) array([1, 2, 3, , 7, 8, 9])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>When <code>axis</code> is specified, <code>values</code> must have the correct shape.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.append(<a href="null">1, 2, 3], [4, 5, 6</a>, <a href="null">7, 8, 9</a>, axis=0) array(<a href="null">1, 2, 3],
       [4, 5, 6],
       [7, 8, 9</a>) np.append(<a href="null">1, 2, 3], [4, 5, 6</a>, [7, 8, 9], axis=0) Traceback (most recent call last):   ValueError: all the input arrays must have same number of dimensions</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L21358">view source</a></div></div><div class="public anchor" id="var-apply_along_axis"><h3>apply_along_axis</h3><div class="usage"><code>(apply_along_axis &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Apply a function to 1-D slices along the given axis.</p>
<p>Execute <code>func1d(a, *args)</code> where <code>func1d</code> operates on 1-D arrays and <code>a</code> is a 1-D slice of <code>arr</code> along <code>axis</code>.</p>
<p>This is equivalent to (but faster than) the following use of <code>ndindex</code> and <code>s_</code>, which sets each of <code>ii</code>, <code>jj</code>, and <code>kk</code> to a tuple of indices::</p>
<pre><code>Ni, Nk = a.shape[:axis], a.shape[axis+1:]
for ii in ndindex(Ni):
    for kk in ndindex(Nk):
        f = func1d(arr[ii + s_[:,] + kk])
        Nj = f.shape
        for jj in ndindex(Nj):
            out[ii + jj + kk] = f[jj]
</code></pre>
<p>Equivalently, eliminating the inner loop, this can be expressed as::</p>
<pre><code>Ni, Nk = a.shape[:axis], a.shape[axis+1:]
for ii in ndindex(Ni):
    for kk in ndindex(Nk):
        out[ii + s_[...,] + kk] = func1d(arr[ii + s_[:,] + kk])
</code></pre>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>func1d : function (M,) -&gt; (Nj)  This function should accept 1-D arrays. It is applied to 1-D  slices of <code>arr</code> along the specified axis. axis : integer  Axis along which <code>arr</code> is sliced. arr : ndarray (Ni, M, Nk)  Input array. args : any  Additional arguments to <code>func1d</code>. kwargs : any  Additional named arguments to <code>func1d</code>.</p>
<pre><code>.. versionadded:: 1.9.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray (Ni, Nj, Nk)  The output array. The shape of <code>out</code> is identical to the shape of  <code>arr</code>, except along the <code>axis</code> dimension. This axis is removed, and  replaced with new dimensions equal to the shape of the return value  of <code>func1d</code>. So if <code>func1d</code> returns a scalar <code>out</code> will have one  fewer dimensions than <code>arr</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>apply_over_axes : Apply a function repeatedly over multiple axes.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>def my_func(a):  ""Average first and last element of a 1-D array""  return (a[0] + a[-1]) * 0.5 b = np.array(<a href="null">1,2,3], [4,5,6], [7,8,9</a>) np.apply_along_axis(my_func, 0, b) array([4., 5., 6.]) np.apply_along_axis(my_func, 1, b) array([2., 5., 8.])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>For a function that returns a 1D array, the number of dimensions in <code>outarr</code> is the same as <code>arr</code>.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>b = np.array(<a href="null">8,1,7], [4,3,9], [5,2,6</a>) np.apply_along_axis(sorted, 1, b) array(<a href="null">1, 7, 8],
       [3, 4, 9],
       [2, 5, 6</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>For a function that returns a higher dimensional array, those dimensions are inserted in place of the <code>axis</code> dimension.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>b = np.array(<a href="null">1,2,3], [4,5,6], [7,8,9</a>) np.apply_along_axis(np.diag, -1, b) array(<a href="null">[1, 0, 0],
        [0, 2, 0],
        [0, 0, 3</a>,  <a href="null">4, 0, 0],
        [0, 5, 0],
        [0, 0, 6</a>,  <a href="null">7, 0, 0],
        [0, 8, 0],
        [0, 0, 9</a>])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L25038">view source</a></div></div><div class="public anchor" id="var-apply_over_axes"><h3>apply_over_axes</h3><div class="usage"><code>(apply_over_axes &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Apply a function repeatedly over multiple axes.</p>
<p><code>func</code> is called as <code>res = func(a, axis)</code>, where <code>axis</code> is the first element of <code>axes</code>. The result <code>res</code> of the function call must have either the same dimensions as <code>a</code> or one less dimension. If <code>res</code> has one less dimension than <code>a</code>, a dimension is inserted before <code>axis</code>. The call to <code>func</code> is then repeated for each axis in <code>axes</code>, with <code>res</code> as the first argument.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>func : function  This function must take two arguments, <code>func(a, axis)</code>. a : array_like  Input array. axes : array_like  Axes over which <code>func</code> is applied; the elements must be integers.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>apply_over_axis : ndarray  The output array. The number of dimensions is the same as <code>a</code>,  but the shape can be different. This depends on whether <code>func</code>  changes the shape of its output with respect to its input.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>apply_along_axis :  Apply a function to 1-D slices of an array along the given axis.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>This function is equivalent to tuple axis arguments to reorderable ufuncs with keepdims=True. Tuple axis arguments to ufuncs have been available since version 1.7.0.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.arange(24).reshape(2,3,4) a array(<a href="null">[ 0,  1,  2,  3],
        [ 4,  5,  6,  7],
        [ 8,  9, 10, 11</a>,  <a href="null">12, 13, 14, 15],
        [16, 17, 18, 19],
        [20, 21, 22, 23</a>])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Sum over axes 0 and 2. The result has same number of dimensions as the original array:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.apply_over_axes(np.sum, a, [0,2]) array(<a href="null">[ 60],
        [ 92],
        [124</a>])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Tuple axis arguments to ufuncs are equivalent:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.sum(a, axis=(0,2), keepdims=True) array(<a href="null">[ 60],
        [ 92],
        [124</a>])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L26809">view source</a></div></div><div class="public anchor" id="var-arange"><h3>arange</h3><div class="usage"><code>(arange self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>arange([start,] stop[, step,], dtype=None)</p>
<p>Return evenly spaced values within a given interval.</p>
<p>Values are generated within the half-open interval <code>[start, stop)</code> (in other words, the interval including <code>start</code> but excluding <code>stop</code>). For integer arguments the function is equivalent to the Python built-in <code>range</code> function, but returns an ndarray rather than a list.</p>
<p>When using a non-integer step, such as 0.1, the results will often not be consistent. It is better to use <code>numpy.linspace</code> for these cases.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>start : number, optional  Start of interval. The interval includes this value. The default  start value is 0. stop : number  End of interval. The interval does not include this value, except  in some cases where <code>step</code> is not an integer and floating point  round-off affects the length of <code>out</code>. step : number, optional  Spacing between values. For any output <code>out</code>, this is the distance  between two adjacent values, <code>out[i+1] - out[i]</code>. The default  step size is 1. If <code>step</code> is specified as a position argument,  <code>start</code> must also be given. dtype : dtype  The type of the output array. If <code>dtype</code> is not given, infer the data  type from the other input arguments.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>arange : ndarray  Array of evenly spaced values.</p>
<pre><code>For floating point arguments, the length of the result is
``ceil((stop - start)/step)``.  Because of floating point overflow,
this rule may result in the last element of `out` being greater
than `stop`.
</code></pre>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>numpy.linspace : Evenly spaced numbers with careful handling of endpoints. numpy.ogrid: Arrays of evenly spaced numbers in N-dimensions. numpy.mgrid: Grid-shaped arrays of evenly spaced numbers in N-dimensions.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.arange(3) array([0, 1, 2]) np.arange(3.0) array([ 0., 1., 2.]) np.arange(3,7) array([3, 4, 5, 6]) np.arange(3,7,2) array([3, 5])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L20949">view source</a></div></div><div class="public anchor" id="var-arccos"><h3>arccos</h3><div class="usage"><code>(arccos self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>arccos(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Trigonometric inverse cosine, element-wise.</p>
<p>The inverse of <code>cos</code> so that, if <code>y = cos(x)</code>, then <code>x = arccos(y)</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  <code>x</code>-coordinate on the unit circle.  For real arguments, the domain is [-1, 1]. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>angle : ndarray  The angle of the ray intersecting the unit circle at the given  <code>x</code>-coordinate in radians [0, pi].  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>cos, arctan, arcsin, emath.arccos</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p><code>arccos</code> is a multivalued function: for each <code>x</code> there are infinitely many numbers <code>z</code> such that <code>cos(z) = x</code>. The convention is to return the angle <code>z</code> whose real part lies in <code>[0, pi]</code>.</p>
<p>For real-valued input data types, <code>arccos</code> always returns real output. For each value that cannot be expressed as a real number or infinity, it yields <code>nan</code> and sets the <code>invalid</code> floating point error flag.</p>
<p>For complex-valued input, <code>arccos</code> is a complex analytic function that has branch cuts <code>[-inf, -1]</code> and <code>[1, inf]</code> and is continuous from above on the former and from below on the latter.</p>
<p>The inverse <code>cos</code> is also known as <code>acos</code> or cos^-1.</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>M. Abramowitz and I.A. Stegun, Handbook of Mathematical Functions, 10th printing, 1964, pp. 79. <a href="http://www.math.sfu.ca/~cbm/aands/">http://www.math.sfu.ca/~cbm/aands/</a></p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>We expect the arccos of 1 to be 0, and of -1 to be pi:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.arccos([1, -1]) array([ 0. , 3.14159265])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Plot arccos:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>import matplotlib.pyplot as plt x = np.linspace(-1, 1, num=100) plt.plot(x, np.arccos(x)) plt.axis(tight) plt.show()</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L26611">view source</a></div></div><div class="public anchor" id="var-arccosh"><h3>arccosh</h3><div class="usage"><code>(arccosh self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>arccosh(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Inverse hyperbolic cosine, element-wise.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Input array. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>arccosh : ndarray  Array of the same shape as <code>x</code>.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>cosh, arcsinh, sinh, arctanh, tanh</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p><code>arccosh</code> is a multivalued function: for each <code>x</code> there are infinitely many numbers <code>z</code> such that <code>cosh(z) = x</code>. The convention is to return the <code>z</code> whose imaginary part lies in <code>[-pi, pi]</code> and the real part in <code>[0, inf]</code>.</p>
<p>For real-valued input data types, <code>arccosh</code> always returns real output. For each value that cannot be expressed as a real number or infinity, it yields <code>nan</code> and sets the <code>invalid</code> floating point error flag.</p>
<p>For complex-valued input, <code>arccosh</code> is a complex analytical function that has a branch cut <code>[-inf, 1]</code> and is continuous from above on it.</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [1] M. Abramowitz and I.A. Stegun, Handbook of Mathematical Functions,  10th printing, 1964, pp. 86. <a href="http://www.math.sfu.ca/~cbm/aands/">http://www.math.sfu.ca/~cbm/aands/</a> .. [2] Wikipedia, Inverse hyperbolic function,  <a href="https://en.wikipedia.org/wiki/Arccosh">https://en.wikipedia.org/wiki/Arccosh</a></p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.arccosh([np.e, 10.0]) array([ 1.65745445, 2.99322285]) np.arccosh(1) 0.0</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L26745">view source</a></div></div><div class="public anchor" id="var-arcsin"><h3>arcsin</h3><div class="usage"><code>(arcsin self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>arcsin(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Inverse sine, element-wise.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  <code>y</code>-coordinate on the unit circle. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>angle : ndarray  The inverse sine of each element in <code>x</code>, in radians and in the  closed interval <code>[-pi/2, pi/2]</code>.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>sin, cos, arccos, tan, arctan, arctan2, emath.arcsin</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p><code>arcsin</code> is a multivalued function: for each <code>x</code> there are infinitely many numbers <code>z</code> such that :math:<code>sin(z) = x</code>. The convention is to return the angle <code>z</code> whose real part lies in [-pi/2, pi/2].</p>
<p>For real-valued input data types, <em>arcsin</em> always returns real output. For each value that cannot be expressed as a real number or infinity, it yields <code>nan</code> and sets the <code>invalid</code> floating point error flag.</p>
<p>For complex-valued input, <code>arcsin</code> is a complex analytic function that has, by convention, the branch cuts [-inf, -1] and [1, inf] and is continuous from above on the former and from below on the latter.</p>
<p>The inverse sine is also known as <code>asin</code> or sin^{-1}.</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>Abramowitz, M. and Stegun, I. A., <em>Handbook of Mathematical Functions</em>, 10th printing, New York: Dover, 1964, pp. 79ff. <a href="http://www.math.sfu.ca/~cbm/aands/">http://www.math.sfu.ca/~cbm/aands/</a></p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.arcsin(1) # pi/2 1.5707963267948966 np.arcsin(-1) # -pi/2 -1.5707963267948966 np.arcsin(0) 0.0</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L28429">view source</a></div></div><div class="public anchor" id="var-arcsinh"><h3>arcsinh</h3><div class="usage"><code>(arcsinh self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>arcsinh(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Inverse hyperbolic sine element-wise.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Input array. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray or scalar  Array of the same shape as <code>x</code>.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p><code>arcsinh</code> is a multivalued function: for each <code>x</code> there are infinitely many numbers <code>z</code> such that <code>sinh(z) = x</code>. The convention is to return the <code>z</code> whose imaginary part lies in <code>[-pi/2, pi/2]</code>.</p>
<p>For real-valued input data types, <code>arcsinh</code> always returns real output. For each value that cannot be expressed as a real number or infinity, it returns <code>nan</code> and sets the <code>invalid</code> floating point error flag.</p>
<p>For complex-valued input, <code>arccos</code> is a complex analytical function that has branch cuts <code>[1j, infj]</code> and <code>[-1j, -infj]</code> and is continuous from the right on the former and from the left on the latter.</p>
<p>The inverse hyperbolic sine is also known as <code>asinh</code> or <code>sinh^-1</code>.</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [1] M. Abramowitz and I.A. Stegun, Handbook of Mathematical Functions,  10th printing, 1964, pp. 86. <a href="http://www.math.sfu.ca/~cbm/aands/">http://www.math.sfu.ca/~cbm/aands/</a> .. [2] Wikipedia, Inverse hyperbolic function,  <a href="https://en.wikipedia.org/wiki/Arcsinh">https://en.wikipedia.org/wiki/Arcsinh</a></p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.arcsinh(np.array([np.e, 10.0])) array([ 1.72538256, 2.99822295])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L18038">view source</a></div></div><div class="public anchor" id="var-arctan"><h3>arctan</h3><div class="usage"><code>(arctan self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>arctan(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Trigonometric inverse tangent, element-wise.</p>
<p>The inverse of tan, so that if <code>y = tan(x)</code> then <code>x = arctan(y)</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray or scalar  Out has the same shape as <code>x</code>. Its real part is in  <code>[-pi/2, pi/2]</code> (<code>arctan(+/-inf)</code> returns <code>+/-pi/2</code>).  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>arctan2 : The four quadrant arctan of the angle formed by (<code>x</code>, <code>y</code>)  and the positive <code>x</code>-axis. angle : Argument of complex values.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p><code>arctan</code> is a multi-valued function: for each <code>x</code> there are infinitely many numbers <code>z</code> such that tan(<code>z</code>) = <code>x</code>. The convention is to return the angle <code>z</code> whose real part lies in [-pi/2, pi/2].</p>
<p>For real-valued input data types, <code>arctan</code> always returns real output. For each value that cannot be expressed as a real number or infinity, it yields <code>nan</code> and sets the <code>invalid</code> floating point error flag.</p>
<p>For complex-valued input, <code>arctan</code> is a complex analytic function that has [<code>1j, infj</code>] and [<code>-1j, -infj</code>] as branch cuts, and is continuous from the left on the former and from the right on the latter.</p>
<p>The inverse tangent is also known as <code>atan</code> or tan^{-1}.</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>Abramowitz, M. and Stegun, I. A., <em>Handbook of Mathematical Functions</em>, 10th printing, New York: Dover, 1964, pp. 79. <a href="http://www.math.sfu.ca/~cbm/aands/">http://www.math.sfu.ca/~cbm/aands/</a></p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>We expect the arctan of 0 to be 0, and of 1 to be pi/4:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.arctan([0, 1]) array([ 0. , 0.78539816])</p>
      <p>np.pi/4 0.78539816339744828</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Plot arctan:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>import matplotlib.pyplot as plt x = np.linspace(-10, 10) plt.plot(x, np.arctan(x)) plt.axis(tight) plt.show()</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L13590">view source</a></div></div><div class="public anchor" id="var-arctan2"><h3>arctan2</h3><div class="usage"><code>(arctan2 self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>arctan2(x1, x2, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Element-wise arc tangent of <code>x1/x2</code> choosing the quadrant correctly.</p>
<p>The quadrant (i.e., branch) is chosen so that <code>arctan2(x1, x2)</code> is the signed angle in radians between the ray ending at the origin and passing through the point (1,0), and the ray ending at the origin and passing through the point (<code>x2</code>, <code>x1</code>). (Note the role reversal: the <code>y</code>-coordinate is the first function parameter, the <code>x</code>-coordinate is the second.) By IEEE convention, this function is defined for <code>x2</code> = +/-0 and for either or both of <code>x1</code> and <code>x2</code> = +/-inf (see Notes for specific values).</p>
<p>This function is not defined for complex-valued arguments; for the so-called argument of complex values, use <code>angle</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x1 : array_like, real-valued  <code>y</code>-coordinates. x2 : array_like, real-valued  <code>x</code>-coordinates. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output). out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>angle : ndarray  Array of angles in radians, in the range <code>[-pi, pi]</code>.  This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>arctan, tan, angle</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p><em>arctan2</em> is identical to the <code>atan2</code> function of the underlying C library. The following special values are defined in the C standard: [1]_</p>
<p>====== ====== ================ <code>x1</code> <code>x2</code> <code>arctan2(x1,x2)</code> ====== ====== ================ +/- 0 +0 +/- 0 +/- 0 -0 +/- pi  &gt; 0 +/-inf +0 / +pi  &lt; 0 +/-inf -0 / -pi +/-inf +inf +/- (pi/4) +/-inf -inf +/- (3*pi/4) ====== ====== ================</p>
<p>Note that +0 and -0 are distinct floating point numbers, as are +inf and -inf.</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [1] ISO/IEC standard 9899:1999, Programming language C.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>Consider four points in different quadrants:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.array([-1, +1, +1, -1]) y = np.array([-1, -1, +1, +1]) np.arctan2(y, x) * 180 / np.pi array([-135., -45., 45., 135.])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Note the order of the parameters. <code>arctan2</code> is defined also when <code>x2</code> = 0 and at several other special points, obtaining values in the range <code>[-pi, pi]</code>:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.arctan2([1., -1.], [0., 0.]) array([ 1.57079633, -1.57079633]) np.arctan2([0., 0., np.inf], [+0., -0., np.inf]) array([ 0. , 3.14159265, 0.78539816])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L575">view source</a></div></div><div class="public anchor" id="var-arctanh"><h3>arctanh</h3><div class="usage"><code>(arctanh self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>arctanh(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Inverse hyperbolic tangent element-wise.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Input array. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray or scalar  Array of the same shape as <code>x</code>.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>emath.arctanh</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p><code>arctanh</code> is a multivalued function: for each <code>x</code> there are infinitely many numbers <code>z</code> such that <code>tanh(z) = x</code>. The convention is to return the <code>z</code> whose imaginary part lies in <code>[-pi/2, pi/2]</code>.</p>
<p>For real-valued input data types, <code>arctanh</code> always returns real output. For each value that cannot be expressed as a real number or infinity, it yields <code>nan</code> and sets the <code>invalid</code> floating point error flag.</p>
<p>For complex-valued input, <code>arctanh</code> is a complex analytical function that has branch cuts <code>[-1, -inf]</code> and <code>[1, inf]</code> and is continuous from above on the former and from below on the latter.</p>
<p>The inverse hyperbolic tangent is also known as <code>atanh</code> or <code>tanh^-1</code>.</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [1] M. Abramowitz and I.A. Stegun, Handbook of Mathematical Functions,  10th printing, 1964, pp. 86. <a href="http://www.math.sfu.ca/~cbm/aands/">http://www.math.sfu.ca/~cbm/aands/</a> .. [2] Wikipedia, Inverse hyperbolic function,  <a href="https://en.wikipedia.org/wiki/Arctanh">https://en.wikipedia.org/wiki/Arctanh</a></p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.arctanh([0, -0.5]) array([ 0. , -0.54930614])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L11725">view source</a></div></div><div class="public anchor" id="var-argmax"><h3>argmax</h3><div class="usage"><code>(argmax &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Returns the indices of the maximum values along an axis.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input array. axis : int, optional  By default, the index is into the flattened array, otherwise  along the specified axis. out : array, optional  If provided, the result will be inserted into this array. It should  be of the appropriate shape and dtype.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>index_array : ndarray of ints  Array of indices into the array. It has the same shape as <code>a.shape</code>  with the dimension along <code>axis</code> removed.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>ndarray.argmax, argmin amax : The maximum value along a given axis. unravel_index : Convert a flat index into an index tuple. take_along_axis : Apply <code>np.expand_dims(index_array, axis)</code>  from argmax to an array as if by calling max.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>In case of multiple occurrences of the maximum values, the indices corresponding to the first occurrence are returned.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.arange(6).reshape(2,3) + 10 a array(<a href="null">10, 11, 12],
       [13, 14, 15</a>) np.argmax(a) 5 np.argmax(a, axis=0) array([1, 1, 1]) np.argmax(a, axis=1) array([2, 2])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Indexes of the maximal elements of a N-dimensional array:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>ind = np.unravel_index(np.argmax(a, axis=None), a.shape) ind (1, 2) a[ind] 15</p>
      <p>b = np.arange(6) b[1] = 5 b array([0, 5, 2, 3, 4, 5]) np.argmax(b) # Only the first occurrence is returned. 1</p>
      <p>x = np.array(<a href="null">4,2,3], [1,0,3</a>) index_array = np.argmax(x, axis=-1)</p>
      <h1><a href="#same-as-np-max-x-axis-1-keepdims-true-" name="same-as-np-max-x-axis-1-keepdims-true-"></a>Same as np.max(x, axis=-1, keepdims=True)</h1>
      <p>np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1) array(<a href="null">4],
       [3</a>)</p>
      <h1><a href="#same-as-np-max-x-axis-1-" name="same-as-np-max-x-axis-1-"></a>Same as np.max(x, axis=-1)</h1>
      <p>np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1).squeeze(axis=-1) array([4, 3])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L6499">view source</a></div></div><div class="public anchor" id="var-argmin"><h3>argmin</h3><div class="usage"><code>(argmin &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Returns the indices of the minimum values along an axis.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input array. axis : int, optional  By default, the index is into the flattened array, otherwise  along the specified axis. out : array, optional  If provided, the result will be inserted into this array. It should  be of the appropriate shape and dtype.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>index_array : ndarray of ints  Array of indices into the array. It has the same shape as <code>a.shape</code>  with the dimension along <code>axis</code> removed.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>ndarray.argmin, argmax amin : The minimum value along a given axis. unravel_index : Convert a flat index into an index tuple. take_along_axis : Apply <code>np.expand_dims(index_array, axis)</code>  from argmin to an array as if by calling min.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>In case of multiple occurrences of the minimum values, the indices corresponding to the first occurrence are returned.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.arange(6).reshape(2,3) + 10 a array(<a href="null">10, 11, 12],
       [13, 14, 15</a>) np.argmin(a) 0 np.argmin(a, axis=0) array([0, 0, 0]) np.argmin(a, axis=1) array([0, 0])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Indices of the minimum elements of a N-dimensional array:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>ind = np.unravel_index(np.argmin(a, axis=None), a.shape) ind (0, 0) a[ind] 10</p>
      <p>b = np.arange(6) + 10 b[4] = 10 b array([10, 11, 12, 13, 10, 15]) np.argmin(b) # Only the first occurrence is returned. 0</p>
      <p>x = np.array(<a href="null">4,2,3], [1,0,3</a>) index_array = np.argmin(x, axis=-1)</p>
      <h1><a href="#same-as-np-min-x-axis-1-keepdims-true-" name="same-as-np-min-x-axis-1-keepdims-true-"></a>Same as np.min(x, axis=-1, keepdims=True)</h1>
      <p>np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1) array(<a href="null">2],
       [0</a>)</p>
      <h1><a href="#same-as-np-max-x-axis-1-" name="same-as-np-max-x-axis-1-"></a>Same as np.max(x, axis=-1)</h1>
      <p>np.take_along_axis(x, np.expand_dims(index_array, axis=-1), axis=-1).squeeze(axis=-1) array([2, 0])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L11197">view source</a></div></div><div class="public anchor" id="var-argpartition"><h3>argpartition</h3><div class="usage"><code>(argpartition &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Perform an indirect partition along the given axis using the algorithm specified by the <code>kind</code> keyword. It returns an array of indices of the same shape as <code>a</code> that index data along the given axis in partitioned order.</p>
<p>.. versionadded:: 1.8.0</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Array to sort. kth : int or sequence of ints  Element index to partition by. The k-th element will be in its  final sorted position and all smaller elements will be moved  before it and all larger elements behind it. The order all  elements in the partitions is undefined. If provided with a  sequence of k-th it will partition all of them into their sorted  position at once. axis : int or None, optional  Axis along which to sort. The default is -1 (the last axis). If  None, the flattened array is used. kind : {introselect}, optional  Selection algorithm. Default is introselect order : str or list of str, optional  When <code>a</code> is an array with fields defined, this argument  specifies which fields to compare first, second, etc. A single  field can be specified as a string, and not all fields need be  specified, but unspecified fields will still be used, in the  order in which they come up in the dtype, to break ties.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>index_array : ndarray, int  Array of indices that partition <code>a</code> along the specified axis.  If <code>a</code> is one-dimensional, <code>a[index_array]</code> yields a partitioned <code>a</code>.  More generally, <code>np.take_along_axis(a, index_array, axis=a)</code> always  yields the partitioned <code>a</code>, irrespective of dimensionality.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>partition : Describes partition algorithms used. ndarray.partition : Inplace partition. argsort : Full indirect sort. take_along_axis : Apply <code>index_array</code> from argpartition  to an array as if by calling partition.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>See <code>partition</code> for notes on the different selection algorithms.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>One dimensional array:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.array([3, 4, 2, 1]) x[np.argpartition(x, 3)] array([2, 1, 3, 4]) x[np.argpartition(x, (1, 3))] array([1, 2, 3, 4])</p>
      <p>x = [3, 4, 2, 1] np.array(x)[np.argpartition(x, 3)] array([2, 1, 3, 4])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Multi-dimensional array:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.array(<a href="null">3, 4, 2], [1, 3, 1</a>) index_array = np.argpartition(x, kth=1, axis=-1) np.take_along_axis(x, index_array, axis=-1) # same as np.partition(x, kth=1) array(<a href="null">2, 3, 4],
       [1, 1, 3</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L20870">view source</a></div></div><div class="public anchor" id="var-argsort"><h3>argsort</h3><div class="usage"><code>(argsort &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Returns the indices that would sort an array.</p>
<p>Perform an indirect sort along the given axis using the algorithm specified by the <code>kind</code> keyword. It returns an array of indices of the same shape as <code>a</code> that index data along the given axis in sorted order.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Array to sort. axis : int or None, optional  Axis along which to sort. The default is -1 (the last axis). If None,  the flattened array is used. kind : {quicksort, mergesort, heapsort, stable}, optional  Sorting algorithm. The default is quicksort. Note that both stable  and mergesort use timsort under the covers and, in general, the  actual implementation will vary with data type. The mergesort option  is retained for backwards compatibility.</p>
<pre><code>.. versionchanged:: 1.15.0.
   The 'stable' option was added.
</code></pre>
<p>order : str or list of str, optional  When <code>a</code> is an array with fields defined, this argument specifies  which fields to compare first, second, etc. A single field can  be specified as a string, and not all fields need be specified,  but unspecified fields will still be used, in the order in which  they come up in the dtype, to break ties.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>index_array : ndarray, int  Array of indices that sort <code>a</code> along the specified <code>axis</code>.  If <code>a</code> is one-dimensional, <code>a[index_array]</code> yields a sorted <code>a</code>.  More generally, <code>np.take_along_axis(a, index_array, axis=axis)</code>  always yields the sorted <code>a</code>, irrespective of dimensionality.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>sort : Describes sorting algorithms used. lexsort : Indirect stable sort with multiple keys. ndarray.sort : Inplace sort. argpartition : Indirect partial sort. take_along_axis : Apply <code>index_array</code> from argsort  to an array as if by calling sort.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>See <code>sort</code> for notes on the different sorting algorithms.</p>
<p>As of NumPy 1.4.0 <code>argsort</code> works with real/complex arrays containing nan values. The enhanced sort order is documented in <code>sort</code>.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>One dimensional array:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.array([3, 1, 2]) np.argsort(x) array([1, 2, 0])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Two-dimensional array:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.array(<a href="null">0, 3], [2, 2</a>) x array(<a href="null">0, 3],
       [2, 2</a>)</p>
      <p>ind = np.argsort(x, axis=0) # sorts along first axis (down) ind array(<a href="null">0, 1],
       [1, 0</a>) np.take_along_axis(x, ind, axis=0) # same as np.sort(x, axis=0) array(<a href="null">0, 2],
       [2, 3</a>)</p>
      <p>ind = np.argsort(x, axis=1) # sorts along last axis (across) ind array(<a href="null">0, 1],
       [0, 1</a>) np.take_along_axis(x, ind, axis=1) # same as np.sort(x, axis=1) array(<a href="null">0, 3],
       [2, 2</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Indices of the sorted elements of a N-dimensional array:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>ind = np.unravel_index(np.argsort(x, axis=None), x.shape) ind (array([0, 1, 1, 0]), array([0, 0, 1, 1])) x[ind] # same as np.sort(x, axis=None) array([0, 2, 2, 3])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Sorting with keys:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.array([(1, 0), (0, 1)], dtype=[(x, &lt;i4), (y, &lt;i4)]) x array([(1, 0), (0, 1)],  dtype=[(x, &lt;i4), (y, &lt;i4)])</p>
      <p>np.argsort(x, order=(x,y)) array([1, 0])</p>
      <p>np.argsort(x, order=(y,x)) array([0, 1])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L19413">view source</a></div></div><div class="public anchor" id="var-argwhere"><h3>argwhere</h3><div class="usage"><code>(argwhere &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Find the indices of array elements that are non-zero, grouped by element.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input data.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>index_array : (N, a.ndim) ndarray  Indices of elements that are non-zero. Indices are grouped by element.  This array will have shape <code>(N, a.ndim)</code> where <code>N</code> is the number of  non-zero items.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>where, nonzero</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p><code>np.argwhere(a)</code> is almost the same as <code>np.transpose(np.nonzero(a))</code>, but produces a result of the correct shape for a 0D array.</p>
<p>The output of <code>argwhere</code> is not suitable for indexing arrays. For this purpose use <code>nonzero(a)</code> instead.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.arange(6).reshape(2,3) x array(<a href="null">0, 1, 2],
       [3, 4, 5</a>) np.argwhere(x&gt;1) array(<a href="null">0, 2],
       [1, 0],
       [1, 1],
       [1, 2</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L21267">view source</a></div></div><div class="public anchor" id="var-around"><h3>around</h3><div class="usage"><code>(around &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Evenly round to the given number of decimals.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input data. decimals : int, optional  Number of decimal places to round to (default: 0). If  decimals is negative, it specifies the number of positions to  the left of the decimal point. out : ndarray, optional  Alternative output array in which to place the result. It must have  the same shape as the expected output, but the type of the output  values will be cast if necessary. See <code>ufuncs-output-type</code> for more  details.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>rounded_array : ndarray  An array of the same type as <code>a</code>, containing the rounded values.  Unless <code>out</code> was specified, a new array is created. A reference to  the result is returned.</p>
<pre><code>The real and imaginary parts of complex numbers are rounded
separately.  The result of rounding a float is a float.
</code></pre>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>ndarray.round : equivalent method</p>
<p>ceil, fix, floor, rint, trunc</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>For values exactly halfway between rounded decimal values, NumPy rounds to the nearest even value. Thus 1.5 and 2.5 round to 2.0, -0.5 and 0.5 round to 0.0, etc.</p>
<p><code>np.around</code> uses a fast but sometimes inexact algorithm to round floating-point datatypes. For positive <code>decimals</code> it is equivalent to <code>np.true_divide(np.rint(a * 10**decimals), 10**decimals)</code>, which has error due to the inexact representation of decimal fractions in the IEEE floating point standard [1]_ and errors introduced when scaling by powers of ten. For instance, note the extra 1 in the following:</p>
<pre><code>&gt;&gt;&gt; np.round(56294995342131.5, 3)
56294995342131.51
</code></pre>
<p>If your goal is to print such values with a fixed number of decimals, it is preferable to use numpys float printing routines to limit the number of printed decimals:</p>
<pre><code>&gt;&gt;&gt; np.format_float_positional(56294995342131.5, precision=3)
'56294995342131.5'
</code></pre>
<p>The float printing routines use an accurate but much more computationally demanding algorithm to compute the number of digits after the decimal point.</p>
<p>Alternatively, Pythons builtin <code>round</code> function uses a more accurate but slower algorithm for 64-bit floating point values:</p>
<pre><code>&gt;&gt;&gt; round(56294995342131.5, 3)
56294995342131.5
&gt;&gt;&gt; np.round(16.055, 2), round(16.055, 2)  # equals 16.0549999999999997
(16.06, 16.05)
</code></pre>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [1] Lecture Notes on the Status of IEEE 754, William Kahan,  <a href="https://people.eecs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF">https://people.eecs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF</a> .. [2] How Futile are Mindless Assessments of  Roundoff in Floating-Point Computation?, William Kahan,  <a href="https://people.eecs.berkeley.edu/~wkahan/Mindless.pdf">https://people.eecs.berkeley.edu/~wkahan/Mindless.pdf</a></p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.around([0.37, 1.64]) array([0., 2.]) np.around([0.37, 1.64], decimals=1) array([0.4, 1.6]) np.around([.5, 1.5, 2.5, 3.5, 4.5]) # rounds to nearest even value array([0., 2., 2., 4., 4.]) np.around([1,2,3,11], decimals=1) # ndarray of ints is returned array([ 1, 2, 3, 11]) np.around([1,2,3,11], decimals=-1) array([ 0, 0, 0, 10])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L22592">view source</a></div></div><div class="public anchor" id="var-array"><h3>array</h3><div class="usage"><code>(array self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>array(object, dtype=None, copy=True, order=K, subok=False, ndmin=0)</p>
<p>Create an array.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>object : array_like  An array, any object exposing the array interface, an object whose  <strong>array</strong> method returns an array, or any (nested) sequence. dtype : data-type, optional  The desired data-type for the array. If not given, then the type will  be determined as the minimum type required to hold the objects in the  sequence. copy : bool, optional  If true (default), then the object is copied. Otherwise, a copy will  only be made if <strong>array</strong> returns a copy, if obj is a nested sequence,  or if a copy is needed to satisfy any of the other requirements  (<code>dtype</code>, <code>order</code>, etc.). order : {K, A, C, F}, optional  Specify the memory layout of the array. If object is not an array, the  newly created array will be in C order (row major) unless F is  specified, in which case it will be in Fortran order (column major).  If object is an array the following holds.</p>
<pre><code>===== ========= ===================================================
order  no copy                     copy=True
===== ========= ===================================================
'K'   unchanged F &amp; C order preserved, otherwise most similar order
'A'   unchanged F order if input is F and not C, otherwise C order
'C'   C order   C order
'F'   F order   F order
===== ========= ===================================================

When ``copy=False`` and a copy is made for other reasons, the result is
the same as if ``copy=True``, with some exceptions for `A`, see the
Notes section. The default order is 'K'.
</code></pre>
<p>subok : bool, optional  If True, then sub-classes will be passed-through, otherwise  the returned array will be forced to be a base-class array (default). ndmin : int, optional  Specifies the minimum number of dimensions that the resulting  array should have. Ones will be pre-pended to the shape as  needed to meet this requirement.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  An array object satisfying the specified requirements.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>empty_like : Return an empty array with shape and type of input. ones_like : Return an array of ones with shape and type of input. zeros_like : Return an array of zeros with shape and type of input. full_like : Return a new array with shape of input filled with value. empty : Return a new uninitialized array. ones : Return a new array setting values to one. zeros : Return a new array setting values to zero. full : Return a new array of given shape filled with value.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>When order is A and <code>object</code> is an array in neither C nor F order, and a copy is forced by a change in dtype, then the order of the result is not necessarily C as expected. This is likely a bug.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.array([1, 2, 3]) array([1, 2, 3])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Upcasting:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.array([1, 2, 3.0]) array([ 1., 2., 3.])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>More than one dimension:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.array(<a href="null">1, 2], [3, 4</a>) array(<a href="null">1, 2],
       [3, 4</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Minimum dimensions 2:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.array([1, 2, 3], ndmin=2) array(<a href="null">1, 2, 3</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Type provided:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.array([1, 2, 3], dtype=complex) array([ 1.+0.j, 2.+0.j, 3.+0.j])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Data-type consisting of more than one element:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.array([(1,2),(3,4)],dtype=[(a,&lt;i4),(b,&lt;i4)]) x[a] array([1, 3])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Creating an array from sub-classes:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.array(np.mat(1 2; 3 4)) array(<a href="null">1, 2],
       [3, 4</a>)</p>
      <p>np.array(np.mat(1 2; 3 4), subok=True) matrix(<a href="null">1, 2],
        [3, 4</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L26260">view source</a></div></div><div class="public anchor" id="var-array2string"><h3>array2string</h3><div class="usage"><code>(array2string &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return a string representation of an array.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input array. max_line_width : int, optional  Inserts newlines if text is longer than <code>max_line_width</code>.  Defaults to <code>numpy.get_printoptions()['linewidth']</code>. precision : int or None, optional  Floating point precision.  Defaults to <code>numpy.get_printoptions()['precision']</code>. suppress_small : bool, optional  Represent numbers very close to zero as zero; default is False.  Very close is defined by precision: if the precision is 8, e.g.,  numbers smaller (in absolute value) than 5e-9 are represented as  zero.  Defaults to <code>numpy.get_printoptions()['suppress']</code>. separator : str, optional  Inserted between elements. prefix : str, optional suffix: str, optional  The length of the prefix and suffix strings are used to respectively  align and wrap the output. An array is typically printed as::</p>
<pre><code>  prefix + array2string(a) + suffix

The output is left-padded by the length of the prefix string, and
wrapping is forced at the column ``max_line_width - len(suffix)``.
It should be noted that the content of prefix and suffix strings are
not included in the output.
</code></pre>
<p>style : _NoValue, optional  Has no effect, do not use.</p>
<pre><code>.. deprecated:: 1.14.0
</code></pre>
<p>formatter : dict of callables, optional  If not None, the keys should indicate the type(s) that the respective  formatting function applies to. Callables should return a string.  Types that are not specified (by their corresponding keys) are handled  by the default formatters. Individual types for which a formatter  can be set are:</p>
<pre><code>- 'bool'
- 'int'
- 'timedelta' : a `numpy.timedelta64`
- 'datetime' : a `numpy.datetime64`
- 'float'
- 'longfloat' : 128-bit floats
- 'complexfloat'
- 'longcomplexfloat' : composed of two 128-bit floats
- 'void' : type `numpy.void`
- 'numpystr' : types `numpy.string_` and `numpy.unicode_`
- 'str' : all other strings

Other keys that can be used to set a group of types at once are:

- 'all' : sets all types
- 'int_kind' : sets 'int'
- 'float_kind' : sets 'float' and 'longfloat'
- 'complex_kind' : sets 'complexfloat' and 'longcomplexfloat'
- 'str_kind' : sets 'str' and 'numpystr'
</code></pre>
<p>threshold : int, optional  Total number of array elements which trigger summarization  rather than full repr.  Defaults to <code>numpy.get_printoptions()['threshold']</code>. edgeitems : int, optional  Number of array items in summary at beginning and end of  each dimension.  Defaults to <code>numpy.get_printoptions()['edgeitems']</code>. sign : string, either -, +, or  , optional  Controls printing of the sign of floating-point types. If +, always  print the sign of positive values. If  , always prints a space  (whitespace character) in the sign position of positive values. If  -, omit the sign character of positive values.  Defaults to <code>numpy.get_printoptions()['sign']</code>. floatmode : str, optional  Controls the interpretation of the <code>precision</code> option for  floating-point types.  Defaults to <code>numpy.get_printoptions()['floatmode']</code>.  Can take the following values:</p>
<pre><code>- 'fixed': Always print exactly `precision` fractional digits,
  even if this would print more or fewer digits than
  necessary to specify the value uniquely.
- 'unique': Print the minimum number of fractional digits necessary
  to represent each value uniquely. Different elements may
  have a different number of digits.  The value of the
  `precision` option is ignored.
- 'maxprec': Print at most `precision` fractional digits, but if
  an element can be uniquely represented with fewer digits
  only print it with that many.
- 'maxprec_equal': Print at most `precision` fractional digits,
  but if every element in the array can be uniquely
  represented with an equal number of fewer digits, use that
  many digits for all elements.
</code></pre>
<p>legacy : string or <code>False</code>, optional  If set to the string <code>'1.13'</code> enables 1.13 legacy printing mode. This  approximates numpy 1.13 print output by including a space in the sign  position of floats and different behavior for 0d arrays. If set to  <code>False</code>, disables legacy mode. Unrecognized strings will be ignored  with a warning for forward compatibility.</p>
<pre><code>.. versionadded:: 1.14.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>array_str : str  String representation of the array.</p>
<h2><a href="#raises" name="raises"></a>Raises</h2>
<p>TypeError  if a callable in <code>formatter</code> does not return a string.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>array_str, array_repr, set_printoptions, get_printoptions</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>If a formatter is specified for a certain type, the <code>precision</code> keyword is ignored for that type.</p>
<p>This is a very flexible function; <code>array_repr</code> and <code>array_str</code> are using <code>array2string</code> internally so keywords with the same name should work identically in all three functions.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.array([1e-16,1,2,3]) np.array2string(x, precision=2, separator=,,  suppress_small=True) [0.,1.,2.,3.]</p>
      <p>x = np.arange(3.) np.array2string(x, formatter={float_kind:lambda x: %.2f % x}) [0.00 1.00 2.00]</p>
      <p>x = np.arange(3) np.array2string(x, formatter={int:lambda x: hex(x)}) [0x0 0x1 0x2]</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L14133">view source</a></div></div><div class="public anchor" id="var-array_equal"><h3>array_equal</h3><div class="usage"><code>(array_equal &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>True if two arrays have the same shape and elements, False otherwise.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a1, a2 : array_like  Input arrays.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>b : bool  Returns True if the arrays are equal.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>allclose: Returns True if two arrays are element-wise equal within a  tolerance. array_equiv: Returns True if input arrays are shape consistent and all  elements equal.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.array_equal([1, 2], [1, 2]) True np.array_equal(np.array([1, 2]), np.array([1, 2])) True np.array_equal([1, 2], [1, 2, 3]) False np.array_equal([1, 2], [1, 4]) False</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L9298">view source</a></div></div><div class="public anchor" id="var-array_equiv"><h3>array_equiv</h3><div class="usage"><code>(array_equiv &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Returns True if input arrays are shape consistent and all elements equal.</p>
<p>Shape consistent means they are either the same shape, or one input array can be broadcasted to create the same shape as the other one.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a1, a2 : array_like  Input arrays.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : bool  True if equivalent, False otherwise.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.array_equiv([1, 2], [1, 2]) True np.array_equiv([1, 2], [1, 3]) False</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Showing the shape equivalence:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.array_equiv([1, 2], <a href="null">1, 2], [1, 2</a>) True np.array_equiv([1, 2], <a href="null">1, 2, 1, 2], [1, 2, 1, 2</a>) False</p>
      <p>np.array_equiv([1, 2], <a href="null">1, 2], [1, 3</a>) False</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L27883">view source</a></div></div><div class="public anchor" id="var-array_repr"><h3>array_repr</h3><div class="usage"><code>(array_repr &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return the string representation of an array.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>arr : ndarray  Input array. max_line_width : int, optional  Inserts newlines if text is longer than <code>max_line_width</code>.  Defaults to <code>numpy.get_printoptions()['linewidth']</code>. precision : int, optional  Floating point precision.  Defaults to <code>numpy.get_printoptions()['precision']</code>. suppress_small : bool, optional  Represent numbers very close to zero as zero; default is False.  Very close is defined by precision: if the precision is 8, e.g.,  numbers smaller (in absolute value) than 5e-9 are represented as  zero.  Defaults to <code>numpy.get_printoptions()['suppress']</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>string : str  The string representation of an array.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>array_str, array2string, set_printoptions</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.array_repr(np.array([1,2])) array([1, 2]) np.array_repr(np.ma.array([0.])) MaskedArray([0.]) np.array_repr(np.array([], np.int32)) array([], dtype=int32)</p>
      <p>x = np.array([1e-6, 4e-7, 2, 3]) np.array_repr(x, precision=6, suppress_small=True) array([0.000001, 0. , 2. , 3. ])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L21936">view source</a></div></div><div class="public anchor" id="var-array_split"><h3>array_split</h3><div class="usage"><code>(array_split &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Split an array into multiple sub-arrays.</p>
<p>Please refer to the <code>split</code> documentation. The only difference between these functions is that <code>array_split</code> allows <code>indices_or_sections</code> to be an integer that does <em>not</em> equally divide the axis. For an array of length l that should be split into n sections, it returns l % n sub-arrays of size l//n + 1 and the rest of size l//n.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>split : Split array into multiple sub-arrays of equal size.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.arange(8.0) np.array_split(x, 3)  [array([0., 1., 2.]), array([3., 4., 5.]), array([6., 7.])]</p>
      <p>x = np.arange(7.0) np.array_split(x, 3)  [array([0., 1., 2.]), array([3., 4.]), array([5., 6.])]</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L1221">view source</a></div></div><div class="public anchor" id="var-array_str"><h3>array_str</h3><div class="usage"><code>(array_str &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return a string representation of the data in an array.</p>
<p>The data in the array is returned as a single string. This function is similar to <code>array_repr</code>, the difference being that <code>array_repr</code> also returns information on the kind of array and its data type.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : ndarray  Input array. max_line_width : int, optional  Inserts newlines if text is longer than <code>max_line_width</code>.  Defaults to <code>numpy.get_printoptions()['linewidth']</code>. precision : int, optional  Floating point precision.  Defaults to <code>numpy.get_printoptions()['precision']</code>. suppress_small : bool, optional  Represent numbers very close to zero as zero; default is False.  Very close is defined by precision: if the precision is 8, e.g.,  numbers smaller (in absolute value) than 5e-9 are represented as  zero.  Defaults to <code>numpy.get_printoptions()['suppress']</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>array2string, array_repr, set_printoptions</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.array_str(np.arange(3)) [0 1 2]</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L2036">view source</a></div></div><div class="public anchor" id="var-asanyarray"><h3>asanyarray</h3><div class="usage"><code>(asanyarray a &amp; [{dtype :dtype, order :order}])</code><code>(asanyarray a &amp; [{dtype :dtype}])</code><code>(asanyarray a)</code></div><div class="doc"><div class="markdown"><p>Convert the input to an ndarray, but pass ndarray subclasses through.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input data, in any form that can be converted to an array. This  includes scalars, lists, lists of tuples, tuples, tuples of tuples,  tuples of lists, and ndarrays. dtype : data-type, optional  By default, the data-type is inferred from the input data. order : {C, F}, optional  Whether to use row-major (C-style) or column-major  (Fortran-style) memory representation. Defaults to C.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray or an ndarray subclass  Array interpretation of <code>a</code>. If <code>a</code> is an ndarray or a subclass  of ndarray, it is returned as-is and no copy is performed.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>asarray : Similar function which always returns ndarrays. ascontiguousarray : Convert input to a contiguous array. asfarray : Convert input to a floating point ndarray. asfortranarray : Convert input to an ndarray with column-major  memory order. asarray_chkfinite : Similar function which checks input for NaNs and  Infs. fromiter : Create an array from an iterator. fromfunction : Construct an array by executing a function on grid  positions.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>Convert a list into an array:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = [1, 2] np.asanyarray(a) array([1, 2])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Instances of <code>ndarray</code> subclasses are passed through as-is:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array([(1.0, 2), (3.0, 4)], dtype=f4,i4).view(np.recarray) np.asanyarray(a) is a True</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L21617">view source</a></div></div><div class="public anchor" id="var-asarray"><h3>asarray</h3><div class="usage"><code>(asarray a &amp; [{dtype :dtype, order :order}])</code><code>(asarray a &amp; [{dtype :dtype}])</code><code>(asarray a)</code></div><div class="doc"><div class="markdown"><p>Convert the input to an array.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input data, in any form that can be converted to an array. This  includes lists, lists of tuples, tuples, tuples of tuples, tuples  of lists and ndarrays. dtype : data-type, optional  By default, the data-type is inferred from the input data. order : {C, F}, optional  Whether to use row-major (C-style) or  column-major (Fortran-style) memory representation.  Defaults to C.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  Array interpretation of <code>a</code>. No copy is performed if the input  is already an ndarray with matching dtype and order. If <code>a</code> is a  subclass of ndarray, a base class ndarray is returned.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>asanyarray : Similar function which passes through subclasses. ascontiguousarray : Convert input to a contiguous array. asfarray : Convert input to a floating point ndarray. asfortranarray : Convert input to an ndarray with column-major  memory order. asarray_chkfinite : Similar function which checks input for NaNs and Infs. fromiter : Create an array from an iterator. fromfunction : Construct an array by executing a function on grid  positions.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>Convert a list into an array:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = [1, 2] np.asarray(a) array([1, 2])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Existing arrays are not copied:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array([1, 2]) np.asarray(a) is a True</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>If <code>dtype</code> is set, array is copied only if dtype does not match:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array([1, 2], dtype=np.float32) np.asarray(a, dtype=np.float32) is a True np.asarray(a, dtype=np.float64) is a False</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Contrary to <code>asanyarray</code>, ndarray subclasses are not passed through:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>issubclass(np.recarray, np.ndarray) True a = np.array([(1.0, 2), (3.0, 4)], dtype=f4,i4).view(np.recarray) np.asarray(a) is a False np.asanyarray(a) is a True</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L22285">view source</a></div></div><div class="public anchor" id="var-asarray_chkfinite"><h3>asarray_chkfinite</h3><div class="usage"><code>(asarray_chkfinite a &amp; [{dtype :dtype, order :order}])</code><code>(asarray_chkfinite a &amp; [{dtype :dtype}])</code><code>(asarray_chkfinite a)</code></div><div class="doc"><div class="markdown"><p>Convert the input to an array, checking for NaNs or Infs.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input data, in any form that can be converted to an array. This  includes lists, lists of tuples, tuples, tuples of tuples, tuples  of lists and ndarrays. Success requires no NaNs or Infs. dtype : data-type, optional  By default, the data-type is inferred from the input data. order : {C, F}, optional  Whether to use row-major (C-style) or  column-major (Fortran-style) memory representation.  Defaults to C.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  Array interpretation of <code>a</code>. No copy is performed if the input  is already an ndarray. If <code>a</code> is a subclass of ndarray, a base  class ndarray is returned.</p>
<h2><a href="#raises" name="raises"></a>Raises</h2>
<p>ValueError  Raises ValueError if <code>a</code> contains NaN (Not a Number) or Inf (Infinity).</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>asarray : Create and array. asanyarray : Similar function which passes through subclasses. ascontiguousarray : Convert input to a contiguous array. asfarray : Convert input to a floating point ndarray. asfortranarray : Convert input to an ndarray with column-major  memory order. fromiter : Create an array from an iterator. fromfunction : Construct an array by executing a function on grid  positions.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>Convert a list into an array. If all elements are finite <code>asarray_chkfinite</code> is identical to <code>asarray</code>.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = [1, 2] np.asarray_chkfinite(a, dtype=float) array([1., 2.])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Raises ValueError if array_like contains Nans or Infs.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = [1, 2, np.inf] try:  np.asarray_chkfinite(a)  except ValueError:  print(ValueError)  ValueError</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L26550">view source</a></div></div><div class="public anchor" id="var-ascontiguousarray"><h3>ascontiguousarray</h3><div class="usage"><code>(ascontiguousarray a &amp; [{dtype :dtype}])</code><code>(ascontiguousarray a)</code></div><div class="doc"><div class="markdown"><p>Return a contiguous array (ndim &gt;= 1) in memory (C order).</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input array. dtype : str or dtype object, optional  Data-type of returned array.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  Contiguous array of same shape and content as <code>a</code>, with type <code>dtype</code>  if specified.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>asfortranarray : Convert input to an ndarray with column-major  memory order. require : Return an ndarray that satisfies requirements. ndarray.flags : Information about the memory layout of the array.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.arange(6).reshape(2,3) np.ascontiguousarray(x, dtype=np.float32) array(<a href="null">0., 1., 2.],
       [3., 4., 5.</a>, dtype=float32) x.flags[C_CONTIGUOUS] True</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Note: This function returns an array with at least one-dimension (1-d) so it will not preserve 0-d arrays. </p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L27630">view source</a></div></div><div class="public anchor" id="var-asfarray"><h3>asfarray</h3><div class="usage"><code>(asfarray &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return an array converted to a float type.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  The input array. dtype : str or dtype object, optional  Float type code to coerce input array <code>a</code>. If <code>dtype</code> is one of the  int dtypes, it is replaced with float64.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  The input <code>a</code> as a float ndarray.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.asfarray([2, 3]) array([2., 3.]) np.asfarray([2, 3], dtype=float) array([2., 3.]) np.asfarray([2, 3], dtype=int8) array([2., 3.])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L17279">view source</a></div></div><div class="public anchor" id="var-asfortranarray"><h3>asfortranarray</h3><div class="usage"><code>(asfortranarray a &amp; [{dtype :dtype}])</code><code>(asfortranarray a)</code></div><div class="doc"><div class="markdown"><p>Return an array (ndim &gt;= 1) laid out in Fortran order in memory.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input array. dtype : str or dtype object, optional  By default, the data-type is inferred from the input data.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  The input <code>a</code> in Fortran, or column-major, order.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>ascontiguousarray : Convert input to a contiguous (C order) array. asanyarray : Convert input to an ndarray with either row or  column-major memory order. require : Return an ndarray that satisfies requirements. ndarray.flags : Information about the memory layout of the array.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.arange(6).reshape(2,3) y = np.asfortranarray(x) x.flags[F_CONTIGUOUS] False y.flags[F_CONTIGUOUS] True</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Note: This function returns an array with at least one-dimension (1-d) so it will not preserve 0-d arrays. </p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L726">view source</a></div></div><div class="public anchor" id="var-asmatrix"><h3>asmatrix</h3><div class="usage"><code>(asmatrix data &amp; [{dtype :dtype}])</code><code>(asmatrix data)</code></div><div class="doc"><div class="markdown"><p>Interpret the input as a matrix.</p>
<p>Unlike <code>matrix</code>, <code>asmatrix</code> does not make a copy if the input is already a matrix or an ndarray. Equivalent to <code>matrix(data, copy=False)</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>data : array_like  Input data. dtype : data-type  Data-type of the output matrix.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>mat : matrix  <code>data</code> interpreted as a matrix.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.array(<a href="null">1, 2], [3, 4</a>)</p>
      <p>m = np.asmatrix(x)</p>
      <p>x[0,0] = 5</p>
      <p>m matrix(<a href="null">5, 2],
        [3, 4</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L6635">view source</a></div></div><div class="public anchor" id="var-asscalar"><h3>asscalar</h3><div class="usage"><code>(asscalar &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Convert an array of size 1 to its scalar equivalent.</p>
<p>.. deprecated:: 1.16</p>
<pre><code>Deprecated, use `numpy.ndarray.item()` instead.
</code></pre>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : ndarray  Input array of size 1.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : scalar  Scalar representation of <code>a</code>. The output data type is the same type  returned by the inputs <code>item</code> method.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.asscalar(np.array([24])) 24</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L16835">view source</a></div></div><div class="public anchor" id="var-atleast_1d"><h3>atleast_1d</h3><div class="usage"><code>(atleast_1d &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Convert inputs to arrays with at least one dimension.</p>
<p>Scalar inputs are converted to 1-dimensional arrays, whilst higher-dimensional inputs are preserved.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>arys1, arys2,  : array_like  One or more input arrays.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>ret : ndarray  An array, or list of arrays, each with <code>a.ndim &gt;= 1</code>.  Copies are made only if necessary.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>atleast_2d, atleast_3d</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.atleast_1d(1.0) array([1.])</p>
      <p>x = np.arange(9.0).reshape(3,3) np.atleast_1d(x) array(<a href="null">0., 1., 2.],
       [3., 4., 5.],
       [6., 7., 8.</a>) np.atleast_1d(x) is x True</p>
      <p>np.atleast_1d(1, [3, 4]) [array([1]), array([3, 4])]</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L21575">view source</a></div></div><div class="public anchor" id="var-atleast_2d"><h3>atleast_2d</h3><div class="usage"><code>(atleast_2d &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>View inputs as arrays with at least two dimensions.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>arys1, arys2,  : array_like  One or more array-like sequences. Non-array inputs are converted  to arrays. Arrays that already have two or more dimensions are  preserved.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>res, res2,  : ndarray  An array, or list of arrays, each with <code>a.ndim &gt;= 2</code>.  Copies are avoided where possible, and views with two or more  dimensions are returned.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>atleast_1d, atleast_3d</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.atleast_2d(3.0) array(<a href="null">3.</a>)</p>
      <p>x = np.arange(3.0) np.atleast_2d(x) array(<a href="null">0., 1., 2.</a>) np.atleast_2d(x).base is x True</p>
      <p>np.atleast_2d(1, [1, 2], <a href="null">1, 2</a>) [array([[1]]), array([[1, 2]]), array([[1, 2]])]</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L16632">view source</a></div></div><div class="public anchor" id="var-atleast_3d"><h3>atleast_3d</h3><div class="usage"><code>(atleast_3d &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>View inputs as arrays with at least three dimensions.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>arys1, arys2,  : array_like  One or more array-like sequences. Non-array inputs are converted to  arrays. Arrays that already have three or more dimensions are  preserved.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>res1, res2,  : ndarray  An array, or list of arrays, each with <code>a.ndim &gt;= 3</code>. Copies are  avoided where possible, and views with three or more dimensions are  returned. For example, a 1-D array of shape <code>(N,)</code> becomes a view  of shape <code>(1, N, 1)</code>, and a 2-D array of shape <code>(M, N)</code> becomes a  view of shape <code>(M, N, 1)</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>atleast_1d, atleast_2d</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.atleast_3d(3.0) array(<a href="null">[3.</a>])</p>
      <p>x = np.arange(3.0) np.atleast_3d(x).shape (1, 3, 1)</p>
      <p>x = np.arange(12.0).reshape(4,3) np.atleast_3d(x).shape (4, 3, 1) np.atleast_3d(x).base is x.base # x is a reshape, so not base itself True</p>
      <p>for arr in np.atleast_3d([1, 2], <a href="null">1, 2</a>, <a href="null">[1, 2</a>]):  print(arr, arr.shape) # doctest: +SKIP  <a href="null">[1]
  [2</a>] (1, 2, 1) <a href="null">[1]
  [2</a>] (1, 2, 1) <a href="null">[1 2</a>] (1, 1, 2)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L13347">view source</a></div></div><div class="public anchor" id="var-average"><h3>average</h3><div class="usage"><code>(average &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Compute the weighted average along the specified axis.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Array containing data to be averaged. If <code>a</code> is not an array, a  conversion is attempted. axis : None or int or tuple of ints, optional  Axis or axes along which to average <code>a</code>. The default,  axis=None, will average over all of the elements of the input array.  If axis is negative it counts from the last to the first axis.</p>
<pre><code>.. versionadded:: 1.7.0

If axis is a tuple of ints, averaging is performed on all of the axes
specified in the tuple instead of a single axis or all the axes as
before.
</code></pre>
<p>weights : array_like, optional  An array of weights associated with the values in <code>a</code>. Each value in  <code>a</code> contributes to the average according to its associated weight.  The weights array can either be 1-D (in which case its length must be  the size of <code>a</code> along the given axis) or of the same shape as <code>a</code>.  If <code>weights=None</code>, then all data in <code>a</code> are assumed to have a  weight equal to one. The 1-D calculation is::</p>
<pre><code>    avg = sum(a * weights) / sum(weights)

The only constraint on `weights` is that `sum(weights)` must not be 0.
</code></pre>
<p>returned : bool, optional  Default is <code>False</code>. If <code>True</code>, the tuple (<code>average</code>, <code>sum_of_weights</code>)  is returned, otherwise only the average is returned.  If <code>weights=None</code>, <code>sum_of_weights</code> is equivalent to the number of  elements over which the average is taken.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>retval, [sum_of_weights] : array_type or double  Return the average along the specified axis. When <code>returned</code> is <code>True</code>,  return a tuple with the average as the first element and the sum  of the weights as the second element. <code>sum_of_weights</code> is of the  same type as <code>retval</code>. The result dtype follows a genereal pattern.  If <code>weights</code> is None, the result dtype will be that of <code>a</code> , or <code>float64</code>  if <code>a</code> is integral. Otherwise, if <code>weights</code> is not None and <code>a</code> is non-  integral, the result type will be the type of lowest precision capable of  representing values of both <code>a</code> and <code>weights</code>. If <code>a</code> happens to be  integral, the previous rules still applies but the result dtype will  at least be <code>float64</code>.</p>
<h2><a href="#raises" name="raises"></a>Raises</h2>
<p>ZeroDivisionError  When all weights along axis are zero. See <code>numpy.ma.average</code> for a  version robust to this type of error. TypeError  When the length of 1D <code>weights</code> is not the same as the shape of <code>a</code>  along axis.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>mean</p>
<p>ma.average : average for masked arrays  useful if your data contains  missing values numpy.result_type : Returns the type that results from applying the  numpy type promotion rules to the arguments.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>data = np.arange(1, 5) data array([1, 2, 3, 4]) np.average(data) 2.5 np.average(np.arange(1, 11), weights=np.arange(10, 0, -1)) 4.0</p>
      <p>data = np.arange(6).reshape((3,2)) data array(<a href="null">0, 1],
       [2, 3],
       [4, 5</a>) np.average(data, axis=1, weights=[1./4, 3./4]) array([0.75, 2.75, 4.75]) np.average(data, weights=[1./4, 3./4]) Traceback (most recent call last):   TypeError: Axis must be specified when shapes of a and weights differ.</p>
      <p>a = np.ones(5, dtype=np.float128) w = np.ones(5, dtype=np.complex64) avg = np.average(a, weights=w) print(avg.dtype) complex256</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L5179">view source</a></div></div><div class="public anchor" id="var-AxisError"><h3>AxisError</h3><div class="usage"><code>(AxisError self axis &amp; [{ndim :ndim, msg_prefix :msg_prefix}])</code><code>(AxisError self axis &amp; [{ndim :ndim}])</code><code>(AxisError self axis)</code></div><div class="doc"><div class="markdown"><p>Axis supplied was invalid. </p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L25035">view source</a></div></div><div class="public anchor" id="var-bartlett"><h3>bartlett</h3><div class="usage"><code>(bartlett M)</code></div><div class="doc"><div class="markdown"><p>Return the Bartlett window.</p>
<p>The Bartlett window is very similar to a triangular window, except that the end points are at zero. It is often used in signal processing for tapering a signal, without generating too much ripple in the frequency domain.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>M : int  Number of points in the output window. If zero or less, an  empty array is returned.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : array  The triangular window, with the maximum value normalized to one  (the value one appears only if the number of samples is odd), with  the first and last samples equal to zero.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>blackman, hamming, hanning, kaiser</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The Bartlett window is defined as</p>
<p>.. math:: w(n) = \frac{2}{M-1} \left(  \frac{M-1}{2} - \left|n - \frac{M-1}{2}\right|  \right)</p>
<p>Most references to the Bartlett window come from the signal processing literature, where it is used as one of many windowing functions for smoothing values. Note that convolution with this window produces linear interpolation. It is also known as an apodization (which meansremoving the foot, i.e. smoothing discontinuities at the beginning and end of the sampled signal) or tapering function. The fourier transform of the Bartlett is the product of two sinc functions. Note the excellent discussion in Kanasewich.</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [1] M.S. Bartlett, Periodogram Analysis and Continuous Spectra,  Biometrika 37, 1-16, 1950. .. [2] E.R. Kanasewich, Time Sequence Analysis in Geophysics,  The University of Alberta Press, 1975, pp. 109-110. .. [3] A.V. Oppenheim and R.W. Schafer, Discrete-Time Signal  Processing, Prentice-Hall, 1999, pp. 468-471. .. [4] Wikipedia, Window function,  <a href="https://en.wikipedia.org/wiki/Window_function">https://en.wikipedia.org/wiki/Window_function</a> .. [5] W.H. Press, B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,  Numerical Recipes, Cambridge University Press, 1986, page 429.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>import matplotlib.pyplot as plt np.bartlett(12) array([ 0. , 0.18181818, 0.36363636, 0.54545455, 0.72727273, # may vary  0.90909091, 0.90909091, 0.72727273, 0.54545455, 0.36363636,  0.18181818, 0. ])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Plot the window and its frequency response (requires SciPy and matplotlib):</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>from numpy.fft import fft, fftshift window = np.bartlett(51) plt.plot(window) [&lt;matplotlib.lines.Line2D object at 0x&gt;] plt.title(Bartlett window) Text(0.5, 1.0, Bartlett window) plt.ylabel(Amplitude) Text(0, 0.5, Amplitude) plt.xlabel(Sample) Text(0.5, 0, Sample) plt.show()</p>
      <p>plt.figure() </p><figure size="" 640x480="" with="" 0="" axes=""> A = fft(window, 2048) / 25.5 mag = np.abs(fftshift(A)) freq = np.linspace(-0.5, 0.5, len(A)) with np.errstate(divide=ignore, invalid=ignore):  response = 20 * np.log10(mag)  response = np.clip(response, -100, 100) plt.plot(freq, response) [&lt;matplotlib.lines.Line2D object at 0x&gt;] plt.title(Frequency response of Bartlett window) Text(0.5, 1.0, Frequency response of Bartlett window) plt.ylabel(Magnitude [dB]) Text(0, 0.5, Magnitude [dB]) plt.xlabel(Normalized frequency [cycles per sample]) Text(0.5, 0, Normalized frequency [cycles per sample]) _ = plt.axis(tight) plt.show()<p></p>
    </figure></blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L25236">view source</a></div></div><div class="public anchor" id="var-base_repr"><h3>base_repr</h3><div class="usage"><code>(base_repr number &amp; [{base :base, padding :padding}])</code><code>(base_repr number &amp; [{base :base}])</code><code>(base_repr number)</code></div><div class="doc"><div class="markdown"><p>Return a string representation of a number in the given base system.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>number : int  The value to convert. Positive and negative values are handled. base : int, optional  Convert <code>number</code> to the <code>base</code> number system. The valid range is 2-36,  the default value is 2. padding : int, optional  Number of zeros padded on the left. Default is 0 (no padding).</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : str  String representation of <code>number</code> in <code>base</code> system.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>binary_repr : Faster version of <code>base_repr</code> for base 2.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.base_repr(5) 101 np.base_repr(6, 5) 11 np.base_repr(7, base=5, padding=3) 00012</p>
      <p>np.base_repr(10, base=16) A np.base_repr(32, base=16) 20</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L22830">view source</a></div></div><div class="public anchor" id="var-binary_repr"><h3>binary_repr</h3><div class="usage"><code>(binary_repr num &amp; [{width :width}])</code><code>(binary_repr num)</code></div><div class="doc"><div class="markdown"><p>Return the binary representation of the input number as a string.</p>
<p>For negative numbers, if width is not given, a minus sign is added to the front. If width is given, the twos complement of the number is returned, with respect to that width.</p>
<p>In a twos-complement system negative numbers are represented by the twos complement of the absolute value. This is the most common method of representing signed integers on computers [1]_. A N-bit twos-complement system can represent every integer in the range :math:<code>-2^{N-1}</code> to :math:<code>+2^{N-1}-1</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>num : int  Only an integer decimal number can be used. width : int, optional  The length of the returned string if <code>num</code> is positive, or the length  of the twos complement if <code>num</code> is negative, provided that <code>width</code> is  at least a sufficient number of bits for <code>num</code> to be represented in the  designated form.</p>
<pre><code>If the `width` value is insufficient, it will be ignored, and `num` will
be returned in binary (`num` &gt; 0) or two's complement (`num` &lt; 0) form
with its width equal to the minimum number of bits needed to represent
the number in the designated form. This behavior is deprecated and will
later raise an error.

.. deprecated:: 1.12.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>bin : str  Binary representation of <code>num</code> or twos complement of <code>num</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>base_repr: Return a string representation of a number in the given base  system. bin: Pythons built-in binary representation generator of an integer.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p><code>binary_repr</code> is equivalent to using <code>base_repr</code> with base 2, but about 25x faster.</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [1] Wikipedia, Twos complement,  <a href="https://en.wikipedia.org/wiki/Two's_complement">https://en.wikipedia.org/wiki/Two's_complement</a></p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.binary_repr(3) 11 np.binary_repr(-3) -11 np.binary_repr(3, width=4) 0011</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The twos complement is returned when the input number is negative and width is specified:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.binary_repr(-3, width=3) 101 np.binary_repr(-3, width=5) 11101</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L21132">view source</a></div></div><div class="public anchor" id="var-bincount"><h3>bincount</h3><div class="usage"><code>(bincount &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>bincount(x, weights=None, minlength=0)</p>
<p>Count number of occurrences of each value in array of non-negative ints.</p>
<p>The number of bins (of size 1) is one larger than the largest value in <code>x</code>. If <code>minlength</code> is specified, there will be at least this number of bins in the output array (though it will be longer if necessary, depending on the contents of <code>x</code>). Each bin gives the number of occurrences of its index value in <code>x</code>. If <code>weights</code> is specified the input array is weighted by it, i.e. if a value <code>n</code> is found at position <code>i</code>, <code>out[n] += weight[i]</code> instead of <code>out[n] += 1</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like, 1 dimension, nonnegative ints  Input array. weights : array_like, optional  Weights, array of the same shape as <code>x</code>. minlength : int, optional  A minimum number of bins for the output array.</p>
<pre><code>.. versionadded:: 1.6.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray of ints  The result of binning the input array.  The length of <code>out</code> is equal to <code>np.amax(x)+1</code>.</p>
<h2><a href="#raises" name="raises"></a>Raises</h2>
<p>ValueError  If the input is not 1-dimensional, or contains elements with negative  values, or if <code>minlength</code> is negative. TypeError  If the type of the input is float or complex.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>histogram, digitize, unique</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.bincount(np.arange(5)) array([1, 1, 1, 1, 1]) np.bincount(np.array([0, 1, 1, 3, 2, 1, 7])) array([1, 3, 1, 1, 0, 0, 0, 1])</p>
      <p>x = np.array([0, 1, 1, 3, 2, 1, 7, 23]) np.bincount(x).size == np.amax(x)+1 True</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The input array needs to be of integer dtype, otherwise a TypeError is raised:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.bincount(np.arange(5, dtype=float)) Traceback (most recent call last):  File <stdin>, line 1, in <module> TypeError: array cannot be safely cast to required type</module></stdin></p>
    </blockquote>
  </blockquote>
</blockquote>
<p>A possible use of <code>bincount</code> is to perform sums over variable-size chunks of an array, using the <code>weights</code> keyword.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>w = np.array([0.3, 0.5, 0.2, 0.7, 1., -0.6]) # weights x = np.array([0, 1, 1, 2, 2, 2]) np.bincount(x, weights=w) array([ 0.3, 0.7, 1.1])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L18870">view source</a></div></div><div class="public anchor" id="var-bitwise_and"><h3>bitwise_and</h3><div class="usage"><code>(bitwise_and self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>bitwise_and(x1, x2, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Compute the bit-wise AND of two arrays element-wise.</p>
<p>Computes the bit-wise AND of the underlying binary representation of the integers in the input arrays. This ufunc implements the C/Python operator <code>&amp;</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x1, x2 : array_like  Only integer and boolean types are handled. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output). out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray or scalar  Result.  This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>logical_and bitwise_or bitwise_xor binary_repr :  Return the binary representation of the input number as a string.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>The number 13 is represented by <code>00001101</code>. Likewise, 17 is represented by <code>00010001</code>. The bit-wise AND of 13 and 17 is therefore <code>000000001</code>, or 1:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.bitwise_and(13, 17) 1</p>
      <p>np.bitwise_and(14, 13) 12 np.binary_repr(12) 1100 np.bitwise_and([14,3], 13) array([12, 1])</p>
      <p>np.bitwise_and([11,7], [4,25]) array([0, 1]) np.bitwise_and(np.array([2,5,255]), np.array([3,14,16])) array([ 2, 4, 16]) np.bitwise_and([True, True], [False, True]) array([False, True])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L15171">view source</a></div></div><div class="public anchor" id="var-bitwise_not"><h3>bitwise_not</h3><div class="usage"><code>(bitwise_not self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>invert(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Compute bit-wise inversion, or bit-wise NOT, element-wise.</p>
<p>Computes the bit-wise NOT of the underlying binary representation of the integers in the input arrays. This ufunc implements the C/Python operator <code>~</code>.</p>
<p>For signed integer inputs, the twos complement is returned. In a twos-complement system negative numbers are represented by the twos complement of the absolute value. This is the most common method of representing signed integers on computers [1]_. A N-bit twos-complement system can represent every integer in the range :math:<code>-2^{N-1}</code> to :math:<code>+2^{N-1}-1</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Only integer and boolean types are handled. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray or scalar  Result.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>bitwise_and, bitwise_or, bitwise_xor logical_not binary_repr :  Return the binary representation of the input number as a string.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p><code>bitwise_not</code> is an alias for <code>invert</code>:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.bitwise_not is np.invert True</p>
    </blockquote>
  </blockquote>
</blockquote>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [1] Wikipedia, Twos complement,  <a href="https://en.wikipedia.org/wiki/Two's_complement">https://en.wikipedia.org/wiki/Two's_complement</a></p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>Weve seen that 13 is represented by <code>00001101</code>. The invert or bit-wise NOT of 13 is then:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.invert(np.array(13, dtype=np.uint8)) x 242 np.binary_repr(x, width=8) 11110010</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The result depends on the bit-width:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.invert(np.array(13, dtype=np.uint16)) x 65522 np.binary_repr(x, width=16) 1111111111110010</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>When using signed integer types the result is the twos complement of the result for the unsigned type:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.invert(np.array([13], dtype=np.int8)) array([-14], dtype=int8) np.binary_repr(-14, width=8) 11110010</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Booleans are accepted as well:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.invert(np.array([True, False])) array([False, True])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L22436">view source</a></div></div><div class="public anchor" id="var-bitwise_or"><h3>bitwise_or</h3><div class="usage"><code>(bitwise_or self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>bitwise_or(x1, x2, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Compute the bit-wise OR of two arrays element-wise.</p>
<p>Computes the bit-wise OR of the underlying binary representation of the integers in the input arrays. This ufunc implements the C/Python operator <code>|</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x1, x2 : array_like  Only integer and boolean types are handled. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output). out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray or scalar  Result.  This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>logical_or bitwise_and bitwise_xor binary_repr :  Return the binary representation of the input number as a string.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>The number 13 has the binaray representation <code>00001101</code>. Likewise, 16 is represented by <code>00010000</code>. The bit-wise OR of 13 and 16 is then <code>000111011</code>, or 29:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.bitwise_or(13, 16) 29 np.binary_repr(29) 11101</p>
      <p>np.bitwise_or(32, 2) 34 np.bitwise_or([33, 4], 1) array([33, 5]) np.bitwise_or([33, 4], [1, 2]) array([33, 6])</p>
      <p>np.bitwise_or(np.array([2, 5, 255]), np.array([4, 4, 4])) array([ 6, 5, 255]) np.array([2, 5, 255]) | np.array([4, 4, 4]) array([ 6, 5, 255]) np.bitwise_or(np.array([2, 5, 255, 2147483647], dtype=np.int32),  np.array([4, 4, 4, 2147483647], dtype=np.int32)) array([ 6, 5, 255, 2147483647]) np.bitwise_or([True, True], [False, True]) array([ True, True])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L6197">view source</a></div></div><div class="public anchor" id="var-bitwise_xor"><h3>bitwise_xor</h3><div class="usage"><code>(bitwise_xor self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>bitwise_xor(x1, x2, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Compute the bit-wise XOR of two arrays element-wise.</p>
<p>Computes the bit-wise XOR of the underlying binary representation of the integers in the input arrays. This ufunc implements the C/Python operator <code>^</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x1, x2 : array_like  Only integer and boolean types are handled. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output). out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray or scalar  Result.  This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>logical_xor bitwise_and bitwise_or binary_repr :  Return the binary representation of the input number as a string.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>The number 13 is represented by <code>00001101</code>. Likewise, 17 is represented by <code>00010001</code>. The bit-wise XOR of 13 and 17 is therefore <code>00011100</code>, or 28:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.bitwise_xor(13, 17) 28 np.binary_repr(28) 11100</p>
      <p>np.bitwise_xor(31, 5) 26 np.bitwise_xor([31,3], 5) array([26, 6])</p>
      <p>np.bitwise_xor([31,3], [5,6]) array([26, 5]) np.bitwise_xor([True, True], [False, True]) array([ True, False])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L29071">view source</a></div></div><div class="public anchor" id="var-blackman"><h3>blackman</h3><div class="usage"><code>(blackman M)</code></div><div class="doc"><div class="markdown"><p>Return the Blackman window.</p>
<p>The Blackman window is a taper formed by using the first three terms of a summation of cosines. It was designed to have close to the minimal leakage possible. It is close to optimal, only slightly worse than a Kaiser window.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>M : int  Number of points in the output window. If zero or less, an empty  array is returned.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  The window, with the maximum value normalized to one (the value one  appears only if the number of samples is odd).</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>bartlett, hamming, hanning, kaiser</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The Blackman window is defined as</p>
<p>.. math:: w(n) = 0.42 - 0.5 \cos(2\pi n/M) + 0.08 \cos(4\pi n/M)</p>
<p>Most references to the Blackman window come from the signal processing literature, where it is used as one of many windowing functions for smoothing values. It is also known as an apodization (which means removing the foot, i.e. smoothing discontinuities at the beginning and end of the sampled signal) or tapering function. It is known as a near optimal tapering function, almost as good (by some measures) as the kaiser window.</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>Blackman, R.B. and Tukey, J.W., (1958) The measurement of power spectra, Dover Publications, New York.</p>
<p>Oppenheim, A.V., and R.W. Schafer. Discrete-Time Signal Processing. Upper Saddle River, NJ: Prentice-Hall, 1999, pp. 468-471.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>import matplotlib.pyplot as plt np.blackman(12) array([-1.38777878e-17, 3.26064346e-02, 1.59903635e-01, # may vary  4.14397981e-01, 7.36045180e-01, 9.67046769e-01,  9.67046769e-01, 7.36045180e-01, 4.14397981e-01,  1.59903635e-01, 3.26064346e-02, -1.38777878e-17])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Plot the window and the frequency response:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>from numpy.fft import fft, fftshift window = np.blackman(51) plt.plot(window) [&lt;matplotlib.lines.Line2D object at 0x&gt;] plt.title(Blackman window) Text(0.5, 1.0, Blackman window) plt.ylabel(Amplitude) Text(0, 0.5, Amplitude) plt.xlabel(Sample) Text(0.5, 0, Sample) plt.show()</p>
      <p>plt.figure() </p><figure size="" 640x480="" with="" 0="" axes=""> A = fft(window, 2048) / 25.5 mag = np.abs(fftshift(A)) freq = np.linspace(-0.5, 0.5, len(A)) with np.errstate(divide=ignore, invalid=ignore):  response = 20 * np.log10(mag)  response = np.clip(response, -100, 100) plt.plot(freq, response) [&lt;matplotlib.lines.Line2D object at 0x&gt;] plt.title(Frequency response of Blackman window) Text(0.5, 1.0, Frequency response of Blackman window) plt.ylabel(Magnitude [dB]) Text(0, 0.5, Magnitude [dB]) plt.xlabel(Normalized frequency [cycles per sample]) Text(0.5, 0, Normalized frequency [cycles per sample]) _ = plt.axis(tight) plt.show()<p></p>
    </figure></blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L16060">view source</a></div></div><div class="public anchor" id="var-block"><h3>block</h3><div class="usage"><code>(block &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Assemble an nd-array from nested lists of blocks.</p>
<p>Blocks in the innermost lists are concatenated (see <code>concatenate</code>) along the last dimension (-1), then these are concatenated along the second-last dimension (-2), and so on until the outermost list is reached.</p>
<p>Blocks can be of any dimension, but will not be broadcasted using the normal rules. Instead, leading axes of size 1 are inserted, to make <code>block.ndim</code> the same for all blocks. This is primarily useful for working with scalars, and means that code like <code>np.block([v, 1])</code> is valid, where <code>v.ndim == 1</code>.</p>
<p>When the nested list is two levels deep, this allows block matrices to be constructed from their components.</p>
<p>.. versionadded:: 1.13.0</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>arrays : nested list of array_like or scalars (but not tuples)  If passed a single ndarray or scalar (a nested list of depth 0), this  is returned unmodified (and not copied).</p>
<pre><code>Elements shapes must match along the appropriate axes (without
broadcasting), but leading 1s will be prepended to the shape as
necessary to make the dimensions match.
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>block_array : ndarray  The array assembled from the given blocks.</p>
<pre><code>The dimensionality of the output is equal to the greatest of:
* the dimensionality of all the inputs
* the depth to which the input list is nested
</code></pre>
<h2><a href="#raises" name="raises"></a>Raises</h2>
<p>ValueError  * If list depths are mismatched - for instance, <code>[[a, b], c]</code> is  illegal, and should be spelt <code>[[a, b], [c]]</code>  * If lists are empty - for instance, <code>[[a, b], []]</code></p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>concatenate : Join a sequence of arrays together. stack : Stack arrays in sequence along a new dimension. hstack : Stack arrays in sequence horizontally (column wise). vstack : Stack arrays in sequence vertically (row wise). dstack : Stack arrays in sequence depth wise (along third dimension). vsplit : Split array into a list of multiple sub-arrays vertically.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>When called with only scalars, <code>np.block</code> is equivalent to an ndarray call. So <code>np.block([[1, 2], [3, 4]])</code> is equivalent to <code>np.array([[1, 2], [3, 4]])</code>.</p>
<p>This function does not enforce that the blocks lie on a fixed grid. <code>np.block([[a, b], [c, d]])</code> is not restricted to arrays of the form::</p>
<pre><code>AAAbb
AAAbb
cccDD
</code></pre>
<p>But is also allowed to produce, for some <code>a, b, c, d</code>::</p>
<pre><code>AAAbb
AAAbb
cDDDD
</code></pre>
<p>Since concatenation happens along the last axis first, <code>block</code> is <em>not</em> capable of producing the following directly::</p>
<pre><code>AAAbb
cccbb
cccDD
</code></pre>
<p>Matlabs square bracket stacking, <code>[A, B, ...; p, q, ...]</code>, is equivalent to <code>np.block([[A, B, ...], [p, q, ...]])</code>.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>The most common use of this function is to build a block matrix</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>A = np.eye(2) * 2 B = np.eye(3) * 3 np.block([  [A, np.zeros((2, 3))],  [np.ones((3, 2)), B ]  ]) array(<a href="null">2., 0., 0., 0., 0.],
       [0., 2., 0., 0., 0.],
       [1., 1., 3., 0., 0.],
       [1., 1., 0., 3., 0.],
       [1., 1., 0., 0., 3.</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>With a list of depth 1, <code>block</code> can be used as <code>hstack</code></p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.block([1, 2, 3]) # hstack([1, 2, 3]) array([1, 2, 3])</p>
      <p>a = np.array([1, 2, 3]) b = np.array([2, 3, 4]) np.block([a, b, 10]) # hstack([a, b, 10]) array([ 1, 2, 3, 2, 3, 4, 10])</p>
      <p>A = np.ones((2, 2), int) B = 2 * A np.block([A, B]) # hstack([A, B]) array(<a href="null">1, 1, 2, 2],
       [1, 1, 2, 2</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>With a list of depth 2, <code>block</code> can be used in place of <code>vstack</code>:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array([1, 2, 3]) b = np.array([2, 3, 4]) np.block(<a href="null">a], [b</a>) # vstack([a, b]) array(<a href="null">1, 2, 3],
       [2, 3, 4</a>)</p>
      <p>A = np.ones((2, 2), int) B = 2 * A np.block(<a href="null">A], [B</a>) # vstack([A, B]) array(<a href="null">1, 1],
       [1, 1],
       [2, 2],
       [2, 2</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>It can also be used in places of <code>atleast_1d</code> and <code>atleast_2d</code></p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array(0) b = np.array([1]) np.block([a]) # atleast_1d(a) array([0]) np.block([b]) # atleast_1d(b) array([1])</p>
      <p>np.block(<a href="null">a</a>) # atleast_2d(a) array(<a href="null">0</a>) np.block(<a href="null">b</a>) # atleast_2d(b) array(<a href="null">1</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L11534">view source</a></div></div><div class="public anchor" id="var-bmat"><h3>bmat</h3><div class="usage"><code>(bmat obj &amp; [{ldict :ldict, gdict :gdict}])</code><code>(bmat obj &amp; [{ldict :ldict}])</code><code>(bmat obj)</code></div><div class="doc"><div class="markdown"><p>Build a matrix object from a string, nested sequence, or array.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>obj : str or array_like  Input data. If a string, variables in the current scope may be  referenced by name. ldict : dict, optional  A dictionary that replaces local operands in current frame.  Ignored if <code>obj</code> is not a string or <code>gdict</code> is None. gdict : dict, optional  A dictionary that replaces global operands in current frame.  Ignored if <code>obj</code> is not a string.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : matrix  Returns a matrix object, which is a specialized 2-D array.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>block :  A generalization of this function for N-d arrays, that returns normal  ndarrays.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>A = np.mat(1 1; 1 1) B = np.mat(2 2; 2 2) C = np.mat(3 4; 5 6) D = np.mat(7 8; 9 0)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>All the following expressions construct the same block matrix:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.bmat(<a href="null">A, B], [C, D</a>) matrix(<a href="null">1, 1, 2, 2],
        [1, 1, 2, 2],
        [3, 4, 7, 8],
        [5, 6, 9, 0</a>) np.bmat(np.r_[np.c_[A, B], np.c_[C, D]]) matrix(<a href="null">1, 1, 2, 2],
        [1, 1, 2, 2],
        [3, 4, 7, 8],
        [5, 6, 9, 0</a>) np.bmat(A,B; C,D) matrix(<a href="null">1, 1, 2, 2],
        [1, 1, 2, 2],
        [3, 4, 7, 8],
        [5, 6, 9, 0</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L4204">view source</a></div></div><div class="public anchor" id="var-bool"><h3>bool</h3><div class="usage"><code>(bool self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>bool(x) -&gt; bool</p>
<p>Returns True when the argument x is true, False otherwise. The builtins True and False are the only two instances of the class bool. The class bool is a subclass of the class int, and cannot be subclassed.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L16053">view source</a></div></div><div class="public anchor" id="var-bool8"><h3>bool8</h3><div class="usage"><code>(bool8 self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Boolean type (True or False), stored as a byte. Character code: <code>'?'</code>. Alias: <code>np.bool8</code>.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L25337">view source</a></div></div><div class="public anchor" id="var-bool_"><h3>bool_</h3><div class="usage"><code>(bool_ self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Boolean type (True or False), stored as a byte. Character code: <code>'?'</code>. Alias: <code>np.bool8</code>.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L2336">view source</a></div></div><div class="public anchor" id="var-broadcast"><h3>broadcast</h3><div class="usage"><code>(broadcast self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Produce an object that mimics broadcasting.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>in1, in2,  : array_like  Input parameters.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>b : broadcast object  Broadcast the input parameters against one another, and  return an object that encapsulates the result.  Amongst others, it has <code>shape</code> and <code>nd</code> properties, and  may be used as an iterator.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>broadcast_arrays broadcast_to</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>Manually adding two vectors, using broadcasting:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.array(<a href="null">1], [2], [3</a>) y = np.array([4, 5, 6]) b = np.broadcast(x, y)</p>
      <p>out = np.empty(b.shape) out.flat = [u+v for (u,v) in b] out array(<a href="null">5.,  6.,  7.],
       [6.,  7.,  8.],
       [7.,  8.,  9.</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Compare against built-in broadcasting:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x + y array(<a href="null">5, 6, 7],
       [6, 7, 8],
       [7, 8, 9</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L16237">view source</a></div></div><div class="public anchor" id="var-broadcast_arrays"><h3>broadcast_arrays</h3><div class="usage"><code>(broadcast_arrays &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Broadcast any number of arrays against each other.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p><code>*args</code> : array_likes  The arrays to broadcast.</p>
<p>subok : bool, optional  If True, then sub-classes will be passed-through, otherwise  the returned arrays will be forced to be a base-class array (default).</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>broadcasted : list of arrays  These arrays are views on the original arrays. They are typically  not contiguous. Furthermore, more than one element of a  broadcasted array may refer to a single memory location. If you need  to write to the arrays, make copies first. While you can set the  <code>writable</code> flag True, writing to a single output value may end up  changing more than one location in the output array.</p>
<pre><code>.. deprecated:: 1.17
    The output is currently marked so that if written to, a deprecation
    warning will be emitted. A future version will set the
    ``writable`` flag False so writing to it will raise an error.
</code></pre>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.array(<a href="null">1,2,3</a>) y = np.array(<a href="null">4],[5</a>) np.broadcast_arrays(x, y) [array([[1, 2, 3],  [1, 2, 3]]), array([[4, 4, 4],  [5, 5, 5]])]</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Here is a useful idiom for getting contiguous copies instead of non-contiguous views.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>[np.array(a) for a in np.broadcast_arrays(x, y)]
[array([[1, 2, 3],  [1, 2, 3]]), array([[4, 4, 4],  [5, 5, 5]])]</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L19994">view source</a></div></div><div class="public anchor" id="var-broadcast_to"><h3>broadcast_to</h3><div class="usage"><code>(broadcast_to &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Broadcast an array to a new shape.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>array : array_like  The array to broadcast. shape : tuple  The shape of the desired array. subok : bool, optional  If True, then sub-classes will be passed-through, otherwise  the returned array will be forced to be a base-class array (default).</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>broadcast : array  A readonly view on the original array with the given shape. It is  typically not contiguous. Furthermore, more than one element of a  broadcasted array may refer to a single memory location.</p>
<h2><a href="#raises" name="raises"></a>Raises</h2>
<p>ValueError  If the array is not compatible with the new shape according to NumPys  broadcasting rules.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>.. versionadded:: 1.10.0</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.array([1, 2, 3]) np.broadcast_to(x, (3, 3)) array(<a href="null">1, 2, 3],
       [1, 2, 3],
       [1, 2, 3</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L24634">view source</a></div></div><div class="public anchor" id="var-BUFSIZE"><h3>BUFSIZE</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L7966">view source</a></div></div><div class="public anchor" id="var-busday_count"><h3>busday_count</h3><div class="usage"><code>(busday_count &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>busday_count(begindates, enddates, weekmask=1111100, holidays=[], busdaycal=None, out=None)</p>
<p>Counts the number of valid days between <code>begindates</code> and <code>enddates</code>, not including the day of <code>enddates</code>.</p>
<p>If <code>enddates</code> specifies a date value that is earlier than the corresponding <code>begindates</code> date value, the count will be negative.</p>
<p>.. versionadded:: 1.7.0</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>begindates : array_like of datetime64[D]  The array of the first dates for counting. enddates : array_like of datetime64[D]  The array of the end dates for counting, which are excluded  from the count themselves. weekmask : str or array_like of bool, optional  A seven-element array indicating which of Monday through Sunday are  valid days. May be specified as a length-seven list or array, like  [1,1,1,1,1,0,0]; a length-seven string, like 1111100; or a string  like Mon Tue Wed Thu Fri, made up of 3-character abbreviations for  weekdays, optionally separated by white space. Valid abbreviations  are: Mon Tue Wed Thu Fri Sat Sun holidays : array_like of datetime64[D], optional  An array of dates to consider as invalid dates. They may be  specified in any order, and NaT (not-a-time) dates are ignored.  This list is saved in a normalized form that is suited for  fast calculations of valid days. busdaycal : busdaycalendar, optional  A <code>busdaycalendar</code> object which specifies the valid days. If this  parameter is provided, neither weekmask nor holidays may be  provided. out : array of int, optional  If provided, this array is filled with the result.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : array of int  An array with a shape from broadcasting <code>begindates</code> and <code>enddates</code>  together, containing the number of valid days between  the begin and end dates.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>busdaycalendar: An object that specifies a custom set of valid days. is_busday : Returns a boolean array indicating valid days. busday_offset : Applies an offset counted in valid days.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <h1><a href="#number-of-weekdays-in-january-2011" name="number-of-weekdays-in-january-2011"></a>Number of weekdays in January 2011</h1>
      <p> np.busday_count(2011-01, 2011-02) 21</p>
      <h1><a href="#number-of-weekdays-in-2011" name="number-of-weekdays-in-2011"></a>Number of weekdays in 2011</h1>
      <p>np.busday_count(2011, 2012) 260</p>
      <h1><a href="#number-of-saturdays-in-2011" name="number-of-saturdays-in-2011"></a>Number of Saturdays in 2011</h1>
      <p> np.busday_count(2011, 2012, weekmask=Sat) 53</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L9551">view source</a></div></div><div class="public anchor" id="var-busday_offset"><h3>busday_offset</h3><div class="usage"><code>(busday_offset &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>busday_offset(dates, offsets, roll=raise, weekmask=1111100, holidays=None, busdaycal=None, out=None)</p>
<p>First adjusts the date to fall on a valid day according to the <code>roll</code> rule, then applies offsets to the given dates counted in valid days.</p>
<p>.. versionadded:: 1.7.0</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>dates : array_like of datetime64[D]  The array of dates to process. offsets : array_like of int  The array of offsets, which is broadcast with <code>dates</code>. roll : {raise, nat, forward, following, backward, preceding, modifiedfollowing, modifiedpreceding}, optional  How to treat dates that do not fall on a valid day. The default  is raise.</p>
<pre><code>  * 'raise' means to raise an exception for an invalid day.
  * 'nat' means to return a NaT (not-a-time) for an invalid day.
  * 'forward' and 'following' mean to take the first valid day
    later in time.
  * 'backward' and 'preceding' mean to take the first valid day
    earlier in time.
  * 'modifiedfollowing' means to take the first valid day
    later in time unless it is across a Month boundary, in which
    case to take the first valid day earlier in time.
  * 'modifiedpreceding' means to take the first valid day
    earlier in time unless it is across a Month boundary, in which
    case to take the first valid day later in time.
</code></pre>
<p>weekmask : str or array_like of bool, optional  A seven-element array indicating which of Monday through Sunday are  valid days. May be specified as a length-seven list or array, like  [1,1,1,1,1,0,0]; a length-seven string, like 1111100; or a string  like Mon Tue Wed Thu Fri, made up of 3-character abbreviations for  weekdays, optionally separated by white space. Valid abbreviations  are: Mon Tue Wed Thu Fri Sat Sun holidays : array_like of datetime64[D], optional  An array of dates to consider as invalid dates. They may be  specified in any order, and NaT (not-a-time) dates are ignored.  This list is saved in a normalized form that is suited for  fast calculations of valid days. busdaycal : busdaycalendar, optional  A <code>busdaycalendar</code> object which specifies the valid days. If this  parameter is provided, neither weekmask nor holidays may be  provided. out : array of datetime64[D], optional  If provided, this array is filled with the result.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : array of datetime64[D]  An array with a shape from broadcasting <code>dates</code> and <code>offsets</code>  together, containing the dates with offsets applied.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>busdaycalendar: An object that specifies a custom set of valid days. is_busday : Returns a boolean array indicating valid days. busday_count : Counts how many valid days are in a half-open date range.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <h1><a href="#first-business-day-in-october-2011-not-accounting-for-holidays-" name="first-business-day-in-october-2011-not-accounting-for-holidays-"></a>First business day in October 2011 (not accounting for holidays)</h1>
      <p> np.busday_offset(2011-10, 0, roll=forward) numpy.datetime64(2011-10-03)</p>
      <h1><a href="#last-business-day-in-february-2012-not-accounting-for-holidays-" name="last-business-day-in-february-2012-not-accounting-for-holidays-"></a>Last business day in February 2012 (not accounting for holidays)</h1>
      <p> np.busday_offset(2012-03, -1, roll=forward) numpy.datetime64(2012-02-29)</p>
      <h1><a href="#third-wednesday-in-january-2011" name="third-wednesday-in-january-2011"></a>Third Wednesday in January 2011</h1>
      <p> np.busday_offset(2011-01, 2, roll=forward, weekmask=Wed) numpy.datetime64(2011-01-19)</p>
      <h1><a href="#2012-mothers-day-in-canada-and-the-u-s-" name="2012-mothers-day-in-canada-and-the-u-s-"></a>2012 Mothers Day in Canada and the U.S.</h1>
      <p> np.busday_offset(2012-05, 1, roll=forward, weekmask=Sun) numpy.datetime64(2012-05-13)</p>
      <h1><a href="#first-business-day-on-or-after-a-date" name="first-business-day-on-or-after-a-date"></a>First business day on or after a date</h1>
      <p> np.busday_offset(2011-03-20, 0, roll=forward) numpy.datetime64(2011-03-21) np.busday_offset(2011-03-22, 0, roll=forward) numpy.datetime64(2011-03-22)</p>
      <h1><a href="#first-business-day-after-a-date" name="first-business-day-after-a-date"></a>First business day after a date</h1>
      <p> np.busday_offset(2011-03-20, 1, roll=backward) numpy.datetime64(2011-03-21) np.busday_offset(2011-03-22, 1, roll=backward) numpy.datetime64(2011-03-23)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L17066">view source</a></div></div><div class="public anchor" id="var-busdaycalendar"><h3>busdaycalendar</h3><div class="usage"><code>(busdaycalendar self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>busdaycalendar(weekmask=1111100, holidays=None)</p>
<p>A business day calendar object that efficiently stores information defining valid days for the busday family of functions.</p>
<p>The default valid days are Monday through Friday (business days). A busdaycalendar object can be specified with any set of weekly valid days, plus an optional holiday dates that always will be invalid.</p>
<p>Once a busdaycalendar object is created, the weekmask and holidays cannot be modified.</p>
<p>.. versionadded:: 1.7.0</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>weekmask : str or array_like of bool, optional  A seven-element array indicating which of Monday through Sunday are  valid days. May be specified as a length-seven list or array, like  [1,1,1,1,1,0,0]; a length-seven string, like 1111100; or a string  like Mon Tue Wed Thu Fri, made up of 3-character abbreviations for  weekdays, optionally separated by white space. Valid abbreviations  are: Mon Tue Wed Thu Fri Sat Sun holidays : array_like of datetime64[D], optional  An array of dates to consider as invalid dates, no matter which  weekday they fall upon. Holiday dates may be specified in any  order, and NaT (not-a-time) dates are ignored. This list is  saved in a normalized form that is suited for fast calculations  of valid days.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : busdaycalendar  A business day calendar object containing the specified  weekmask and holidays values.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>is_busday : Returns a boolean array indicating valid days. busday_offset : Applies an offset counted in valid days. busday_count : Counts how many valid days are in a half-open date range.</p>
<h2><a href="#attributes" name="attributes"></a>Attributes</h2>
<p>Note: once a busdaycalendar object is created, you cannot modify the weekmask or holidays. The attributes return copies of internal data. weekmask : (copy) seven-element array of bool holidays : (copy) sorted array of datetime64[D]</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <h1><a href="#some-important-days-in-july" name="some-important-days-in-july"></a>Some important days in July</h1>
      <p> bdd = np.busdaycalendar(  holidays=[2011-07-01, 2011-07-04, 2011-07-17])</p>
      <h1><a href="#default-is-monday-to-friday-weekdays" name="default-is-monday-to-friday-weekdays"></a>Default is Monday to Friday weekdays</h1>
      <p> bdd.weekmask array([ True, True, True, True, True, False, False])</p>
      <h1><a href="#any-holidays-already-on-the-weekend-are-removed" name="any-holidays-already-on-the-weekend-are-removed"></a>Any holidays already on the weekend are removed</h1>
      <p> bdd.holidays array([2011-07-01, 2011-07-04], dtype=datetime64[D])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L28855">view source</a></div></div><div class="public anchor" id="var-byte"><h3>byte</h3><div class="usage"><code>(byte self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Signed integer type, compatible with C <code>char</code>. Character code: <code>'b'</code>. Canonical name: <code>np.byte</code>. Alias <em>on this platform</em>: <code>np.int8</code>: 8-bit signed integer (-128 to 127).</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L27450">view source</a></div></div><div class="public anchor" id="var-byte_bounds"><h3>byte_bounds</h3><div class="usage"><code>(byte_bounds a)</code></div><div class="doc"><div class="markdown"><p>Returns pointers to the end-points of an array.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : ndarray  Input array. It must conform to the Python-side of the array  interface.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>(low, high) : tuple of 2 integers  The first integer is the first byte of the array, the second  integer is just past the last byte of the array. If <code>a</code> is not  contiguous it will not use every byte between the (<code>low</code>, <code>high</code>)  values.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>I = np.eye(2, dtype=f); I.dtype dtype(float32) low, high = np.byte_bounds(I) high - low == I.size*I.itemsize True I = np.eye(2); I.dtype dtype(float64) low, high = np.byte_bounds(I) high - low == I.size*I.itemsize True</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L28496">view source</a></div></div><div class="public anchor" id="var-bytes0"><h3>bytes0</h3><div class="usage"><code>(bytes0 self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L25021">view source</a></div></div><div class="public anchor" id="var-bytes_"><h3>bytes_</h3><div class="usage"><code>(bytes_ self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L2344">view source</a></div></div><div class="public anchor" id="var-c_"><h3>c_</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Translates slice objects to concatenation along the second axis.</p>
<p>This is short-hand for <code>np.r_['-1,2,0', index expression]</code>, which is useful because of its common occurrence. In particular, arrays will be stacked along their last axis after being upgraded to at least 2-D with 1s post-pended to the shape (column vectors made out of 1-D arrays).</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>column_stack : Stack 1-D arrays as columns into a 2-D array. r_ : For more detailed documentation.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.c_[np.array([1,2,3]), np.array([4,5,6])] array(<a href="null">1, 4],
       [2, 5],
       [3, 6</a>) np.c_[np.array([[1,2,3]]), 0, 0, np.array([[4,5,6]])] array(<a href="null">1, 2, 3, ..., 4, 5, 6</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L4973">view source</a></div></div><div class="public anchor" id="var-can_cast"><h3>can_cast</h3><div class="usage"><code>(can_cast &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>can_cast(from_, to, casting=safe)</p>
<p>Returns True if cast between data types can occur according to the casting rule. If from is a scalar or array scalar, also returns True if the scalar value can be cast without overflow or truncation to an integer.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>from_ : dtype, dtype specifier, scalar, or array  Data type, scalar, or array to cast from. to : dtype or dtype specifier  Data type to cast to. casting : {no, equiv, safe, same_kind, unsafe}, optional  Controls what kind of data casting may occur.</p>
<pre><code>  * 'no' means the data types should not be cast at all.
  * 'equiv' means only byte-order changes are allowed.
  * 'safe' means only casts which can preserve values are allowed.
  * 'same_kind' means only safe casts or casts within a kind,
    like float64 to float32, are allowed.
  * 'unsafe' means any data conversions may be done.
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : bool  True if cast can occur according to the casting rule.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>.. versionchanged:: 1.17.0  Casting between a simple data type and a structured one is possible only  for unsafe casting. Casting to multiple fields is allowed, but  casting from multiple fields is not.</p>
<p>.. versionchanged:: 1.9.0  Casting from numeric to string types in safe casting mode requires  that the string dtype length is long enough to store the maximum  integer/float value converted.</p>
<h2><a href="#see-also" name="see-also"></a>See also</h2>
<p>dtype, result_type</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>Basic examples</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.can_cast(np.int32, np.int64) True np.can_cast(np.float64, complex) True np.can_cast(complex, float) False</p>
      <p>np.can_cast(i8, f8) True np.can_cast(i8, f4) False np.can_cast(i4, S4) False</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Casting scalars</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.can_cast(100, i1) True np.can_cast(150, i1) False np.can_cast(150, u1) True</p>
      <p>np.can_cast(3.5e100, np.float32) False np.can_cast(1000.0, np.float32) True</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Array scalar checks the value, array does not</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.can_cast(np.array(1000.0), np.float32) True np.can_cast(np.array([1000.0]), np.float32) False</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Using the casting rules</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.can_cast(i8, i8, no) True np.can_cast(&lt;i8, &gt;i8, no) False</p>
      <p>np.can_cast(&lt;i8, &gt;i8, equiv) True np.can_cast(&lt;i4, &gt;i8, equiv) False</p>
      <p>np.can_cast(&lt;i4, &gt;i8, safe) True np.can_cast(&lt;i8, &gt;i4, safe) False</p>
      <p>np.can_cast(&lt;i8, &gt;i4, same_kind) True np.can_cast(&lt;i8, &gt;u4, same_kind) False</p>
      <p>np.can_cast(&lt;i8, &gt;u4, unsafe) True</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L12142">view source</a></div></div><div class="public anchor" id="var-cast"><h3>cast</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Base object for a dictionary for look-up with any alias for an array dtype.</p>
<p>Instances of <code>_typedict</code> can not be used as dictionaries directly, first they have to be populated.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L4010">view source</a></div></div><div class="public anchor" id="var-cbrt"><h3>cbrt</h3><div class="usage"><code>(cbrt self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>cbrt(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Return the cube-root of an array, element-wise.</p>
<p>.. versionadded:: 1.10.0</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  The values whose cube-roots are required. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray  An array of the same shape as <code>x</code>, containing the cube  cube-root of each element in <code>x</code>.  If <code>out</code> was provided, <code>y</code> is a reference to it.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.cbrt([1,8,27]) array([ 1., 2., 3.])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L8004">view source</a></div></div><div class="public anchor" id="var-cdouble"><h3>cdouble</h3><div class="usage"><code>(cdouble self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Complex number type composed of two double-precision floating-point numbers, compatible with Python <code>complex</code>. Character code: <code>'D'</code>. Canonical name: <code>np.cdouble</code>. Alias: <code>np.cfloat</code>. Alias: <code>np.complex_</code>. Alias <em>on this platform</em>: <code>np.complex128</code>: Complex number type composed of 2 64-bit-precision floating-point numbers.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L15237">view source</a></div></div><div class="public anchor" id="var-ceil"><h3>ceil</h3><div class="usage"><code>(ceil self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>ceil(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Return the ceiling of the input, element-wise.</p>
<p>The ceil of the scalar <code>x</code> is the smallest integer <code>i</code>, such that <code>i &gt;= x</code>. It is often denoted as :math:<code>\lceil x \rceil</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Input data. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray or scalar  The ceiling of each element in <code>x</code>, with <code>float</code> dtype.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>floor, trunc, rint</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0]) np.ceil(a) array([-1., -1., -0., 1., 2., 2., 2.])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L666">view source</a></div></div><div class="public anchor" id="var-cfloat"><h3>cfloat</h3><div class="usage"><code>(cfloat self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Complex number type composed of two double-precision floating-point numbers, compatible with Python <code>complex</code>. Character code: <code>'D'</code>. Canonical name: <code>np.cdouble</code>. Alias: <code>np.cfloat</code>. Alias: <code>np.complex_</code>. Alias <em>on this platform</em>: <code>np.complex128</code>: Complex number type composed of 2 64-bit-precision floating-point numbers.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L25767">view source</a></div></div><div class="public anchor" id="var-char"><h3>char</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>This module contains a set of functions for vectorized string operations and methods.</p>
<p>.. note::  The <code>chararray</code> class exists for backwards compatibility with  Numarray, it is not recommended for new development. Starting from numpy  1.4, if one needs arrays of strings, it is recommended to use arrays of  <code>dtype</code> <code>object_</code>, <code>string_</code> or <code>unicode_</code>, and use the free functions  in the <code>numpy.char</code> module for fast vectorized string operations.</p>
<p>Some methods will only be available if the corresponding string method is available in your version of Python.</p>
<p>The preferred alias for <code>defchararray</code> is <code>numpy.char</code>.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L16152">view source</a></div></div><div class="public anchor" id="var-character"><h3>character</h3><div class="usage"><code>(character self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Abstract base class of all character string scalar types.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L15907">view source</a></div></div><div class="public anchor" id="var-chararray"><h3>chararray</h3><div class="usage"><code>(chararray self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>chararray(shape, itemsize=1, unicode=False, buffer=None, offset=0,  strides=None, order=None)</p>
<p>Provides a convenient view on arrays of string and unicode values.</p>
<p>.. note::  The <code>chararray</code> class exists for backwards compatibility with  Numarray, it is not recommended for new development. Starting from numpy  1.4, if one needs arrays of strings, it is recommended to use arrays of  <code>dtype</code> <code>object_</code>, <code>string_</code> or <code>unicode_</code>, and use the free functions  in the <code>numpy.char</code> module for fast vectorized string operations.</p>
<p>Versus a regular NumPy array of type <code>str</code> or <code>unicode</code>, this class adds the following functionality:</p>
<p>1) values automatically have whitespace removed from the end  when indexed</p>
<p>2) comparison operators automatically remove whitespace from the  end when comparing values</p>
<p>3) vectorized string operations are provided as methods  (e.g. <code>.endswith</code>) and infix operators (e.g. <code>"+", "*", "%"</code>)</p>
<p>chararrays should be created using <code>numpy.char.array</code> or <code>numpy.char.asarray</code>, rather than this constructor directly.</p>
<p>This constructor creates the array, using <code>buffer</code> (with <code>offset</code> and <code>strides</code>) if it is not <code>None</code>. If <code>buffer</code> is <code>None</code>, then constructs a new array with <code>strides</code> in C order, unless both <code>len(shape) &gt;= 2</code> and <code>order='F'</code>, in which case <code>strides</code> is in Fortran order.</p>
<h2><a href="#methods" name="methods"></a>Methods</h2>
<p>astype argsort copy count decode dump dumps encode endswith expandtabs fill find flatten getfield index isalnum isalpha isdecimal isdigit islower isnumeric isspace istitle isupper item join ljust lower lstrip nonzero put ravel repeat replace reshape resize rfind rindex rjust rsplit rstrip searchsorted setfield setflags sort split splitlines squeeze startswith strip swapaxes swapcase take title tofile tolist tostring translate transpose upper view zfill</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>shape : tuple  Shape of the array. itemsize : int, optional  Length of each array element, in number of characters. Default is 1. unicode : bool, optional  Are the array elements of type unicode (True) or string (False).  Default is False. buffer : int, optional  Memory address of the start of the array data. Default is None,  in which case a new array is created. offset : int, optional  Fixed stride displacement from the beginning of an axis?  Default is 0. Needs to be &gt;=0. strides : array_like of ints, optional  Strides for the array (see <code>ndarray.strides</code> for full description).  Default is None. order : {C, F}, optional  The order in which the array data is stored in memory: C -&gt;  row major order (the default), F -&gt; column major  (Fortran) order.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>charar = np.chararray((3, 3)) charar[:] = a charar chararray(<a href="null">b'a', b'a', b'a'],
           [b'a', b'a', b'a'],
           [b'a', b'a', b'a'</a>, dtype=|S1)</p>
      <p>charar = np.chararray(charar.shape, itemsize=5) charar[:] = abc charar chararray(<a href="null">b'abc', b'abc', b'abc'],
           [b'abc', b'abc', b'abc'],
           [b'abc', b'abc', b'abc'</a>, dtype=|S5)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L11271">view source</a></div></div><div class="public anchor" id="var-choose"><h3>choose</h3><div class="usage"><code>(choose &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Construct an array from an index array and a set of arrays to choose from.</p>
<p>First of all, if confused or uncertain, definitely look at the Examples - in its full generality, this function is less simple than it might seem from the following code description (below ndi = <code>numpy.lib.index_tricks</code>):</p>
<p><code>np.choose(a,c) == np.array([c[a[I]][I] for I in ndi.ndindex(a.shape)])</code>.</p>
<p>But this omits some subtleties. Here is a fully general summary:</p>
<p>Given an index array (<code>a</code>) of integers and a sequence of <code>n</code> arrays (<code>choices</code>), <code>a</code> and each choice array are first broadcast, as necessary, to arrays of a common shape; calling these <em>Ba</em> and <em>Bchoices[i], i = 0,,n-1</em> we have that, necessarily, <code>Ba.shape == Bchoices[i].shape</code> for each <code>i</code>. Then, a new array with shape <code>Ba.shape</code> is created as follows:</p>
<ul>
  <li>
  <p>if <code>mode=raise</code> (the default), then, first of all, each element of  <code>a</code> (and thus <code>Ba</code>) must be in the range <code>[0, n-1]</code>; now, suppose that  <code>i</code> (in that range) is the value at the <code>(j0, j1, ..., jm)</code> position  in <code>Ba</code> - then the value at the same position in the new array is the  value in <code>Bchoices[i]</code> at that same position;</p></li>
  <li>
  <p>if <code>mode=wrap</code>, values in <code>a</code> (and thus <code>Ba</code>) may be any (signed)  integer; modular arithmetic is used to map integers outside the range  <code>[0, n-1]</code> back into that range; and then the new array is constructed  as above;</p></li>
  <li>
  <p>if <code>mode=clip</code>, values in <code>a</code> (and thus <code>Ba</code>) may be any (signed)  integer; negative integers are mapped to 0; values greater than <code>n-1</code>  are mapped to <code>n-1</code>; and then the new array is constructed as above.</p></li>
</ul>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : int array  This array must contain integers in <code>[0, n-1]</code>, where <code>n</code> is the number  of choices, unless <code>mode=wrap</code> or <code>mode=clip</code>, in which cases any  integers are permissible. choices : sequence of arrays  Choice arrays. <code>a</code> and all of the choices must be broadcastable to the  same shape. If <code>choices</code> is itself an array (not recommended), then  its outermost dimension (i.e., the one corresponding to  <code>choices.shape[0]</code>) is taken as defining the sequence. out : array, optional  If provided, the result will be inserted into this array. It should  be of the appropriate shape and dtype. Note that <code>out</code> is always  buffered if <code>mode='raise'</code>; use other modes for better performance. mode : {raise (default), wrap, clip}, optional  Specifies how indices outside <code>[0, n-1]</code> will be treated:</p>
<pre><code>  * 'raise' : an exception is raised
  * 'wrap' : value becomes value mod `n`
  * 'clip' : values &lt; 0 are mapped to 0, values &gt; n-1 are mapped to n-1
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>merged_array : array  The merged result.</p>
<h2><a href="#raises" name="raises"></a>Raises</h2>
<p>ValueError: shape mismatch  If <code>a</code> and each choice array are not all broadcastable to the same  shape.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>ndarray.choose : equivalent method numpy.take_along_axis : Preferable if <code>choices</code> is an array</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>To reduce the chance of misinterpretation, even though the following abuse is nominally supported, <code>choices</code> should neither be, nor be thought of as, a single array, i.e., the outermost sequence-like container should be either a list or a tuple.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>choices = <a href="null">0, 1, 2, 3], [10, 11, 12, 13],
...   [20, 21, 22, 23], [30, 31, 32, 33</a> np.choose([2, 3, 1, 0], choices  # the first element of the result will be the first element of the  # third (2+1) array in choices, namely, 20; the second element  # will be the second element of the fourth (3+1) choice array, i.e.,  # 31, etc.  ) array([20, 31, 12, 3]) np.choose([2, 4, 1, 0], choices, mode=clip) # 4 goes to 3 (4-1) array([20, 31, 12, 3])</p>
      <h1><a href="#because-there-are-4-choice-arrays" name="because-there-are-4-choice-arrays"></a>because there are 4 choice arrays</h1>
      <p>np.choose([2, 4, 1, 0], choices, mode=wrap) # 4 goes to (4 mod 4) array([20, 1, 12, 3])</p>
      <h1><a href="#i-e-0" name="i-e-0"></a>i.e., 0</h1>
    </blockquote>
  </blockquote>
</blockquote>
<p>A couple examples illustrating how choose broadcasts:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = <a href="null">1, 0, 1], [0, 1, 0], [1, 0, 1</a> choices = [-10, 10] np.choose(a, choices) array(<a href="null"> 10, -10,  10],
       [-10,  10, -10],
       [ 10, -10,  10</a>)</p>
      <h1><a href="#with-thanks-to-anne-archibald" name="with-thanks-to-anne-archibald"></a>With thanks to Anne Archibald</h1>
      <p>a = np.array([0, 1]).reshape((2,1,1)) c1 = np.array([1, 2, 3]).reshape((1,3,1)) c2 = np.array([-1, -2, -3, -4, -5]).reshape((1,1,5)) np.choose(a, (c1, c2)) # result is 2x3x5, res[0,:,:]=c1, res[1,:,:]=c2 array(<a href="null">[ 1,  1,  1,  1,  1],
        [ 2,  2,  2,  2,  2],
        [ 3,  3,  3,  3,  3</a>,  <a href="null">-1, -2, -3, -4, -5],
        [-1, -2, -3, -4, -5],
        [-1, -2, -3, -4, -5</a>])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L18539">view source</a></div></div><div class="public anchor" id="var-CLIP"><h3>CLIP</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L24632">view source</a></div></div><div class="public anchor" id="var-clip"><h3>clip</h3><div class="usage"><code>(clip &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Clip (limit) the values in an array.</p>
<p>Given an interval, values outside the interval are clipped to the interval edges. For example, if an interval of <code>[0, 1]</code> is specified, values smaller than 0 become 0, and values larger than 1 become 1.</p>
<p>Equivalent to but faster than <code>np.maximum(a_min, np.minimum(a, a_max))</code>. No check is performed to ensure <code>a_min &lt; a_max</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Array containing elements to clip. a_min : scalar or array_like or None  Minimum value. If None, clipping is not performed on lower  interval edge. Not more than one of <code>a_min</code> and <code>a_max</code> may be  None. a_max : scalar or array_like or None  Maximum value. If None, clipping is not performed on upper  interval edge. Not more than one of <code>a_min</code> and <code>a_max</code> may be  None. If <code>a_min</code> or <code>a_max</code> are array_like, then the three  arrays will be broadcasted to match their shapes. out : ndarray, optional  The results will be placed in this array. It may be the input  array for in-place clipping. <code>out</code> must be of the right shape  to hold the output. Its type is preserved. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<pre><code>.. versionadded:: 1.17.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>clipped_array : ndarray  An array with the elements of <code>a</code>, but where values  &lt; <code>a_min</code> are replaced with <code>a_min</code>, and those &gt; <code>a_max</code>  with <code>a_max</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>ufuncs-output-type</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.arange(10) np.clip(a, 1, 8) array([1, 1, 2, 3, 4, 5, 6, 7, 8, 8]) a array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) np.clip(a, 3, 6, out=a) array([3, 3, 3, 3, 4, 5, 6, 6, 6, 6]) a = np.arange(10) a array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) np.clip(a, [3, 4, 1, 1, 1, 4, 4, 4, 4, 4], 8) array([3, 4, 2, 3, 4, 5, 6, 7, 8, 8])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L6424">view source</a></div></div><div class="public anchor" id="var-clongdouble"><h3>clongdouble</h3><div class="usage"><code>(clongdouble self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Complex number type composed of two extended-precision floating-point numbers. Character code: <code>'G'</code>. Canonical name: <code>np.clongdouble</code>. Alias: <code>np.clongfloat</code>. Alias: <code>np.longcomplex</code>. Alias <em>on this platform</em>: <code>np.complex256</code>: Complex number type composed of 2 128-bit extended-precision floating-point numbers.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L970">view source</a></div></div><div class="public anchor" id="var-clongfloat"><h3>clongfloat</h3><div class="usage"><code>(clongfloat self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Complex number type composed of two extended-precision floating-point numbers. Character code: <code>'G'</code>. Canonical name: <code>np.clongdouble</code>. Alias: <code>np.clongfloat</code>. Alias: <code>np.longcomplex</code>. Alias <em>on this platform</em>: <code>np.complex256</code>: Complex number type composed of 2 128-bit extended-precision floating-point numbers.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L10250">view source</a></div></div><div class="public anchor" id="var-column_stack"><h3>column_stack</h3><div class="usage"><code>(column_stack &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Stack 1-D arrays as columns into a 2-D array.</p>
<p>Take a sequence of 1-D arrays and stack them as columns to make a single 2-D array. 2-D arrays are stacked as-is, just like with <code>hstack</code>. 1-D arrays are turned into 2-D columns first.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>tup : sequence of 1-D or 2-D arrays.  Arrays to stack. All of them must have the same first dimension.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>stacked : 2-D array  The array formed by stacking the given arrays.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>stack, hstack, vstack, concatenate</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array((1,2,3)) b = np.array((2,3,4)) np.column_stack((a,b)) array(<a href="null">1, 2],
       [2, 3],
       [3, 4</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L23064">view source</a></div></div><div class="public anchor" id="var-common_type"><h3>common_type</h3><div class="usage"><code>(common_type &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return a scalar type which is common to the input arrays.</p>
<p>The return type will always be an inexact (i.e. floating point) scalar type, even if all the arrays are integer arrays. If one of the inputs is an integer array, the minimum precision type that is returned is a 64-bit floating point dtype.</p>
<p>All input arrays except int64 and uint64 can be safely cast to the returned dtype without loss of information.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>array1, array2,  : ndarrays  Input arrays.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : data type code  Data type code.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>dtype, mintypecode</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.common_type(np.arange(2, dtype=np.float32)) &lt;class numpy.float32&gt; np.common_type(np.arange(2, dtype=np.float32), np.arange(2)) &lt;class numpy.float64&gt; np.common_type(np.arange(4), np.array([45, 6.j]), np.array([45.0])) &lt;class numpy.complex128&gt;</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L933">view source</a></div></div><div class="public anchor" id="var-compare_chararrays"><h3>compare_chararrays</h3><div class="usage"><code>(compare_chararrays self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>compare_chararrays(a, b, cmp_op, rstrip)</p>
<p>Performs element-wise comparison of two string arrays using the comparison operator specified by <code>cmp_op</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a, b : array_like  Arrays to be compared. cmp_op : {&lt;, &lt;=, ==, &gt;=, &gt;, !=}  Type of comparison. rstrip : Boolean  If True, the spaces at the end of Strings are removed before the comparison.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  The output array of type Boolean with the same shape as a and b.</p>
<h2><a href="#raises" name="raises"></a>Raises</h2>
<p>ValueError  If <code>cmp_op</code> is not valid. TypeError  If at least one of <code>a</code> or <code>b</code> is a non-string array</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array([a, b, cde]) b = np.array([a, a, dec]) np.compare_chararrays(a, b, &gt;, True) array([False, True, False])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L21900">view source</a></div></div><div class="public anchor" id="var-compat"><h3>compat</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Compatibility module.</p>
<p>This module contains duplicated code from Python itself or 3rd party extensions, which may be included for the following reasons:</p>
<ul>
  <li>compatibility</li>
  <li>we may only need a small subset of the copied library/module</li>
</ul></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L9212">view source</a></div></div><div class="public anchor" id="var-complex"><h3>complex</h3><div class="usage"><code>(complex self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Create a complex number from a real part and an optional imaginary part.</p>
<p>This is equivalent to (real + imag*1j) where imag defaults to 0.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L25685">view source</a></div></div><div class="public anchor" id="var-complex128"><h3>complex128</h3><div class="usage"><code>(complex128 self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Complex number type composed of two double-precision floating-point numbers, compatible with Python <code>complex</code>. Character code: <code>'D'</code>. Canonical name: <code>np.cdouble</code>. Alias: <code>np.cfloat</code>. Alias: <code>np.complex_</code>. Alias <em>on this platform</em>: <code>np.complex128</code>: Complex number type composed of 2 64-bit-precision floating-point numbers.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L13027">view source</a></div></div><div class="public anchor" id="var-complex256"><h3>complex256</h3><div class="usage"><code>(complex256 self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Complex number type composed of two extended-precision floating-point numbers. Character code: <code>'G'</code>. Canonical name: <code>np.clongdouble</code>. Alias: <code>np.clongfloat</code>. Alias: <code>np.longcomplex</code>. Alias <em>on this platform</em>: <code>np.complex256</code>: Complex number type composed of 2 128-bit extended-precision floating-point numbers.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L26980">view source</a></div></div><div class="public anchor" id="var-complex64"><h3>complex64</h3><div class="usage"><code>(complex64 self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Complex number type composed of two single-precision floating-point numbers. Character code: <code>'F'</code>. Canonical name: <code>np.csingle</code>. Alias: <code>np.singlecomplex</code>. Alias <em>on this platform</em>: <code>np.complex64</code>: Complex number type composed of 2 32-bit-precision floating-point numbers.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L26737">view source</a></div></div><div class="public anchor" id="var-complex_"><h3>complex_</h3><div class="usage"><code>(complex_ self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Complex number type composed of two double-precision floating-point numbers, compatible with Python <code>complex</code>. Character code: <code>'D'</code>. Canonical name: <code>np.cdouble</code>. Alias: <code>np.cfloat</code>. Alias: <code>np.complex_</code>. Alias <em>on this platform</em>: <code>np.complex128</code>: Complex number type composed of 2 64-bit-precision floating-point numbers.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L4964">view source</a></div></div><div class="public anchor" id="var-complexfloating"><h3>complexfloating</h3><div class="usage"><code>(complexfloating self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Abstract base class of all complex number scalar types that are made up of floating-point numbers.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L20502">view source</a></div></div><div class="public anchor" id="var-ComplexWarning"><h3>ComplexWarning</h3><div class="usage"><code>(ComplexWarning self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>The warning raised when casting a complex dtype to a real dtype.</p>
<p>As implemented, casting a complex number to a real discards its imaginary part, but this behavior may not be what the user actually wants.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L18140">view source</a></div></div><div class="public anchor" id="var-compress"><h3>compress</h3><div class="usage"><code>(compress &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return selected slices of an array along given axis.</p>
<p>When working along a given axis, a slice along that axis is returned in <code>output</code> for each index where <code>condition</code> evaluates to True. When working on a 1-D array, <code>compress</code> is equivalent to <code>extract</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>condition : 1-D array of bools  Array that selects which entries to return. If len(condition)  is less than the size of <code>a</code> along the given axis, then output is  truncated to the length of the condition array. a : array_like  Array from which to extract a part. axis : int, optional  Axis along which to take slices. If None (default), work on the  flattened array. out : ndarray, optional  Output array. Its type is preserved and it must be of the right  shape to hold the output.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>compressed_array : ndarray  A copy of <code>a</code> without the slices along axis for which <code>condition</code>  is false.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>take, choose, diag, diagonal, select ndarray.compress : Equivalent method in ndarray np.extract: Equivalent method when working on 1-D arrays ufuncs-output-type</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array(<a href="null">1, 2], [3, 4], [5, 6</a>) a array(<a href="null">1, 2],
       [3, 4],
       [5, 6</a>) np.compress([0, 1], a, axis=0) array(<a href="null">3, 4</a>) np.compress([False, True, True], a, axis=0) array(<a href="null">3, 4],
       [5, 6</a>) np.compress([False, True], a, axis=1) array(<a href="null">2],
       [4],
       [6</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Working on the flattened array does not return slices along an axis but selects elements.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.compress([False, True], a) array([2])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L438">view source</a></div></div><div class="public anchor" id="var-concatenate"><h3>concatenate</h3><div class="usage"><code>(concatenate &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>concatenate((a1, a2, ), axis=0, out=None)</p>
<p>Join a sequence of arrays along an existing axis.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a1, a2,  : sequence of array_like  The arrays must have the same shape, except in the dimension  corresponding to <code>axis</code> (the first, by default). axis : int, optional  The axis along which the arrays will be joined. If axis is None,  arrays are flattened before use. Default is 0. out : ndarray, optional  If provided, the destination to place the result. The shape must be  correct, matching that of what concatenate would have returned if no  out argument were specified.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>res : ndarray  The concatenated array.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>ma.concatenate : Concatenate function that preserves input masks. array_split : Split an array into multiple sub-arrays of equal or  near-equal size. split : Split array into a list of multiple sub-arrays of equal size. hsplit : Split array into multiple sub-arrays horizontally (column wise) vsplit : Split array into multiple sub-arrays vertically (row wise) dsplit : Split array into multiple sub-arrays along the 3rd axis (depth). stack : Stack a sequence of arrays along a new axis. hstack : Stack arrays in sequence horizontally (column wise) vstack : Stack arrays in sequence vertically (row wise) dstack : Stack arrays in sequence depth wise (along third dimension) block : Assemble arrays from blocks.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>When one or more of the arrays to be concatenated is a MaskedArray, this function will return a MaskedArray object instead of an ndarray, but the input masks are <em>not</em> preserved. In cases where a MaskedArray is expected as input, use the ma.concatenate function from the masked array module instead.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array(<a href="null">1, 2], [3, 4</a>) b = np.array(<a href="null">5, 6</a>) np.concatenate((a, b), axis=0) array(<a href="null">1, 2],
       [3, 4],
       [5, 6</a>) np.concatenate((a, b.T), axis=1) array(<a href="null">1, 2, 5],
       [3, 4, 6</a>) np.concatenate((a, b), axis=None) array([1, 2, 3, 4, 5, 6])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>This function will not preserve masking of MaskedArray inputs.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.ma.arange(3) a[1] = np.ma.masked b = np.arange(2, 5) a masked_array(data=[0, , 2],  mask=[False, True, False],  fill_value=999999) b array([2, 3, 4]) np.concatenate([a, b]) masked_array(data=[0, 1, 2, 2, 3, 4],  mask=False,  fill_value=999999) np.ma.concatenate([a, b]) masked_array(data=[0, , 2, 2, 3, 4],  mask=[False, True, False, False, False, False],  fill_value=999999)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L28243">view source</a></div></div><div class="public anchor" id="var-conj"><h3>conj</h3><div class="usage"><code>(conj self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>conjugate(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Return the complex conjugate, element-wise.</p>
<p>The complex conjugate of a complex number is obtained by changing the sign of its imaginary part.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Input value. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray  The complex conjugate of <code>x</code>, with same dtype as <code>y</code>.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p><code>conj</code> is an alias for <code>conjugate</code>:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.conj is np.conjugate True</p>
    </blockquote>
  </blockquote>
</blockquote>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.conjugate(1+2j) (1-2j)</p>
      <p>x = np.eye(2) + 1j * np.eye(2) np.conjugate(x) array(<a href="null"> 1.-1.j,  0.-0.j],
       [ 0.-0.j,  1.-1.j</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L20819">view source</a></div></div><div class="public anchor" id="var-conjugate"><h3>conjugate</h3><div class="usage"><code>(conjugate self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>conjugate(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Return the complex conjugate, element-wise.</p>
<p>The complex conjugate of a complex number is obtained by changing the sign of its imaginary part.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Input value. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray  The complex conjugate of <code>x</code>, with same dtype as <code>y</code>.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p><code>conj</code> is an alias for <code>conjugate</code>:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.conj is np.conjugate True</p>
    </blockquote>
  </blockquote>
</blockquote>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.conjugate(1+2j) (1-2j)</p>
      <p>x = np.eye(2) + 1j * np.eye(2) np.conjugate(x) array(<a href="null"> 1.-1.j,  0.-0.j],
       [ 0.-0.j,  1.-1.j</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L11885">view source</a></div></div><div class="public anchor" id="var-convolve"><h3>convolve</h3><div class="usage"><code>(convolve &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Returns the discrete, linear convolution of two one-dimensional sequences.</p>
<p>The convolution operator is often seen in signal processing, where it models the effect of a linear time-invariant system on a signal [1]_. In probability theory, the sum of two independent random variables is distributed according to the convolution of their individual distributions.</p>
<p>If <code>v</code> is longer than <code>a</code>, the arrays are swapped before computation.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : (N,) array_like  First one-dimensional input array. v : (M,) array_like  Second one-dimensional input array. mode : {full, valid, same}, optional  full:  By default, mode is full. This returns the convolution  at each point of overlap, with an output shape of (N+M-1,). At  the end-points of the convolution, the signals do not overlap  completely, and boundary effects may be seen.</p>
<pre><code>'same':
  Mode 'same' returns output of length ``max(M, N)``.  Boundary
  effects are still visible.

'valid':
  Mode 'valid' returns output of length
  ``max(M, N) - min(M, N) + 1``.  The convolution product is only given
  for points where the signals overlap completely.  Values outside
  the signal boundary have no effect.
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  Discrete, linear convolution of <code>a</code> and <code>v</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>scipy.signal.fftconvolve : Convolve two arrays using the Fast Fourier  Transform. scipy.linalg.toeplitz : Used to construct the convolution operator. polymul : Polynomial multiplication. Same output as convolve, but also  accepts poly1d objects as input.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The discrete convolution operation is defined as</p>
<p>.. math:: (a * v)[n] = \sum_{m = -\infty}^{\infty} a[m] v[n - m]</p>
<p>It can be shown that a convolution :math:<code>x(t) * y(t)</code> in time/space is equivalent to the multiplication :math:<code>X(f) Y(f)</code> in the Fourier domain, after appropriate padding (padding is necessary to prevent circular convolution). Since multiplication is more efficient (faster) than convolution, the function <code>scipy.signal.fftconvolve</code> exploits the FFT to calculate the convolution of large data-sets.</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [1] Wikipedia, Convolution,  <a href="https://en.wikipedia.org/wiki/Convolution">https://en.wikipedia.org/wiki/Convolution</a></p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>Note how the convolution operator flips the second array before sliding the two across one another:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.convolve([1, 2, 3], [0, 1, 0.5]) array([0. , 1. , 2.5, 4. , 1.5])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Only return the middle values of the convolution. Contains boundary effects, where zeros are taken into account:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.convolve([1,2,3],[0,1,0.5], same) array([1. , 2.5, 4. ])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The two arrays are of the same length, so there is only one position where they completely overlap:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.convolve([1,2,3],[0,1,0.5], valid) array([2.5])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L22686">view source</a></div></div><div class="public anchor" id="var-copy"><h3>copy</h3><div class="usage"><code>(copy &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return an array copy of the given object.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input data. order : {C, F, A, K}, optional  Controls the memory layout of the copy. C means C-order,  F means F-order, A means F if <code>a</code> is Fortran contiguous,  C otherwise. K means match the layout of <code>a</code> as closely  as possible. (Note that this function and :meth:<code>ndarray.copy</code> are very  similar, but have different default values for their order=  arguments.)</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>arr : ndarray  Array interpretation of <code>a</code>.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>This is equivalent to:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.array(a, copy=True) #doctest: +SKIP</p>
    </blockquote>
  </blockquote>
</blockquote>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>Create an array x, with a reference y and a copy z:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.array([1, 2, 3]) y = x z = np.copy(x)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Note that, when we modify x, y changes, but not z:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x[0] = 10 x[0] == y[0] True x[0] == z[0] False</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L4853">view source</a></div></div><div class="public anchor" id="var-copysign"><h3>copysign</h3><div class="usage"><code>(copysign self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>copysign(x1, x2, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Change the sign of x1 to that of x2, element-wise.</p>
<p>If <code>x2</code> is a scalar, its sign will be copied to all elements of <code>x1</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x1 : array_like  Values to change the sign of. x2 : array_like  The sign of <code>x2</code> is copied to <code>x1</code>. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output). out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray or scalar  The values of <code>x1</code> with the sign of <code>x2</code>.  This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.copysign(1.3, -1) -1.3 1/np.copysign(0, 1) inf 1/np.copysign(0, -1) -inf</p>
      <p>np.copysign([-1, 0, 1], -1.1) array([-1., -0., -1.]) np.copysign([-1, 0, 1], np.arange(3)-1) array([-1., 0., 1.])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L5653">view source</a></div></div><div class="public anchor" id="var-copyto"><h3>copyto</h3><div class="usage"><code>(copyto &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>copyto(dst, src, casting=same_kind, where=True)</p>
<p>Copies values from one array to another, broadcasting as necessary.</p>
<p>Raises a TypeError if the <code>casting</code> rule is violated, and if <code>where</code> is provided, it selects which elements to copy.</p>
<p>.. versionadded:: 1.7.0</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>dst : ndarray  The array into which values are copied. src : array_like  The array from which values are copied. casting : {no, equiv, safe, same_kind, unsafe}, optional  Controls what kind of data casting may occur when copying.</p>
<pre><code>  * 'no' means the data types should not be cast at all.
  * 'equiv' means only byte-order changes are allowed.
  * 'safe' means only casts which can preserve values are allowed.
  * 'same_kind' means only safe casts or casts within a kind,
    like float64 to float32, are allowed.
  * 'unsafe' means any data conversions may be done.
</code></pre>
<p>where : array_like of bool, optional  A boolean array which is broadcasted to match the dimensions  of <code>dst</code>, and selects elements to copy from <code>src</code> to <code>dst</code>  wherever it contains the value True.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L28722">view source</a></div></div><div class="public anchor" id="var-core"><h3>core</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Contains the core of NumPy: ndarray, ufuncs, dtypes, etc.</p>
<p>Please note that this module is private. All functions and objects are available in the main <code>numpy</code> namespace - use that instead.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L26729">view source</a></div></div><div class="public anchor" id="var-corrcoef"><h3>corrcoef</h3><div class="usage"><code>(corrcoef &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return Pearson product-moment correlation coefficients.</p>
<p>Please refer to the documentation for <code>cov</code> for more detail. The relationship between the correlation coefficient matrix, <code>R</code>, and the covariance matrix, <code>C</code>, is</p>
<p>.. math:: R_{ij} = \frac{ C_{ij} } { \sqrt{ C_{ii} * C_{jj} } }</p>
<p>The values of <code>R</code> are between -1 and 1, inclusive.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  A 1-D or 2-D array containing multiple variables and observations.  Each row of <code>x</code> represents a variable, and each column a single  observation of all those variables. Also see <code>rowvar</code> below. y : array_like, optional  An additional set of variables and observations. <code>y</code> has the same  shape as <code>x</code>. rowvar : bool, optional  If <code>rowvar</code> is True (default), then each row represents a  variable, with observations in the columns. Otherwise, the relationship  is transposed: each column represents a variable, while the rows  contain observations. bias : _NoValue, optional  Has no effect, do not use.</p>
<pre><code>.. deprecated:: 1.10.0
</code></pre>
<p>ddof : _NoValue, optional  Has no effect, do not use.</p>
<pre><code>.. deprecated:: 1.10.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>R : ndarray  The correlation coefficient matrix of the variables.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>cov : Covariance matrix</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Due to floating point rounding the resulting array may not be Hermitian, the diagonal elements may not be 1, and the elements may not satisfy the inequality abs(a) &lt;= 1. The real and imaginary parts are clipped to the interval [-1, 1] in an attempt to improve on that situation but is not much help in the complex case.</p>
<p>This function accepts but discards arguments <code>bias</code> and <code>ddof</code>. This is for backwards compatibility with previous versions of this function. These arguments had no effect on the return values of the function and can be safely ignored in this and previous versions of numpy.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L6106">view source</a></div></div><div class="public anchor" id="var-correlate"><h3>correlate</h3><div class="usage"><code>(correlate &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Cross-correlation of two 1-dimensional sequences.</p>
<p>This function computes the correlation as generally defined in signal processing texts::</p>
<pre><code>c_{av}[k] = sum_n a[n+k] * conj(v[n])
</code></pre>
<p>with a and v sequences being zero-padded where necessary and conj being the conjugate.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a, v : array_like  Input sequences. mode : {valid, same, full}, optional  Refer to the <code>convolve</code> docstring. Note that the default  is valid, unlike <code>convolve</code>, which uses full. old_behavior : bool  <code>old_behavior</code> was removed in NumPy 1.10. If you need the old  behavior, use <code>multiarray.correlate</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  Discrete cross-correlation of <code>a</code> and <code>v</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>convolve : Discrete, linear convolution of two one-dimensional sequences. multiarray.correlate : Old, no conjugate, version of correlate.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The definition of correlation above is not unique and sometimes correlation may be defined differently. Another common definition is::</p>
<pre><code>c'_{av}[k] = sum_n a[n] conj(v[n+k])
</code></pre>
<p>which is related to <code>c_{av}[k]</code> by <code>c'_{av}[k] = c_{av}[-k]</code>.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.correlate([1, 2, 3], [0, 1, 0.5]) array([3.5]) np.correlate([1, 2, 3], [0, 1, 0.5], same) array([2. , 3.5, 3. ]) np.correlate([1, 2, 3], [0, 1, 0.5], full) array([0.5, 2. , 3.5, 3. , 0. ])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Using complex sequences:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.correlate([1+1j, 2, 3-1j], [0, 1, 0.5j], full) array([ 0.5-0.5j, 1.0+0.j , 1.5-1.5j, 3.0-1.j , 0.0+0.j ])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Note that you get the time reversed, complex conjugated result when the two input sequences change places, i.e., <code>c_{va}[k] = c^{*}_{av}[-k]</code>:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.correlate([0, 1, 0.5j], [1+1j, 2, 3-1j], full) array([ 0.0+0.j , 3.0+1.j , 1.5+1.5j, 1.0+0.j , 0.5+0.5j])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L17805">view source</a></div></div><div class="public anchor" id="var-cos"><h3>cos</h3><div class="usage"><code>(cos self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>cos(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Cosine element-wise.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Input array in radians. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray  The corresponding cosine values.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>If <code>out</code> is provided, the function writes the result into it, and returns a reference to <code>out</code>. (See Examples)</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions. New York, NY: Dover, 1972.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.cos(np.array([0, np.pi/2, np.pi])) array([ 1.00000000e+00, 6.12303177e-17, -1.00000000e+00])</p>
      <h1><a href="#example-of-providing-the-optional-output-parameter" name="example-of-providing-the-optional-output-parameter"></a>Example of providing the optional output parameter</h1>
      <p>out1 = np.array([0], dtype=d) out2 = np.cos([0.1], out1) out2 is out1 True</p>
      <h1><a href="#example-of-valueerror-due-to-provision-of-shape-mis-matched" name="example-of-valueerror-due-to-provision-of-shape-mis-matched"></a>Example of ValueError due to provision of shape mis-matched <code>out</code></h1>
      <p>np.cos(np.zeros((3,3)),np.zeros((2,2))) Traceback (most recent call last):  File <stdin>, line 1, in <module> ValueError: operands could not be broadcast together with shapes (3,3) (2,2)</module></stdin></p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L19177">view source</a></div></div><div class="public anchor" id="var-cosh"><h3>cosh</h3><div class="usage"><code>(cosh self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>cosh(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Hyperbolic cosine, element-wise.</p>
<p>Equivalent to <code>1/2 * (np.exp(x) + np.exp(-x))</code> and <code>np.cos(1j*x)</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Input array. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray or scalar  Output array of same shape as <code>x</code>.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.cosh(0) 1.0</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The hyperbolic cosine describes the shape of a hanging cable:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>import matplotlib.pyplot as plt x = np.linspace(-4, 4, 1000) plt.plot(x, np.cosh(x)) plt.show()</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L1488">view source</a></div></div><div class="public anchor" id="var-count_nonzero"><h3>count_nonzero</h3><div class="usage"><code>(count_nonzero &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Counts the number of non-zero values in the array <code>a</code>.</p>
<p>The word non-zero is in reference to the Python 2.x built-in method <code>__nonzero__()</code> (renamed <code>__bool__()</code> in Python 3.x) of Python objects that tests an objects truthfulness. For example, any number is considered truthful if it is nonzero, whereas any string is considered truthful if it is not the empty string. Thus, this function (recursively) counts how many elements in <code>a</code> (and in sub-arrays thereof) have their <code>__nonzero__()</code> or <code>__bool__()</code> method evaluated to <code>True</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  The array for which to count non-zeros. axis : int or tuple, optional  Axis or tuple of axes along which to count non-zeros.  Default is None, meaning that non-zeros will be counted  along a flattened version of <code>a</code>.</p>
<pre><code>.. versionadded:: 1.12.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>count : int or array of int  Number of non-zero values in the array along a given axis.  Otherwise, the total number of non-zero values in the array  is returned.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>nonzero : Return the coordinates of all the non-zero values.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.count_nonzero(np.eye(4)) 4 np.count_nonzero(<a href="null">0,1,7,0,0],[3,0,0,2,19</a>) 5 np.count_nonzero(<a href="null">0,1,7,0,0],[3,0,0,2,19</a>, axis=0) array([1, 1, 1, 1, 1]) np.count_nonzero(<a href="null">0,1,7,0,0],[3,0,0,2,19</a>, axis=1) array([2, 3])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L12537">view source</a></div></div><div class="public anchor" id="var-cov"><h3>cov</h3><div class="usage"><code>(cov &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Estimate a covariance matrix, given data and weights.</p>
<p>Covariance indicates the level to which two variables vary together. If we examine N-dimensional samples, :math:<code>X = [x_1, x_2, ... x_N]^T</code>, then the covariance matrix element :math:<code>C_{ij}</code> is the covariance of :math:<code>x_i</code> and :math:<code>x_j</code>. The element :math:<code>C_{ii}</code> is the variance of :math:<code>x_i</code>.</p>
<p>See the notes for an outline of the algorithm.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>m : array_like  A 1-D or 2-D array containing multiple variables and observations.  Each row of <code>m</code> represents a variable, and each column a single  observation of all those variables. Also see <code>rowvar</code> below. y : array_like, optional  An additional set of variables and observations. <code>y</code> has the same form  as that of <code>m</code>. rowvar : bool, optional  If <code>rowvar</code> is True (default), then each row represents a  variable, with observations in the columns. Otherwise, the relationship  is transposed: each column represents a variable, while the rows  contain observations. bias : bool, optional  Default normalization (False) is by <code>(N - 1)</code>, where <code>N</code> is the  number of observations given (unbiased estimate). If <code>bias</code> is True,  then normalization is by <code>N</code>. These values can be overridden by using  the keyword <code>ddof</code> in numpy versions &gt;= 1.5. ddof : int, optional  If not <code>None</code> the default value implied by <code>bias</code> is overridden.  Note that <code>ddof=1</code> will return the unbiased estimate, even if both  <code>fweights</code> and <code>aweights</code> are specified, and <code>ddof=0</code> will return  the simple average. See the notes for the details. The default value  is <code>None</code>.</p>
<pre><code>.. versionadded:: 1.5
</code></pre>
<p>fweights : array_like, int, optional  1-D array of integer frequency weights; the number of times each  observation vector should be repeated.</p>
<pre><code>.. versionadded:: 1.10
</code></pre>
<p>aweights : array_like, optional  1-D array of observation vector weights. These relative weights are  typically large for observations considered important and smaller for  observations considered less important. If <code>ddof=0</code> the array of  weights can be used to assign probabilities to observation vectors.</p>
<pre><code>.. versionadded:: 1.10
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  The covariance matrix of the variables.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>corrcoef : Normalized covariance matrix</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Assume that the observations are in the columns of the observation array <code>m</code> and let <code>f = fweights</code> and <code>a = aweights</code> for brevity. The steps to compute the weighted covariance are as follows::</p>
<pre><code>&gt;&gt;&gt; m = np.arange(10, dtype=np.float64)
&gt;&gt;&gt; f = np.arange(10) * 2
&gt;&gt;&gt; a = np.arange(10) ** 2.
&gt;&gt;&gt; ddof = 1
&gt;&gt;&gt; w = f * a
&gt;&gt;&gt; v1 = np.sum(w)
&gt;&gt;&gt; v2 = np.sum(w * a)
&gt;&gt;&gt; m -= np.sum(m * w, axis=None, keepdims=True) / v1
&gt;&gt;&gt; cov = np.dot(m * w, m.T) * v1 / (v1**2 - ddof * v2)
</code></pre>
<p>Note that when <code>a == 1</code>, the normalization factor <code>v1 / (v1**2 - ddof * v2)</code> goes over to <code>1 / (np.sum(f) - ddof)</code> as it should.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>Consider two variables, :math:<code>x_0</code> and :math:<code>x_1</code>, which correlate perfectly, but in opposite directions:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.array(<a href="null">0, 2], [1, 1], [2, 0</a>).T x array(<a href="null">0, 1, 2],
       [2, 1, 0</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Note how :math:<code>x_0</code> increases while :math:<code>x_1</code> decreases. The covariance matrix shows this clearly:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.cov(x) array(<a href="null"> 1., -1.],
       [-1.,  1.</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Note that element :math:<code>C_{0,1}</code>, which shows the correlation between :math:<code>x_0</code> and :math:<code>x_1</code>, is negative.</p>
<p>Further, note how <code>x</code> and <code>y</code> are combined:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = [-2.1, -1, 4.3] y = [3, 1.1, 0.12] X = np.stack((x, y), axis=0) np.cov(X) array(<a href="null">11.71      , -4.286     ], # may vary
       [-4.286     ,  2.144133</a>) np.cov(x, y) array(<a href="null">11.71      , -4.286     ], # may vary
       [-4.286     ,  2.144133</a>) np.cov(x) array(11.71)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L23098">view source</a></div></div><div class="public anchor" id="var-cross"><h3>cross</h3><div class="usage"><code>(cross &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return the cross product of two (arrays of) vectors.</p>
<p>The cross product of <code>a</code> and <code>b</code> in :math:<code>R^3</code> is a vector perpendicular to both <code>a</code> and <code>b</code>. If <code>a</code> and <code>b</code> are arrays of vectors, the vectors are defined by the last axis of <code>a</code> and <code>b</code> by default, and these axes can have dimensions 2 or 3. Where the dimension of either <code>a</code> or <code>b</code> is 2, the third component of the input vector is assumed to be zero and the cross product calculated accordingly. In cases where both input vectors have dimension 2, the z-component of the cross product is returned.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Components of the first vector(s). b : array_like  Components of the second vector(s). axisa : int, optional  Axis of <code>a</code> that defines the vector(s). By default, the last axis. axisb : int, optional  Axis of <code>b</code> that defines the vector(s). By default, the last axis. axisc : int, optional  Axis of <code>c</code> containing the cross product vector(s). Ignored if  both input vectors have dimension 2, as the return is scalar.  By default, the last axis. axis : int, optional  If defined, the axis of <code>a</code>, <code>b</code> and <code>c</code> that defines the vector(s)  and cross product(s). Overrides <code>axisa</code>, <code>axisb</code> and <code>axisc</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>c : ndarray  Vector cross product(s).</p>
<h2><a href="#raises" name="raises"></a>Raises</h2>
<p>ValueError  When the dimension of the vector(s) in <code>a</code> and/or <code>b</code> does not  equal 2 or 3.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>inner : Inner product outer : Outer product. ix_ : Construct index arrays.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>.. versionadded:: 1.9.0</p>
<p>Supports full broadcasting of the inputs.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>Vector cross-product.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = [1, 2, 3] y = [4, 5, 6] np.cross(x, y) array([-3, 6, -3])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>One vector with dimension 2.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = [1, 2] y = [4, 5, 6] np.cross(x, y) array([12, -6, -3])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Equivalently:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = [1, 2, 0] y = [4, 5, 6] np.cross(x, y) array([12, -6, -3])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Both vectors with dimension 2.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = [1,2] y = [4,5] np.cross(x, y) array(-3)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Multiple vector cross-products. Note that the direction of the cross product vector is defined by the <code>right-hand rule</code>.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.array(<a href="null">1,2,3], [4,5,6</a>) y = np.array(<a href="null">4,5,6], [1,2,3</a>) np.cross(x, y) array(<a href="null">-3,  6, -3],
       [ 3, -6,  3</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The orientation of <code>c</code> can be changed using the <code>axisc</code> keyword.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.cross(x, y, axisc=0) array(<a href="null">-3,  3],
       [ 6, -6],
       [-3,  3</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Change the vector definition of <code>x</code> and <code>y</code> using <code>axisa</code> and <code>axisb</code>.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.array(<a href="null">1,2,3], [4,5,6], [7, 8, 9</a>) y = np.array(<a href="null">7, 8, 9], [4,5,6], [1,2,3</a>) np.cross(x, y) array(<a href="null"> -6,  12,  -6],
       [  0,   0,   0],
       [  6, -12,   6</a>) np.cross(x, y, axisa=0, axisb=0) array(<a href="null">-24,  48, -24],
       [-30,  60, -30],
       [-36,  72, -36</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L8093">view source</a></div></div><div class="public anchor" id="var-csingle"><h3>csingle</h3><div class="usage"><code>(csingle self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Complex number type composed of two single-precision floating-point numbers. Character code: <code>'F'</code>. Canonical name: <code>np.csingle</code>. Alias: <code>np.singlecomplex</code>. Alias <em>on this platform</em>: <code>np.complex64</code>: Complex number type composed of 2 32-bit-precision floating-point numbers.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L6189">view source</a></div></div><div class="public anchor" id="var-ctypeslib"><h3>ctypeslib</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>============================</p>
<h1><a href="#utility-functions" name="utility-functions"></a><code>ctypes</code> Utility Functions</h1>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>load_library : Load a C library. ndpointer : Array restype/argtype with verification. as_ctypes : Create a ctypes array from an ndarray. as_array : Create an ndarray from a ctypes array.</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [1] SciPy Cookbook: ctypes, <a href="https://scipy-cookbook.readthedocs.io/items/Ctypes.html">https://scipy-cookbook.readthedocs.io/items/Ctypes.html</a></p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>Load the C library:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>_lib = np.ctypeslib.load_library(libmystuff, .) #doctest: +SKIP</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Our result type, an ndarray that must be of type double, be 1-dimensional and is C-contiguous in memory:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>array_1d_double = np.ctypeslib.ndpointer(  dtype=np.double,  ndim=1, flags=CONTIGUOUS) #doctest: +SKIP</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Our C-function typically takes an array and updates its values in-place. For example::</p>
<pre><code>void foo_func(double* x, int length)
{
    int i;
    for (i = 0; i &lt; length; i++) {
        x[i] = i*i;
    }
}
</code></pre>
<p>We wrap it using:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>_lib.foo_func.restype = None #doctest: +SKIP _lib.foo_func.argtypes = [array_1d_double, c_int] #doctest: +SKIP</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Then, were ready to call <code>foo_func</code>:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>out = np.empty(15, dtype=np.double) _lib.foo_func(out, len(out)) #doctest: +SKIP</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L2284">view source</a></div></div><div class="public anchor" id="var-cumprod"><h3>cumprod</h3><div class="usage"><code>(cumprod &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return the cumulative product of elements along a given axis.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input array. axis : int, optional  Axis along which the cumulative product is computed. By default  the input is flattened. dtype : dtype, optional  Type of the returned array, as well as of the accumulator in which  the elements are multiplied. If <em>dtype</em> is not specified, it  defaults to the dtype of <code>a</code>, unless <code>a</code> has an integer dtype with  a precision less than that of the default platform integer. In  that case, the default platform integer is used instead. out : ndarray, optional  Alternative output array in which to place the result. It must  have the same shape and buffer length as the expected output  but the type of the resulting values will be cast if necessary.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>cumprod : ndarray  A new array holding the result is returned unless <code>out</code> is  specified, in which case a reference to out is returned.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>ufuncs-output-type</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Arithmetic is modular when using integer types, and no error is raised on overflow.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array([1,2,3]) np.cumprod(a) # intermediate results 1, 1*2  # total product 1*2*3 = 6 array([1, 2, 6]) a = np.array(<a href="null">1, 2, 3], [4, 5, 6</a>) np.cumprod(a, dtype=float) # specify type of output array([ 1., 2., 6., 24., 120., 720.])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The cumulative product for each column (i.e., over the rows) of <code>a</code>:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.cumprod(a, axis=0) array(<a href="null"> 1,  2,  3],
       [ 4, 10, 18</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The cumulative product for each row (i.e. over the columns) of <code>a</code>:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.cumprod(a,axis=1) array(<a href="null">  1,   2,   6],
       [  4,  20, 120</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L8261">view source</a></div></div><div class="public anchor" id="var-cumproduct"><h3>cumproduct</h3><div class="usage"><code>(cumproduct &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return the cumulative product over the given axis.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>cumprod : equivalent function; see for details.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L24062">view source</a></div></div><div class="public anchor" id="var-cumsum"><h3>cumsum</h3><div class="usage"><code>(cumsum &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return the cumulative sum of the elements along a given axis.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input array. axis : int, optional  Axis along which the cumulative sum is computed. The default  (None) is to compute the cumsum over the flattened array. dtype : dtype, optional  Type of the returned array and of the accumulator in which the  elements are summed. If <code>dtype</code> is not specified, it defaults  to the dtype of <code>a</code>, unless <code>a</code> has an integer dtype with a  precision less than that of the default platform integer. In  that case, the default platform integer is used. out : ndarray, optional  Alternative output array in which to place the result. It must  have the same shape and buffer length as the expected output  but the type will be cast if necessary. See <code>ufuncs-output-type</code> for  more details.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>cumsum_along_axis : ndarray.  A new array holding the result is returned unless <code>out</code> is  specified, in which case a reference to <code>out</code> is returned. The  result has the same size as <code>a</code>, and the same shape as <code>a</code> if  <code>axis</code> is not None or <code>a</code> is a 1-d array.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>sum : Sum array elements.</p>
<p>trapz : Integration of array values using the composite trapezoidal rule.</p>
<p>diff : Calculate the n-th discrete difference along given axis.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Arithmetic is modular when using integer types, and no error is raised on overflow.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array(<a href="null">1,2,3], [4,5,6</a>) a array(<a href="null">1, 2, 3],
       [4, 5, 6</a>) np.cumsum(a) array([ 1, 3, 6, 10, 15, 21]) np.cumsum(a, dtype=float) # specifies type of output value(s) array([ 1., 3., 6., 10., 15., 21.])</p>
      <p>np.cumsum(a,axis=0) # sum over rows for each of the 3 columns array(<a href="null">1, 2, 3],
       [5, 7, 9</a>) np.cumsum(a,axis=1) # sum over columns for each of the 2 rows array(<a href="null"> 1,  3,  6],
       [ 4,  9, 15</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L25171">view source</a></div></div><div class="public anchor" id="var-DataSource"><h3>DataSource</h3><div class="usage"><code>(DataSource self &amp; [{destpath :destpath}])</code><code>(DataSource self)</code></div><div class="doc"><div class="markdown"><p>DataSource(destpath=.)</p>
<p>A generic data source file (file, http, ftp, ).</p>
<p>DataSources can be local files or remote files/URLs. The files may also be compressed or uncompressed. DataSource hides some of the low-level details of downloading the file, allowing you to simply pass in a valid file path (or URL) and obtain a file object.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>destpath : str or None, optional  Path to the directory where the source file gets downloaded to for  use. If <code>destpath</code> is None, a temporary directory will be created.  The default path is the current directory.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>URLs require a scheme string (<code>http://</code>) to be used, without it they will fail::</p>
<pre><code>&gt;&gt;&gt; repos = np.DataSource()
&gt;&gt;&gt; repos.exists('www.google.com/index.html')
False
&gt;&gt;&gt; repos.exists('http://www.google.com/index.html')
True
</code></pre>
<p>Temporary directories are deleted when the DataSource is deleted.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>::</p>
<pre><code>&gt;&gt;&gt; ds = np.DataSource('/home/guido')
&gt;&gt;&gt; urlname = 'http://www.google.com/'
&gt;&gt;&gt; gfile = ds.open('http://www.google.com/')
&gt;&gt;&gt; ds.abspath(urlname)
'/home/guido/www.google.com/index.html'

&gt;&gt;&gt; ds = np.DataSource(None)  # use with temporary file
&gt;&gt;&gt; ds.open('/home/guido/foobar.txt')
&lt;open file '/home/guido.foobar.txt', mode 'r' at 0x91d4430&gt;
&gt;&gt;&gt; ds.abspath('/home/guido/foobar.txt')
'/tmp/.../home/guido/foobar.txt'
</code></pre></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L19364">view source</a></div></div><div class="public anchor" id="var-datetime64"><h3>datetime64</h3><div class="usage"><code>(datetime64 self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L28719">view source</a></div></div><div class="public anchor" id="var-datetime_as_string"><h3>datetime_as_string</h3><div class="usage"><code>(datetime_as_string &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>datetime_as_string(arr, unit=None, timezone=naive, casting=same_kind)</p>
<p>Convert an array of datetimes into an array of strings.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>arr : array_like of datetime64  The array of UTC timestamps to format. unit : str  One of None, auto, or a :ref:<code>datetime unit &lt;arrays.dtypes.dateunits&gt;</code>. timezone : {naive, UTC, local} or tzinfo  Timezone information to use when displaying the datetime. If UTC, end  with a Z to indicate UTC time. If local, convert to the local timezone  first, and suffix with a +-#### timezone offset. If a tzinfo object,  then do as with local, but use the specified timezone. casting : {no, equiv, safe, same_kind, unsafe}  Casting to allow when changing between datetime units.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>str_arr : ndarray  An array of strings the same shape as <code>arr</code>.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>import pytz d = np.arange(2002-10-27T04:30, 4*60, 60, dtype=M8[m]) d array([2002-10-27T04:30, 2002-10-27T05:30, 2002-10-27T06:30,  2002-10-27T07:30], dtype=datetime64[m])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Setting the timezone to UTC shows the same information, but with a Z suffix</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.datetime_as_string(d, timezone=UTC) array([2002-10-27T04:30Z, 2002-10-27T05:30Z, 2002-10-27T06:30Z,  2002-10-27T07:30Z], dtype=&lt;U35)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Note that we picked datetimes that cross a DST boundary. Passing in a <code>pytz</code> timezone object will print the appropriate offset</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.datetime_as_string(d, timezone=pytz.timezone(US/Eastern)) array([2002-10-27T00:30-0400, 2002-10-27T01:30-0400,  2002-10-27T01:30-0500, 2002-10-27T02:30-0500], dtype=&lt;U39)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Passing in a unit will change the precision</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.datetime_as_string(d, unit=h) array([2002-10-27T04, 2002-10-27T05, 2002-10-27T06, 2002-10-27T07],  dtype=&lt;U32) np.datetime_as_string(d, unit=s) array([2002-10-27T04:30:00, 2002-10-27T05:30:00, 2002-10-27T06:30:00,  2002-10-27T07:30:00], dtype=&lt;U38)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>casting can be used to specify whether precision can be changed</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.datetime_as_string(d, unit=h, casting=safe) Traceback (most recent call last):   TypeError: Cannot create a datetime string as units h from a NumPy datetime with units m according to the rule safe</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L12403">view source</a></div></div><div class="public anchor" id="var-datetime_data"><h3>datetime_data</h3><div class="usage"><code>(datetime_data self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>datetime_data(dtype, /)</p>
<p>Get information about the step size of a date or time type.</p>
<p>The returned tuple can be passed as the second argument of <code>numpy.datetime64</code> and <code>numpy.timedelta64</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>dtype : dtype  The dtype object, which must be a <code>datetime64</code> or <code>timedelta64</code> type.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>unit : str  The :ref:<code>datetime unit &lt;arrays.dtypes.dateunits&gt;</code> on which this dtype  is based. count : int  The number of base units in a step.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>dt_25s = np.dtype(timedelta64[25s]) np.datetime_data(dt_25s) (s, 25) np.array(10, dt_25s).astype(timedelta64[s]) array(250, dtype=timedelta64[s])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The result can be used to construct a datetime that uses the same units as a timedelta</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.datetime64(2010, np.datetime_data(dt_25s)) numpy.datetime64(2010-01-01T00:00:00,25s)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L12467">view source</a></div></div><div class="public anchor" id="var-deg2rad"><h3>deg2rad</h3><div class="usage"><code>(deg2rad self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>deg2rad(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Convert angles from degrees to radians.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Angles in degrees. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray  The corresponding angle in radians.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>rad2deg : Convert angles from radians to degrees. unwrap : Remove large jumps in angle by wrapping.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>.. versionadded:: 1.3.0</p>
<p><code>deg2rad(x)</code> is <code>x * pi / 180</code>.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.deg2rad(180) 3.1415926535897931</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L28917">view source</a></div></div><div class="public anchor" id="var-degrees"><h3>degrees</h3><div class="usage"><code>(degrees self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>degrees(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Convert angles from radians to degrees.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Input array in radians. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray of floats  The corresponding degree values; if <code>out</code> was supplied this is a  reference to it.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>rad2deg : equivalent function</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>Convert a radian array to degrees</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>rad = np.arange(12.)*np.pi/6 np.degrees(rad) array([ 0., 30., 60., 90., 120., 150., 180., 210., 240.,  270., 300., 330.])</p>
      <p>out = np.zeros((rad.shape)) r = np.degrees(rad, out) np.all(r == out) True</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L10964">view source</a></div></div><div class="public anchor" id="var-delete"><h3>delete</h3><div class="usage"><code>(delete &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return a new array with sub-arrays along an axis deleted. For a one dimensional array, this returns those entries not returned by <code>arr[obj]</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>arr : array_like  Input array. obj : slice, int or array of ints  Indicate indices of sub-arrays to remove along the specified axis. axis : int, optional  The axis along which to delete the subarray defined by <code>obj</code>.  If <code>axis</code> is None, <code>obj</code> is applied to the flattened array.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  A copy of <code>arr</code> with the elements specified by <code>obj</code> removed. Note  that <code>delete</code> does not occur in-place. If <code>axis</code> is None, <code>out</code> is  a flattened array.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>insert : Insert elements into an array. append : Append elements at the end of an array.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Often it is preferable to use a boolean mask. For example:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>arr = np.arange(12) + 1 mask = np.ones(len(arr), dtype=bool) mask<a href="null">0,2,4</a> = False result = arr[mask,]</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Is equivalent to <code>np.delete(arr, [0,2,4], axis=0)</code>, but allows further use of <code>mask</code>.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>arr = np.array(<a href="null">1,2,3,4], [5,6,7,8], [9,10,11,12</a>) arr array(<a href="null"> 1,  2,  3,  4],
       [ 5,  6,  7,  8],
       [ 9, 10, 11, 12</a>) np.delete(arr, 1, 0) array(<a href="null"> 1,  2,  3,  4],
       [ 9, 10, 11, 12</a>)</p>
      <p>np.delete(arr, np.s_[::2], 1) array(<a href="null"> 2,  4],
       [ 6,  8],
       [10, 12</a>) np.delete(arr, [1,3,5], None) array([ 1, 3, 5, 7, 8, 9, 10, 11, 12])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L5708">view source</a></div></div><div class="public anchor" id="var-deprecate"><h3>deprecate</h3><div class="usage"><code>(deprecate &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Issues a DeprecationWarning, adds warning to <code>old_name</code>s docstring, rebinds <code>old_name.__name__</code> and returns the new function object.</p>
<p>This function may also be used as a decorator.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>func : function  The function to be deprecated. old_name : str, optional  The name of the function to be deprecated. Default is None, in  which case the name of <code>func</code> is used. new_name : str, optional  The new name for the function. Default is None, in which case the  deprecation message is that <code>old_name</code> is deprecated. If given, the  deprecation message is that <code>old_name</code> is deprecated and <code>new_name</code>  should be used instead. message : str, optional  Additional explanation of the deprecation. Displayed in the  docstring after the warning.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>old_func : function  The deprecated function.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>Note that <code>olduint</code> returns a value after printing Deprecation Warning:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>olduint = np.deprecate(np.uint) DeprecationWarning: <code>uint64</code> is deprecated! # may vary olduint(6) 6</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L2741">view source</a></div></div><div class="public anchor" id="var-deprecate_with_doc"><h3>deprecate_with_doc</h3><div class="usage"><code>(deprecate_with_doc msg)</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L6315">view source</a></div></div><div class="public anchor" id="var-diag"><h3>diag</h3><div class="usage"><code>(diag &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Extract a diagonal or construct a diagonal array.</p>
<p>See the more detailed documentation for <code>numpy.diagonal</code> if you use this function to extract a diagonal and wish to write to the resulting array; whether it returns a copy or a view depends on what version of numpy you are using.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>v : array_like  If <code>v</code> is a 2-D array, return a copy of its <code>k</code>-th diagonal.  If <code>v</code> is a 1-D array, return a 2-D array with <code>v</code> on the <code>k</code>-th  diagonal. k : int, optional  Diagonal in question. The default is 0. Use <code>k&gt;0</code> for diagonals  above the main diagonal, and <code>k&lt;0</code> for diagonals below the main  diagonal.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  The extracted diagonal or constructed diagonal array.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>diagonal : Return specified diagonals. diagflat : Create a 2-D array with the flattened input as a diagonal. trace : Sum along diagonals. triu : Upper triangle of an array. tril : Lower triangle of an array.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.arange(9).reshape((3,3)) x array(<a href="null">0, 1, 2],
       [3, 4, 5],
       [6, 7, 8</a>)</p>
      <p>np.diag(x) array([0, 4, 8]) np.diag(x, k=1) array([1, 5]) np.diag(x, k=-1) array([3, 7])</p>
      <p>np.diag(np.diag(x)) array(<a href="null">0, 0, 0],
       [0, 4, 0],
       [0, 0, 8</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L979">view source</a></div></div><div class="public anchor" id="var-diag_indices"><h3>diag_indices</h3><div class="usage"><code>(diag_indices n &amp; [{ndim :ndim}])</code><code>(diag_indices n)</code></div><div class="doc"><div class="markdown"><p>Return the indices to access the main diagonal of an array.</p>
<p>This returns a tuple of indices that can be used to access the main diagonal of an array <code>a</code> with <code>a.ndim &gt;= 2</code> dimensions and shape (n, n, , n). For <code>a.ndim = 2</code> this is the usual diagonal, for <code>a.ndim &gt; 2</code> this is the set of indices to access <code>a[i, i, ..., i]</code> for <code>i = [0..n-1]</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>n : int  The size, along each dimension, of the arrays for which the returned  indices can be used.</p>
<p>ndim : int, optional  The number of dimensions.</p>
<h2><a href="#see-also" name="see-also"></a>See also</h2>
<p>diag_indices_from</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>.. versionadded:: 1.4.0</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>Create a set of indices to access the diagonal of a (4, 4) array:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>di = np.diag_indices(4) di (array([0, 1, 2, 3]), array([0, 1, 2, 3])) a = np.arange(16).reshape(4, 4) a array(<a href="null"> 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15</a>) a[di] = 100 a array(<a href="null">100,   1,   2,   3],
       [  4, 100,   6,   7],
       [  8,   9, 100,  11],
       [ 12,  13,  14, 100</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Now, we create indices to manipulate a 3-D array:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>d3 = np.diag_indices(2, 3) d3 (array([0, 1]), array([0, 1]), array([0, 1]))</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>And use it to set the diagonal of an array of zeros to 1:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.zeros((2, 2, 2), dtype=int) a[d3] = 1 a array(<a href="null">[1, 0],
        [0, 0</a>,  <a href="null">0, 0],
        [0, 1</a>])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L24280">view source</a></div></div><div class="public anchor" id="var-diag_indices_from"><h3>diag_indices_from</h3><div class="usage"><code>(diag_indices_from &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return the indices to access the main diagonal of an n-dimensional array.</p>
<p>See <code>diag_indices</code> for full details.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>arr : array, at least 2-D</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>diag_indices</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>.. versionadded:: 1.4.0</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L13203">view source</a></div></div><div class="public anchor" id="var-diagflat"><h3>diagflat</h3><div class="usage"><code>(diagflat &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Create a two-dimensional array with the flattened input as a diagonal.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>v : array_like  Input data, which is flattened and set as the <code>k</code>-th  diagonal of the output. k : int, optional  Diagonal to set; 0, the default, corresponds to the main diagonal,  a positive (negative) <code>k</code> giving the number of the diagonal above  (below) the main.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  The 2-D output array.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>diag : MATLAB work-alike for 1-D and 2-D arrays. diagonal : Return specified diagonals. trace : Sum along diagonals.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.diagflat(<a href="null">1,2], [3,4</a>) array(<a href="null">1, 0, 0, 0],
       [0, 2, 0, 0],
       [0, 0, 3, 0],
       [0, 0, 0, 4</a>)</p>
      <p>np.diagflat([1,2], 1) array(<a href="null">0, 1, 0],
       [0, 0, 2],
       [0, 0, 0</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L25645">view source</a></div></div><div class="public anchor" id="var-diagonal"><h3>diagonal</h3><div class="usage"><code>(diagonal &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return specified diagonals.</p>
<p>If <code>a</code> is 2-D, returns the diagonal of <code>a</code> with the given offset, i.e., the collection of elements of the form <code>a[i, i+offset]</code>. If <code>a</code> has more than two dimensions, then the axes specified by <code>axis1</code> and <code>axis2</code> are used to determine the 2-D sub-array whose diagonal is returned. The shape of the resulting array can be determined by removing <code>axis1</code> and <code>axis2</code> and appending an index to the right equal to the size of the resulting diagonals.</p>
<p>In versions of NumPy prior to 1.7, this function always returned a new, independent array containing a copy of the values in the diagonal.</p>
<p>In NumPy 1.7 and 1.8, it continues to return a copy of the diagonal, but depending on this fact is deprecated. Writing to the resulting array continues to work as it used to, but a FutureWarning is issued.</p>
<p>Starting in NumPy 1.9 it returns a read-only view on the original array. Attempting to write to the resulting array will produce an error.</p>
<p>In some future release, it will return a read/write view and writing to the returned array will alter your original array. The returned array will have the same type as the input array.</p>
<p>If you dont write to the array returned by this function, then you can just ignore all of the above.</p>
<p>If you depend on the current behavior, then we suggest copying the returned array explicitly, i.e., use <code>np.diagonal(a).copy()</code> instead of just <code>np.diagonal(a)</code>. This will work with both past and future versions of NumPy.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Array from which the diagonals are taken. offset : int, optional  Offset of the diagonal from the main diagonal. Can be positive or  negative. Defaults to main diagonal (0). axis1 : int, optional  Axis to be used as the first axis of the 2-D sub-arrays from which  the diagonals should be taken. Defaults to first axis (0). axis2 : int, optional  Axis to be used as the second axis of the 2-D sub-arrays from  which the diagonals should be taken. Defaults to second axis (1).</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>array_of_diagonals : ndarray  If <code>a</code> is 2-D, then a 1-D array containing the diagonal and of the  same type as <code>a</code> is returned unless <code>a</code> is a <code>matrix</code>, in which case  a 1-D array rather than a (2-D) <code>matrix</code> is returned in order to  maintain backward compatibility.</p>
<pre><code>If ``a.ndim &gt; 2``, then the dimensions specified by `axis1` and `axis2`
are removed, and a new axis inserted at the end corresponding to the
diagonal.
</code></pre>
<h2><a href="#raises" name="raises"></a>Raises</h2>
<p>ValueError  If the dimension of <code>a</code> is less than 2.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>diag : MATLAB work-a-like for 1-D and 2-D arrays. diagflat : Create diagonal arrays. trace : Sum along diagonals.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.arange(4).reshape(2,2) a array(<a href="null">0, 1],
       [2, 3</a>) a.diagonal() array([0, 3]) a.diagonal(1) array([1])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>A 3-D example:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.arange(8).reshape(2,2,2); a array(<a href="null">[0, 1],
        [2, 3</a>,  <a href="null">4, 5],
        [6, 7</a>]) a.diagonal(0, # Main diagonals of two arrays created by skipping  0, # across the outer(left)-most axis last and  1) # the middle (row) axis first. array(<a href="null">0, 6],
       [1, 7</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The sub-arrays whose main diagonals we just obtained; note that each corresponds to fixing the right-most (column) axis, and that the diagonals are packed in rows.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a[:,:,0] # main diagonal is [0 6] array(<a href="null">0, 2],
       [4, 6</a>) a[:,:,1] # main diagonal is [1 7] array(<a href="null">1, 3],
       [5, 7</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The anti-diagonal can be obtained by reversing the order of elements using either <code>numpy.flipud</code> or <code>numpy.fliplr</code>.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.arange(9).reshape(3, 3) a array(<a href="null">0, 1, 2],
       [3, 4, 5],
       [6, 7, 8</a>) np.fliplr(a).diagonal() # Horizontal flip array([2, 4, 6]) np.flipud(a).diagonal() # Vertical flip array([6, 4, 2])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Note that the order in which the diagonal is retrieved varies depending on the flip function.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L9790">view source</a></div></div><div class="public anchor" id="var-diff"><h3>diff</h3><div class="usage"><code>(diff &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Calculate the n-th discrete difference along the given axis.</p>
<p>The first difference is given by <code>out[i] = a[i+1] - a[i]</code> along the given axis, higher differences are calculated by using <code>diff</code> recursively.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input array n : int, optional  The number of times values are differenced. If zero, the input  is returned as-is. axis : int, optional  The axis along which the difference is taken, default is the  last axis. prepend, append : array_like, optional  Values to prepend or append to <code>a</code> along axis prior to  performing the difference. Scalar values are expanded to  arrays with length 1 in the direction of axis and the shape  of the input array in along all other axes. Otherwise the  dimension and shape must match <code>a</code> except along axis.</p>
<pre><code>.. versionadded:: 1.16.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>diff : ndarray  The n-th differences. The shape of the output is the same as <code>a</code>  except along <code>axis</code> where the dimension is smaller by <code>n</code>. The  type of the output is the same as the type of the difference  between any two elements of <code>a</code>. This is the same as the type of  <code>a</code> in most cases. A notable exception is <code>datetime64</code>, which  results in a <code>timedelta64</code> output array.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>gradient, ediff1d, cumsum</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Type is preserved for boolean arrays, so the result will contain <code>False</code> when consecutive elements are the same and <code>True</code> when they differ.</p>
<p>For unsigned integer arrays, the results will also be unsigned. This should not be surprising, as the result is consistent with calculating the difference directly:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>u8_arr = np.array([1, 0], dtype=np.uint8) np.diff(u8_arr) array([255], dtype=uint8) u8_arr[1,] - u8_arr[0,] 255</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>If this is not desirable, then the array should be cast to a larger integer type first:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>i16_arr = u8_arr.astype(np.int16) np.diff(i16_arr) array([-1], dtype=int16)</p>
    </blockquote>
  </blockquote>
</blockquote>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.array([1, 2, 4, 7, 0]) np.diff(x) array([ 1, 2, 3, -7]) np.diff(x, n=2) array([ 1, 1, -10])</p>
      <p>x = np.array(<a href="null">1, 3, 6, 10], [0, 5, 6, 8</a>) np.diff(x) array(<a href="null">2, 3, 4],
       [5, 1, 2</a>) np.diff(x, axis=0) array(<a href="null">-1,  2,  0, -2</a>)</p>
      <p>x = np.arange(1066-10-13, 1066-10-16, dtype=np.datetime64) np.diff(x) array([1, 1], dtype=timedelta64[D])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L11016">view source</a></div></div><div class="public anchor" id="var-digitize"><h3>digitize</h3><div class="usage"><code>(digitize &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return the indices of the bins to which each value in input array belongs.</p>
<p>========= ============= ============================ <code>right</code> order of bins returned index <code>i</code> satisfies ========= ============= ============================ <code>False</code> increasing <code>bins[i-1] &lt;= x &lt; bins[i]</code> <code>True</code> increasing <code>bins[i-1] &lt; x &lt;= bins[i]</code> <code>False</code> decreasing <code>bins[i-1] &gt; x &gt;= bins[i]</code> <code>True</code> decreasing <code>bins[i-1] &gt;= x &gt; bins[i]</code> ========= ============= ============================</p>
<p>If values in <code>x</code> are beyond the bounds of <code>bins</code>, 0 or <code>len(bins)</code> is returned as appropriate.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Input array to be binned. Prior to NumPy 1.10.0, this array had to  be 1-dimensional, but can now have any shape. bins : array_like  Array of bins. It has to be 1-dimensional and monotonic. right : bool, optional  Indicating whether the intervals include the right or the left bin  edge. Default behavior is (right==False) indicating that the interval  does not include the right edge. The left bin end is open in this  case, i.e., bins[i-1] &lt;= x &lt; bins[i] is the default behavior for  monotonically increasing bins.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>indices : ndarray of ints  Output array of indices, of same shape as <code>x</code>.</p>
<h2><a href="#raises" name="raises"></a>Raises</h2>
<p>ValueError  If <code>bins</code> is not monotonic. TypeError  If the type of the input is complex.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>bincount, histogram, unique, searchsorted</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>If values in <code>x</code> are such that they fall outside the bin range, attempting to index <code>bins</code> with the indices that <code>digitize</code> returns will result in an IndexError.</p>
<p>.. versionadded:: 1.10.0</p>
<p><code>np.digitize</code> is implemented in terms of <code>np.searchsorted</code>. This means that a binary search is used to bin the values, which scales much better for larger number of bins than the previous linear search. It also removes the requirement for the input array to be 1-dimensional.</p>
<p>For monotonically <em>increasing</em> <code>bins</code>, the following are equivalent::</p>
<pre><code>np.digitize(x, bins, right=True)
np.searchsorted(bins, x, side='left')
</code></pre>
<p>Note that as the order of the arguments are reversed, the side must be too. The <code>searchsorted</code> call is marginally faster, as it does not do any monotonicity checks. Perhaps more importantly, it supports all dtypes.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.array([0.2, 6.4, 3.0, 1.6]) bins = np.array([0.0, 1.0, 2.5, 4.0, 10.0]) inds = np.digitize(x, bins) inds array([1, 4, 3, 2]) for n in range(x.size):  print(bins[inds[n]-1], &lt;=, x[n], &lt;, bins[inds[n]])  0.0 &lt;= 0.2 &lt; 1.0 4.0 &lt;= 6.4 &lt; 10.0 2.5 &lt;= 3.0 &lt; 4.0 1.0 &lt;= 1.6 &lt; 2.5</p>
      <p>x = np.array([1.2, 10.0, 12.4, 15.5, 20.]) bins = np.array([0, 5, 10, 15, 20]) np.digitize(x,bins,right=True) array([1, 2, 3, 4, 4]) np.digitize(x,bins,right=False) array([1, 3, 3, 4, 5])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L1130">view source</a></div></div><div class="public anchor" id="var-disp"><h3>disp</h3><div class="usage"><code>(disp mesg &amp; [{device :device, linefeed :linefeed}])</code><code>(disp mesg &amp; [{device :device}])</code><code>(disp mesg)</code></div><div class="doc"><div class="markdown"><p>Display a message on a device.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>mesg : str  Message to display. device : object  Device to write message. If None, defaults to <code>sys.stdout</code> which is  very similar to <code>print</code>. <code>device</code> needs to have <code>write()</code> and  <code>flush()</code> methods. linefeed : bool, optional  Option whether to print a line feed or not. Defaults to True.</p>
<h2><a href="#raises" name="raises"></a>Raises</h2>
<p>AttributeError  If <code>device</code> does not have a <code>write()</code> or <code>flush()</code> method.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>Besides <code>sys.stdout</code>, a file-like object can also be used as it has both required methods:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>from io import StringIO buf = StringIO() np.disp(uDisplay in a file, device=buf) buf.getvalue() Display in a file\n</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L14279">view source</a></div></div><div class="public anchor" id="var-divide"><h3>divide</h3><div class="usage"><code>(divide self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>true_divide(x1, x2, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Returns a true division of the inputs, element-wise.</p>
<p>Instead of the Python traditional floor division, this returns a true division. True division adjusts the output type to present the best answer, regardless of input types.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x1 : array_like  Dividend array. x2 : array_like  Divisor array. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output). out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray or scalar  This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The floor division operator <code>//</code> was added in Python 2.2 making <code>//</code> and <code>/</code> equivalent operators. The default floor division operation of <code>/</code> can be replaced by true division with <code>from
__future__ import division</code>.</p>
<p>In Python 3.0, <code>//</code> is the floor division operator and <code>/</code> the true division operator. The <code>true_divide(x1, x2)</code> function is equivalent to true division in Python.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.arange(5) np.true_divide(x, 4) array([ 0. , 0.25, 0.5 , 0.75, 1. ])</p>
      <p>x//4 array([0, 0, 0, 0, 1])</p>
      <p>from <strong>future</strong> import division x/4 array([ 0. , 0.25, 0.5 , 0.75, 1. ]) x//4 array([0, 0, 0, 0, 1])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L21713">view source</a></div></div><div class="public anchor" id="var-division"><h3>division</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L13397">view source</a></div></div><div class="public anchor" id="var-divmod"><h3>divmod</h3><div class="usage"><code>(divmod self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>divmod(x1, x2[, out1, out2], / [, out=(None, None)], *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Return element-wise quotient and remainder simultaneously.</p>
<p>.. versionadded:: 1.13.0</p>
<p><code>np.divmod(x, y)</code> is equivalent to <code>(x // y, x % y)</code>, but faster because it avoids redundant work. It is used to implement the Python built-in function <code>divmod</code> on NumPy arrays.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x1 : array_like  Dividend array. x2 : array_like  Divisor array. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output). out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out1 : ndarray  Element-wise quotient resulting from floor division.  This is a scalar if both <code>x1</code> and <code>x2</code> are scalars. out2 : ndarray  Element-wise remainder from floor division.  This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>floor_divide : Equivalent to Pythons <code>//</code> operator. remainder : Equivalent to Pythons <code>%</code> operator. modf : Equivalent to <code>divmod(x, 1)</code> for positive <code>x</code> with the return  values switched.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.divmod(np.arange(5), 3) (array([0, 0, 0, 1, 1]), array([0, 1, 2, 0, 1]))</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L13147">view source</a></div></div><div class="public anchor" id="var-dot"><h3>dot</h3><div class="usage"><code>(dot &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>dot(a, b, out=None)</p>
<p>Dot product of two arrays. Specifically,</p>
<ul>
  <li>
  <p>If both <code>a</code> and <code>b</code> are 1-D arrays, it is inner product of vectors  (without complex conjugation).</p></li>
  <li>
  <p>If both <code>a</code> and <code>b</code> are 2-D arrays, it is matrix multiplication,  but using :func:<code>matmul</code> or <code>a @ b</code> is preferred.</p></li>
  <li>
  <p>If either <code>a</code> or <code>b</code> is 0-D (scalar), it is equivalent to :func:<code>multiply</code>  and using <code>numpy.multiply(a, b)</code> or <code>a * b</code> is preferred.</p></li>
  <li>
  <p>If <code>a</code> is an N-D array and <code>b</code> is a 1-D array, it is a sum product over  the last axis of <code>a</code> and <code>b</code>.</p></li>
  <li>
    <p>If <code>a</code> is an N-D array and <code>b</code> is an M-D array (where <code>M&gt;=2</code>), it is a  sum product over the last axis of <code>a</code> and the second-to-last axis of <code>b</code>::</p>
    <p>dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])</p>
  </li>
</ul>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  First argument. b : array_like  Second argument. out : ndarray, optional  Output argument. This must have the exact kind that would be returned  if it was not used. In particular, it must have the right type, must be  C-contiguous, and its dtype must be the dtype that would be returned  for <code>dot(a,b)</code>. This is a performance feature. Therefore, if these  conditions are not met, an exception is raised, instead of attempting  to be flexible.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>output : ndarray  Returns the dot product of <code>a</code> and <code>b</code>. If <code>a</code> and <code>b</code> are both  scalars or both 1-D arrays then a scalar is returned; otherwise  an array is returned.  If <code>out</code> is given, then it is returned.</p>
<h2><a href="#raises" name="raises"></a>Raises</h2>
<p>ValueError  If the last dimension of <code>a</code> is not the same size as  the second-to-last dimension of <code>b</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>vdot : Complex-conjugating dot product. tensordot : Sum products over arbitrary axes. einsum : Einstein summation convention. matmul : @ operator as method with out parameter.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.dot(3, 4) 12</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Neither argument is complex-conjugated:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.dot([2j, 3j], [2j, 3j]) (-13+0j)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>For 2-D arrays it is the matrix product:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = <a href="null">1, 0], [0, 1</a> b = <a href="null">4, 1], [2, 2</a> np.dot(a, b) array(<a href="null">4, 1],
       [2, 2</a>)</p>
      <p>a = np.arange(3*4*5*6).reshape((3,4,5,6)) b = np.arange(3*4*5*6)[::-1].reshape((5,4,6,3)) np.dot(a, b)[2,3,2,1,2,2] 499128 sum(a[2,3,2,:] * b[1,2,:,2]) 499128</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L7733">view source</a></div></div><div class="public anchor" id="var-double"><h3>double</h3><div class="usage"><code>(double self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Double-precision floating-point number type, compatible with Python <code>float</code> and C <code>double</code>. Character code: <code>'d'</code>. Canonical name: <code>np.double</code>. Alias: <code>np.float_</code>. Alias <em>on this platform</em>: <code>np.float64</code>: 64-bit precision floating-point number type: sign bit, 11 bits exponent, 52 bits mantissa.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L21204">view source</a></div></div><div class="public anchor" id="var-dsplit"><h3>dsplit</h3><div class="usage"><code>(dsplit &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Split array into multiple sub-arrays along the 3rd axis (depth).</p>
<p>Please refer to the <code>split</code> documentation. <code>dsplit</code> is equivalent to <code>split</code> with <code>axis=2</code>, the array is always split along the third axis provided the array dimension is greater than or equal to 3.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>split : Split an array into multiple sub-arrays of equal size.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.arange(16.0).reshape(2, 2, 4) x array(<a href="null">[ 0.,   1.,   2.,   3.],
        [ 4.,   5.,   6.,   7.</a>,  <a href="null"> 8.,   9.,  10.,  11.],
        [12.,  13.,  14.,  15.</a>]) np.dsplit(x, 2) [array([[[ 0., 1.],  [ 4., 5.]],  [[ 8., 9.],  [12., 13.]]]), array([[[ 2., 3.],  [ 6., 7.]],  [[10., 11.],  [14., 15.]]])] np.dsplit(x, np.array([3, 6])) [array([[[ 0., 1., 2.],  [ 4., 5., 6.]],  [[ 8., 9., 10.],  [12., 13., 14.]]]),  array([[[ 3.],  [ 7.]],  [[11.],  [15.]]]), array([], shape=(2, 2, 0), dtype=float64)]</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L24545">view source</a></div></div><div class="public anchor" id="var-dstack"><h3>dstack</h3><div class="usage"><code>(dstack &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Stack arrays in sequence depth wise (along third axis).</p>
<p>This is equivalent to concatenation along the third axis after 2-D arrays of shape <code>(M,N)</code> have been reshaped to <code>(M,N,1)</code> and 1-D arrays of shape <code>(N,)</code> have been reshaped to <code>(1,N,1)</code>. Rebuilds arrays divided by <code>dsplit</code>.</p>
<p>This function makes most sense for arrays with up to 3 dimensions. For instance, for pixel-data with a height (first axis), width (second axis), and r/g/b channels (third axis). The functions <code>concatenate</code>, <code>stack</code> and <code>block</code> provide more general stacking and concatenation operations.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>tup : sequence of arrays  The arrays must have the same shape along all but the third axis.  1-D or 2-D arrays must have the same shape.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>stacked : ndarray  The array formed by stacking the given arrays, will be at least 3-D.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>stack : Join a sequence of arrays along a new axis. vstack : Stack along first axis. hstack : Stack along second axis. concatenate : Join a sequence of arrays along an existing axis. dsplit : Split array along third axis.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array((1,2,3)) b = np.array((2,3,4)) np.dstack((a,b)) array(<a href="null">[1, 2],
        [2, 3],
        [3, 4</a>])</p>
      <p>a = np.array(<a href="null">1],[2],[3</a>) b = np.array(<a href="null">2],[3],[4</a>) np.dstack((a,b)) array(<a href="null">[1, 2</a>,  <a href="null">2, 3</a>,  <a href="null">3, 4</a>])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L22018">view source</a></div></div><div class="public anchor" id="var-dtype"><h3>dtype</h3><div class="usage"><code>(dtype self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>dtype(obj, align=False, copy=False)</p>
<p>Create a data type object.</p>
<p>A numpy array is homogeneous, and contains elements described by a dtype object. A dtype object can be constructed from different combinations of fundamental numeric types.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>obj  Object to be converted to a data type object. align : bool, optional  Add padding to the fields to match what a C compiler would output  for a similar C-struct. Can be <code>True</code> only if <code>obj</code> is a dictionary  or a comma-separated string. If a struct dtype is being created,  this also sets a sticky alignment flag <code>isalignedstruct</code>. copy : bool, optional  Make a new copy of the data-type object. If <code>False</code>, the result  may just be a reference to a built-in data-type object.</p>
<h2><a href="#see-also" name="see-also"></a>See also</h2>
<p>result_type</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>Using array-scalar type:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.dtype(np.int16) dtype(int16)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Structured type, one field name f1, containing int16:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.dtype([(f1, np.int16)]) dtype([(f1, &lt;i2)])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Structured type, one field named f1, in itself containing a structured type with one field:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.dtype([(f1, [(f1, np.int16)])]) dtype([(f1, [(f1, &lt;i2)])])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Structured type, two fields: the first field contains an unsigned int, the second an int32:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.dtype([(f1, np.uint64), (f2, np.int32)]) dtype([(f1, &lt;u8), (f2, &lt;i4)])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Using array-protocol type strings:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.dtype([(a,f8),(b,S10)]) dtype([(a, &lt;f8), (b, S10)])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Using comma-separated field formats. The shape is (2,3):</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.dtype(i4, (2,3)f8) dtype([(f0, &lt;i4), (f1, &lt;f8, (2, 3))])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Using tuples. <code>int</code> is a fixed type, 3 the fields shape. <code>void</code> is a flexible type, here of size 10:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.dtype([(hello,(np.int64,3)),(world,np.void,10)]) dtype([(hello, &lt;i8, (3,)), (world, V10)])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Subdivide <code>int16</code> into 2 <code>int8</code>s, called x and y. 0 and 1 are the offsets in bytes:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.dtype((np.int16, {x:(np.int8,0), y:(np.int8,1)})) dtype((numpy.int16, [(x, i1), (y, i1)]))</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Using dictionaries. Two fields named gender and age:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.dtype({names:[gender,age], formats:[S1,np.uint8]}) dtype([(gender, S1), (age, u1)])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Offsets in bytes, here 0 and 25:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.dtype({surname:(S25,0),age:(np.uint8,25)}) dtype([(surname, S25), (age, u1)])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L25417">view source</a></div></div><div class="public anchor" id="var-e"><h3>e</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L4383">view source</a></div></div><div class="public anchor" id="var-ediff1d"><h3>ediff1d</h3><div class="usage"><code>(ediff1d &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>The differences between consecutive elements of an array.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>ary : array_like  If necessary, will be flattened before the differences are taken. to_end : array_like, optional  Number(s) to append at the end of the returned differences. to_begin : array_like, optional  Number(s) to prepend at the beginning of the returned differences.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>ediff1d : ndarray  The differences. Loosely, this is <code>ary.flat[1:] - ary.flat[:-1]</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>diff, gradient</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>When applied to masked arrays, this function drops the mask information if the <code>to_begin</code> and/or <code>to_end</code> parameters are used.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.array([1, 2, 4, 7, 0]) np.ediff1d(x) array([ 1, 2, 3, -7])</p>
      <p>np.ediff1d(x, to_begin=-99, to_end=np.array([88, 99])) array([-99, 1, 2, , -7, 88, 99])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The returned array is always 1D.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>y = <a href="null">1, 2, 4], [1, 6, 24</a> np.ediff1d(y) array([ 1, 2, -3, 5, 18])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L5881">view source</a></div></div><div class="public anchor" id="var-einsum"><h3>einsum</h3><div class="usage"><code>(einsum &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>einsum(subscripts, *operands, out=None, dtype=None, order=K,  casting=safe, optimize=False)</p>
<p>Evaluates the Einstein summation convention on the operands.</p>
<p>Using the Einstein summation convention, many common multi-dimensional, linear algebraic array operations can be represented in a simple fashion. In <em>implicit</em> mode <code>einsum</code> computes these values.</p>
<p>In <em>explicit</em> mode, <code>einsum</code> provides further flexibility to compute other array operations that might not be considered classical Einstein summation operations, by disabling, or forcing summation over specified subscript labels.</p>
<p>See the notes and examples for clarification.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>subscripts : str  Specifies the subscripts for summation as comma separated list of  subscript labels. An implicit (classical Einstein summation)  calculation is performed unless the explicit indicator -&gt; is  included as well as subscript labels of the precise output form. operands : list of array_like  These are the arrays for the operation. out : ndarray, optional  If provided, the calculation is done into this array. dtype : {data-type, None}, optional  If provided, forces the calculation to use the data type specified.  Note that you may have to also give a more liberal <code>casting</code>  parameter to allow the conversions. Default is None. order : {C, F, A, K}, optional  Controls the memory layout of the output. C means it should  be C contiguous. F means it should be Fortran contiguous,  A means it should be F if the inputs are all F, C otherwise.  K means it should be as close to the layout as the inputs as  is possible, including arbitrarily permuted axes.  Default is K. casting : {no, equiv, safe, same_kind, unsafe}, optional  Controls what kind of data casting may occur. Setting this to  unsafe is not recommended, as it can adversely affect accumulations.</p>
<pre><code>  * 'no' means the data types should not be cast at all.
  * 'equiv' means only byte-order changes are allowed.
  * 'safe' means only casts which can preserve values are allowed.
  * 'same_kind' means only safe casts or casts within a kind,
    like float64 to float32, are allowed.
  * 'unsafe' means any data conversions may be done.

Default is 'safe'.
</code></pre>
<p>optimize : {False, True, greedy, optimal}, optional  Controls if intermediate optimization should occur. No optimization  will occur if False and True will default to the greedy algorithm.  Also accepts an explicit contraction list from the <code>np.einsum_path</code>  function. See <code>np.einsum_path</code> for more details. Defaults to False.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>output : ndarray  The calculation based on the Einstein summation convention.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>einsum_path, dot, inner, outer, tensordot, linalg.multi_dot</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>.. versionadded:: 1.6.0</p>
<p>The Einstein summation convention can be used to compute many multi-dimensional, linear algebraic array operations. <code>einsum</code> provides a succinct way of representing these.</p>
<p>A non-exhaustive list of these operations, which can be computed by <code>einsum</code>, is shown below along with examples:</p>
<ul>
  <li>Trace of an array, :py:func:<code>numpy.trace</code>.</li>
  <li>Return a diagonal, :py:func:<code>numpy.diag</code>.</li>
  <li>Array axis summations, :py:func:<code>numpy.sum</code>.</li>
  <li>Transpositions and permutations, :py:func:<code>numpy.transpose</code>.</li>
  <li>Matrix multiplication and dot product, :py:func:<code>numpy.matmul</code> :py:func:<code>numpy.dot</code>.</li>
  <li>Vector inner and outer products, :py:func:<code>numpy.inner</code> :py:func:<code>numpy.outer</code>.</li>
  <li>Broadcasting, element-wise and scalar multiplication, :py:func:<code>numpy.multiply</code>.</li>
  <li>Tensor contractions, :py:func:<code>numpy.tensordot</code>.</li>
  <li>Chained array operations, in efficient calculation order, :py:func:<code>numpy.einsum_path</code>.</li>
</ul>
<p>The subscripts string is a comma-separated list of subscript labels, where each label refers to a dimension of the corresponding operand. Whenever a label is repeated it is summed, so <code>np.einsum('i,i', a, b)</code> is equivalent to :py:func:<code>np.inner(a,b) &lt;numpy.inner&gt;</code>. If a label appears only once, it is not summed, so <code>np.einsum('i', a)</code> produces a view of <code>a</code> with no changes. A further example <code>np.einsum('ij,jk', a, b)</code> describes traditional matrix multiplication and is equivalent to :py:func:<code>np.matmul(a,b) &lt;numpy.matmul&gt;</code>. Repeated subscript labels in one operand take the diagonal. For example, <code>np.einsum('ii', a)</code> is equivalent to :py:func:<code>np.trace(a) &lt;numpy.trace&gt;</code>.</p>
<p>In <em>implicit mode</em>, the chosen subscripts are important since the axes of the output are reordered alphabetically. This means that <code>np.einsum('ij', a)</code> doesnt affect a 2D array, while <code>np.einsum('ji', a)</code> takes its transpose. Additionally, <code>np.einsum('ij,jk', a, b)</code> returns a matrix multiplication, while, <code>np.einsum('ij,jh', a, b)</code> returns the transpose of the multiplication since subscript h precedes subscript i.</p>
<p>In <em>explicit mode</em> the output can be directly controlled by specifying output subscript labels. This requires the identifier -&gt; as well as the list of output subscript labels. This feature increases the flexibility of the function since summing can be disabled or forced when required. The call <code>np.einsum('i-&gt;', a)</code> is like :py:func:<code>np.sum(a, axis=-1) &lt;numpy.sum&gt;</code>, and <code>np.einsum('ii-&gt;i', a)</code> is like :py:func:<code>np.diag(a) &lt;numpy.diag&gt;</code>. The difference is that <code>einsum</code> does not allow broadcasting by default. Additionally <code>np.einsum('ij,jh-&gt;ih', a, b)</code> directly specifies the order of the output subscript labels and therefore returns matrix multiplication, unlike the example above in implicit mode.</p>
<p>To enable and control broadcasting, use an ellipsis. Default NumPy-style broadcasting is done by adding an ellipsis to the left of each term, like <code>np.einsum('...ii-&gt;...i', a)</code>. To take the trace along the first and last axes, you can do <code>np.einsum('i...i', a)</code>, or to do a matrix-matrix product with the left-most indices instead of rightmost, one can do <code>np.einsum('ij...,jk...-&gt;ik...', a, b)</code>.</p>
<p>When there is only one operand, no axes are summed, and no output parameter is provided, a view into the operand is returned instead of a new array. Thus, taking the diagonal as <code>np.einsum('ii-&gt;i', a)</code> produces a view (changed in version 1.10.0).</p>
<p><code>einsum</code> also provides an alternative way to provide the subscripts and operands as <code>einsum(op0, sublist0, op1, sublist1, ..., [sublistout])</code>. If the output shape is not provided in this format <code>einsum</code> will be calculated in implicit mode, otherwise it will be performed explicitly. The examples below have corresponding <code>einsum</code> calls with the two parameter methods.</p>
<p>.. versionadded:: 1.10.0</p>
<p>Views returned from einsum are now writeable whenever the input array is writeable. For example, <code>np.einsum('ijk...-&gt;kji...', a)</code> will now have the same effect as :py:func:<code>np.swapaxes(a, 0, 2) &lt;numpy.swapaxes&gt;</code> and <code>np.einsum('ii-&gt;i', a)</code> will return a writeable view of the diagonal of a 2D array.</p>
<p>.. versionadded:: 1.12.0</p>
<p>Added the <code>optimize</code> argument which will optimize the contraction order of an einsum expression. For a contraction with three or more operands this can greatly increase the computational efficiency at the cost of a larger memory footprint during computation.</p>
<p>Typically a greedy algorithm is applied which empirical tests have shown returns the optimal path in the majority of cases. In some cases optimal will return the superlative path through a more expensive, exhaustive search. For iterative calculations it may be advisable to calculate the optimal path once and reuse that path by supplying it as an argument. An example is given below.</p>
<p>See :py:func:<code>numpy.einsum_path</code> for more details.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.arange(25).reshape(5,5) b = np.arange(5) c = np.arange(6).reshape(2,3)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Trace of a matrix:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.einsum(ii, a) 60 np.einsum(a, [0,0]) 60 np.trace(a) 60</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Extract the diagonal (requires explicit form):</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.einsum(ii-&gt;i, a) array([ 0, 6, 12, 18, 24]) np.einsum(a, [0,0], [0]) array([ 0, 6, 12, 18, 24]) np.diag(a) array([ 0, 6, 12, 18, 24])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Sum over an axis (requires explicit form):</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.einsum(ij-&gt;i, a) array([ 10, 35, 60, 85, 110]) np.einsum(a, [0,1], [0]) array([ 10, 35, 60, 85, 110]) np.sum(a, axis=1) array([ 10, 35, 60, 85, 110])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>For higher dimensional arrays summing a single axis can be done with ellipsis:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.einsum(j-&gt;, a) array([ 10, 35, 60, 85, 110]) np.einsum(a, [Ellipsis,1], [Ellipsis]) array([ 10, 35, 60, 85, 110])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Compute a matrix transpose, or reorder any number of axes:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.einsum(ji, c) array(<a href="null">0, 3],
       [1, 4],
       [2, 5</a>) np.einsum(ij-&gt;ji, c) array(<a href="null">0, 3],
       [1, 4],
       [2, 5</a>) np.einsum(c, [1,0]) array(<a href="null">0, 3],
       [1, 4],
       [2, 5</a>) np.transpose(c) array(<a href="null">0, 3],
       [1, 4],
       [2, 5</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Vector inner products:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.einsum(i,i, b, b) 30 np.einsum(b, [0], b, [0]) 30 np.inner(b,b) 30</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Matrix vector multiplication:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.einsum(ij,j, a, b) array([ 30, 80, 130, 180, 230]) np.einsum(a, [0,1], b, [1]) array([ 30, 80, 130, 180, 230]) np.dot(a, b) array([ 30, 80, 130, 180, 230]) np.einsum(j,j, a, b) array([ 30, 80, 130, 180, 230])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Broadcasting and scalar multiplication:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.einsum(, , 3, c) array(<a href="null"> 0,  3,  6],
       [ 9, 12, 15</a>) np.einsum(,ij, 3, c) array(<a href="null"> 0,  3,  6],
       [ 9, 12, 15</a>) np.einsum(3, [Ellipsis], c, [Ellipsis]) array(<a href="null"> 0,  3,  6],
       [ 9, 12, 15</a>) np.multiply(3, c) array(<a href="null"> 0,  3,  6],
       [ 9, 12, 15</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Vector outer product:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.einsum(i,j, np.arange(2)+1, b) array(<a href="null">0, 1, 2, 3, 4],
       [0, 2, 4, 6, 8</a>) np.einsum(np.arange(2)+1, [0], b, [1]) array(<a href="null">0, 1, 2, 3, 4],
       [0, 2, 4, 6, 8</a>) np.outer(np.arange(2)+1, b) array(<a href="null">0, 1, 2, 3, 4],
       [0, 2, 4, 6, 8</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Tensor contraction:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.arange(60.).reshape(3,4,5) b = np.arange(24.).reshape(4,3,2) np.einsum(ijk,jil-&gt;kl, a, b) array(<a href="null">4400., 4730.],
       [4532., 4874.],
       [4664., 5018.],
       [4796., 5162.],
       [4928., 5306.</a>) np.einsum(a, [0,1,2], b, [1,0,3], [2,3]) array(<a href="null">4400., 4730.],
       [4532., 4874.],
       [4664., 5018.],
       [4796., 5162.],
       [4928., 5306.</a>) np.tensordot(a,b, axes=([1,0],[0,1])) array(<a href="null">4400., 4730.],
       [4532., 4874.],
       [4664., 5018.],
       [4796., 5162.],
       [4928., 5306.</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Writeable returned arrays (since version 1.10.0):</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.zeros((3, 3)) np.einsum(ii-&gt;i, a)[:] = 1 a array(<a href="null">1., 0., 0.],
       [0., 1., 0.],
       [0., 0., 1.</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Example of ellipsis use:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.arange(6).reshape((3,2)) b = np.arange(12).reshape((4,3)) np.einsum(ki,jk-&gt;ij, a, b) array(<a href="null">10, 28, 46, 64],
       [13, 40, 67, 94</a>) np.einsum(ki,k-&gt;i, a, b) array(<a href="null">10, 28, 46, 64],
       [13, 40, 67, 94</a>) np.einsum(k,jk, a, b) array(<a href="null">10, 28, 46, 64],
       [13, 40, 67, 94</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Chained array operations. For more complicated contractions, speed ups might be achieved by repeatedly computing a greedy path or pre-computing the optimal path and repeatedly applying it, using an <code>einsum_path</code> insertion (since version 1.12.0). Performance improvements can be particularly significant with larger arrays:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.ones(64).reshape(2,4,8)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Basic <code>einsum</code>: ~1520ms (benchmarked on 3.1GHz Intel i5.)</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>for iteration in range(500):  _ = np.einsum(ijk,ilm,njm,nlk,abc-&gt;,a,a,a,a,a)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Sub-optimal <code>einsum</code> (due to repeated path calculation time): ~330ms</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>for iteration in range(500):  _ = np.einsum(ijk,ilm,njm,nlk,abc-&gt;,a,a,a,a,a, optimize=optimal)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Greedy <code>einsum</code> (faster optimal path approximation): ~160ms</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>for iteration in range(500):  _ = np.einsum(ijk,ilm,njm,nlk,abc-&gt;,a,a,a,a,a, optimize=greedy)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Optimal <code>einsum</code> (best usage pattern in some use cases): ~110ms</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>path = np.einsum_path(ijk,ilm,njm,nlk,abc-&gt;,a,a,a,a,a, optimize=optimal)[0] for iteration in range(500):  _ = np.einsum(ijk,ilm,njm,nlk,abc-&gt;,a,a,a,a,a, optimize=path)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L24673">view source</a></div></div><div class="public anchor" id="var-einsum_path"><h3>einsum_path</h3><div class="usage"><code>(einsum_path &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>einsum_path(subscripts, *operands, optimize=greedy)</p>
<p>Evaluates the lowest cost contraction order for an einsum expression by considering the creation of intermediate arrays.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>subscripts : str  Specifies the subscripts for summation. *operands : list of array_like  These are the arrays for the operation. optimize : {bool, list, tuple, greedy, optimal}  Choose the type of path. If a tuple is provided, the second argument is  assumed to be the maximum intermediate size created. If only a single  argument is provided the largest input or output array size is used  as a maximum intermediate size.</p>
<pre><code>* if a list is given that starts with ``einsum_path``, uses this as the
  contraction path
* if False no optimization is taken
* if True defaults to the 'greedy' algorithm
* 'optimal' An algorithm that combinatorially explores all possible
  ways of contracting the listed tensors and choosest the least costly
  path. Scales exponentially with the number of terms in the
  contraction.
* 'greedy' An algorithm that chooses the best pair contraction
  at each step. Effectively, this algorithm searches the largest inner,
  Hadamard, and then outer products at each step. Scales cubically with
  the number of terms in the contraction. Equivalent to the 'optimal'
  path for most contractions.

Default is 'greedy'.
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>path : list of tuples  A list representation of the einsum path. string_repr : str  A printable representation of the einsum path.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The resulting path indicates which terms of the input contraction should be contracted first, the result of this contraction is then appended to the end of the contraction list. This list can then be iterated over until all intermediate contractions are complete.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>einsum, linalg.multi_dot</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>We can begin with a chain dot example. In this case, it is optimal to contract the <code>b</code> and <code>c</code> tensors first as represented by the first element of the path <code>(1, 2)</code>. The resulting tensor is added to the end of the contraction and the remaining contraction <code>(0, 1)</code> is then completed.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.random.seed(123) a = np.random.rand(2, 2) b = np.random.rand(2, 5) c = np.random.rand(5, 2) path_info = np.einsum_path(ij,jk,kl-&gt;il, a, b, c, optimize=greedy) print(path_info[0]) [einsum_path, (1, 2), (0, 1)] print(path_info[1])  Complete contraction: ij,jk,kl-&gt;il # may vary  Naive scaling: 4  Optimized scaling: 3  Naive FLOP count: 1.600e+02  Optimized FLOP count: 5.600e+01  Theoretical speedup: 2.857</p>
      <h2><a href="#largest-intermediate-4-000e-00-elements" name="largest-intermediate-4-000e-00-elements"></a> Largest intermediate: 4.000e+00 elements</h2>
      <h2><a href="#scaling-current-remaining" name="scaling-current-remaining"></a>scaling current remaining</h2>
      <p>3 kl,jk-&gt;jl ij,jl-&gt;il  3 jl,ij-&gt;il il-&gt;il</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>A more complex index transformation example.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>I = np.random.rand(10, 10, 10, 10) C = np.random.rand(10, 10) path_info = np.einsum_path(ea,fb,abcd,gc,hd-&gt;efgh, C, C, I, C, C,  optimize=greedy)</p>
      <p>print(path_info[0]) [einsum_path, (0, 2), (0, 3), (0, 2), (0, 1)] print(path_info[1])  Complete contraction: ea,fb,abcd,gc,hd-&gt;efgh # may vary  Naive scaling: 8  Optimized scaling: 5  Naive FLOP count: 8.000e+08  Optimized FLOP count: 8.000e+05  Theoretical speedup: 1000.000</p>
      <h2><a href="#largest-intermediate-1-000e-04-elements" name="largest-intermediate-1-000e-04-elements"></a> Largest intermediate: 1.000e+04 elements</h2>
      <h2><a href="#scaling-current-remaining" name="scaling-current-remaining"></a>scaling current remaining</h2>
      <p>5 abcd,ea-&gt;bcde fb,gc,hd,bcde-&gt;efgh  5 bcde,fb-&gt;cdef gc,hd,cdef-&gt;efgh  5 cdef,gc-&gt;defg hd,defg-&gt;efgh  5 defg,hd-&gt;efgh efgh-&gt;efgh</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L10008">view source</a></div></div><div class="public anchor" id="var-emath"><h3>emath</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Wrapper functions to more user-friendly calling of certain math functions whose output data-type is different than the input data-type in certain domains of the input.</p>
<p>For example, for functions like <code>log</code> with branch cuts, the versions in this module provide the mathematically valid answers in the complex plane::</p>
<p>&gt;&gt;&gt; import math  &gt;&gt;&gt; from numpy.lib import scimath  &gt;&gt;&gt; scimath.log(-math.exp(1)) == (1+1j*math.pi)  True</p>
<p>Similarly, <code>sqrt</code>, other base logarithms, <code>power</code> and trig functions are correctly handled. See their respective docstrings for specific examples.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L6791">view source</a></div></div><div class="public anchor" id="var-empty"><h3>empty</h3><div class="usage"><code>(empty self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>empty(shape, dtype=float, order=C)</p>
<p>Return a new array of given shape and type, without initializing entries.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>shape : int or tuple of int  Shape of the empty array, e.g., <code>(2, 3)</code> or <code>2</code>. dtype : data-type, optional  Desired output data-type for the array, e.g, <code>numpy.int8</code>. Default is  <code>numpy.float64</code>. order : {C, F}, optional, default: C  Whether to store multi-dimensional data in row-major  (C-style) or column-major (Fortran-style) order in  memory.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  Array of uninitialized (arbitrary) data of the given shape, dtype, and  order. Object arrays will be initialized to None.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>empty_like : Return an empty array with shape and type of input. ones : Return a new array setting values to one. zeros : Return a new array setting values to zero. full : Return a new array of given shape filled with value.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p><code>empty</code>, unlike <code>zeros</code>, does not set the array values to zero, and may therefore be marginally faster. On the other hand, it requires the user to manually set all the values in the array, and should be used with caution.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.empty([2, 2]) array(<a href="null"> -9.74499359e+001,   6.69583040e-309],
       [  2.13182611e-314,   3.06959433e-309</a>) #uninitialized</p>
      <p>np.empty([2, 2], dtype=int) array(<a href="null">-1073741821, -1067949133],
       [  496041986,    19249760</a>) #uninitialized</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L18292">view source</a></div></div><div class="public anchor" id="var-empty_like"><h3>empty_like</h3><div class="usage"><code>(empty_like &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>empty_like(prototype, dtype=None, order=K, subok=True, shape=None)</p>
<p>Return a new array with the same shape and type as a given array.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>prototype : array_like  The shape and data-type of <code>prototype</code> define these same attributes  of the returned array. dtype : data-type, optional  Overrides the data type of the result.</p>
<pre><code>.. versionadded:: 1.6.0
</code></pre>
<p>order : {C, F, A, or K}, optional  Overrides the memory layout of the result. C means C-order,  F means F-order, A means F if <code>prototype</code> is Fortran  contiguous, C otherwise. K means match the layout of <code>prototype</code>  as closely as possible.</p>
<pre><code>.. versionadded:: 1.6.0
</code></pre>
<p>subok : bool, optional.  If True, then the newly created array will use the sub-class  type of a, otherwise it will be a base-class array. Defaults  to True. shape : int or sequence of ints, optional.  Overrides the shape of the result. If order=K and the number of  dimensions is unchanged, will try to keep order, otherwise,  order=C is implied.</p>
<pre><code>.. versionadded:: 1.17.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  Array of uninitialized (arbitrary) data with the same  shape and type as <code>prototype</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>ones_like : Return an array of ones with shape and type of input. zeros_like : Return an array of zeros with shape and type of input. full_like : Return a new array with shape of input filled with value. empty : Return a new uninitialized array.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>This function does <em>not</em> initialize the returned array; to do that use <code>zeros_like</code> or <code>ones_like</code> instead. It may be marginally faster than the functions that do set the array values.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = ([1,2,3], [4,5,6]) # a is array-like np.empty_like(a) array(<a href="null">-1073741821, -1073741821,           3],    # uninitialized
       [          0,           0, -1073741821</a>) a = np.array(<a href="null">1., 2., 3.],[4.,5.,6.</a>) np.empty_like(a) array(<a href="null"> -2.00000715e+000,   1.48219694e-323,  -2.00000572e+000], # uninitialized
       [  4.38791518e-305,  -2.00000715e+000,   4.17269252e-309</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L17329">view source</a></div></div><div class="public anchor" id="var-equal"><h3>equal</h3><div class="usage"><code>(equal self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>equal(x1, x2, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Return (x1 == x2) element-wise.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x1, x2 : array_like  Input arrays. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output). out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray or scalar  Output array, element-wise comparison of <code>x1</code> and <code>x2</code>.  Typically of type bool, unless <code>dtype=object</code> is passed.  This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>not_equal, greater_equal, less_equal, greater, less</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.equal([0, 1, 3], np.arange(3)) array([ True, True, False])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>What is compared are values, not types. So an int (1) and an array of length one can evaluate as True:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.equal(1, np.ones(1)) array([ True])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L24585">view source</a></div></div><div class="public anchor" id="var-ERR_CALL"><h3>ERR_CALL</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L2424">view source</a></div></div><div class="public anchor" id="var-ERR_DEFAULT"><h3>ERR_DEFAULT</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L13201">view source</a></div></div><div class="public anchor" id="var-ERR_IGNORE"><h3>ERR_IGNORE</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L17197">view source</a></div></div><div class="public anchor" id="var-ERR_LOG"><h3>ERR_LOG</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L20435">view source</a></div></div><div class="public anchor" id="var-ERR_PRINT"><h3>ERR_PRINT</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L28800">view source</a></div></div><div class="public anchor" id="var-ERR_RAISE"><h3>ERR_RAISE</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L8949">view source</a></div></div><div class="public anchor" id="var-ERR_WARN"><h3>ERR_WARN</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L14367">view source</a></div></div><div class="public anchor" id="var-errstate"><h3>errstate</h3><div class="usage"><code>(errstate self &amp; [{:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>errstate(**kwargs)</p>
<p>Context manager for floating-point error handling.</p>
<p>Using an instance of <code>errstate</code> as a context manager allows statements in that context to execute with a known error handling behavior. Upon entering the context the error handling is set with <code>seterr</code> and <code>seterrcall</code>, and upon exiting it is reset to what it was before.</p>
<p>.. versionchanged:: 1.17.0  <code>errstate</code> is also usable as a function decorator, saving  a level of indentation if an entire function is wrapped.  See :py:class:<code>contextlib.ContextDecorator</code> for more information.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>kwargs : {divide, over, under, invalid}  Keyword arguments. The valid keywords are the possible floating-point  exceptions. Each keyword should have a string value that defines the  treatment for the particular error. Possible values are  {ignore, warn, raise, call, print, log}.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>seterr, geterr, seterrcall, geterrcall</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>For complete documentation of the types of floating-point exceptions and treatment options, see <code>seterr</code>.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>from collections import OrderedDict olderr = np.seterr(all=ignore) # Set error handling to known state.</p>
      <p>np.arange(3) / 0. array([nan, inf, inf]) with np.errstate(divide=warn):  np.arange(3) / 0. array([nan, inf, inf])</p>
      <p>np.sqrt(-1) nan with np.errstate(invalid=raise):  np.sqrt(-1) Traceback (most recent call last):  File <stdin>, line 2, in <module> FloatingPointError: invalid value encountered in sqrt</module></stdin></p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Outside the context the error handling behavior has not changed:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>OrderedDict(sorted(np.geterr().items())) OrderedDict([(divide, ignore), (invalid, ignore), (over, ignore), (under, ignore)])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L10858">view source</a></div></div><div class="public anchor" id="var-euler_gamma"><h3>euler_gamma</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L25765">view source</a></div></div><div class="public anchor" id="var-exp"><h3>exp</h3><div class="usage"><code>(exp self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>exp(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Calculate the exponential of all elements in the input array.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Input values. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray or scalar  Output array, element-wise exponential of <code>x</code>.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>expm1 : Calculate <code>exp(x) - 1</code> for all elements in the array. exp2 : Calculate <code>2**x</code> for all elements in the array.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The irrational number <code>e</code> is also known as Eulers number. It is approximately 2.718281, and is the base of the natural logarithm, <code>ln</code> (this means that, if :math:<code>x = \ln y = \log_e y</code>, then :math:<code>e^x = y</code>. For real input, <code>exp(x)</code> is always positive.</p>
<p>For complex arguments, <code>x = a + ib</code>, we can write :math:<code>e^x = e^a e^{ib}</code>. The first term, :math:<code>e^a</code>, is already known (it is the real argument, described above). The second term, :math:<code>e^{ib}</code>, is :math:<code>\cos b + i \sin b</code>, a function with magnitude 1 and a periodic phase.</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [1] Wikipedia, Exponential function,  <a href="https://en.wikipedia.org/wiki/Exponential_function">https://en.wikipedia.org/wiki/Exponential_function</a> .. [2] M. Abramovitz and I. A. Stegun, Handbook of Mathematical Functions  with Formulas, Graphs, and Mathematical Tables, Dover, 1964, p. 69,  <a href="http://www.math.sfu.ca/~cbm/aands/page_69.htm">http://www.math.sfu.ca/~cbm/aands/page_69.htm</a></p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>Plot the magnitude and phase of <code>exp(x)</code> in the complex plane:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>import matplotlib.pyplot as plt</p>
      <p>x = np.linspace(-2*np.pi, 2*np.pi, 100) xx = x + 1j * x[:, np.newaxis] # a + ib over complex plane out = np.exp(xx)</p>
      <p>plt.subplot(121) plt.imshow(np.abs(out),  extent=[-2*np.pi, 2*np.pi, -2*np.pi, 2*np.pi], cmap=gray) plt.title(Magnitude of exp(x))</p>
      <p>plt.subplot(122) plt.imshow(np.angle(out),  extent=[-2*np.pi, 2*np.pi, -2*np.pi, 2*np.pi], cmap=hsv) plt.title(Phase (angle) of exp(x)) plt.show()</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L16468">view source</a></div></div><div class="public anchor" id="var-exp2"><h3>exp2</h3><div class="usage"><code>(exp2 self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>exp2(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Calculate <code>2**p</code> for all <code>p</code> in the input array.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Input values. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray or scalar  Element-wise 2 to the power <code>x</code>.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>power</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>.. versionadded:: 1.3.0</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.exp2([2, 3]) array([ 4., 8.])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L22166">view source</a></div></div><div class="public anchor" id="var-expand_dims"><h3>expand_dims</h3><div class="usage"><code>(expand_dims &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Expand the shape of an array.</p>
<p>Insert a new axis that will appear at the <code>axis</code> position in the expanded array shape.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input array. axis : int or tuple of ints  Position in the expanded axes where the new axis (or axes) is placed.</p>
<pre><code>.. deprecated:: 1.13.0
    Passing an axis where ``axis &gt; a.ndim`` will be treated as
    ``axis == a.ndim``, and passing ``axis &lt; -a.ndim - 1`` will
    be treated as ``axis == 0``. This behavior is deprecated.

.. versionchanged:: 1.18.0
    A tuple of axes is now supported.  Out of range axes as
    described above are now forbidden and raise an `AxisError`.
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>result : ndarray  View of <code>a</code> with the number of dimensions increased.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>squeeze : The inverse operation, removing singleton dimensions reshape : Insert, remove, and combine dimensions, and resize existing ones doc.indexing, atleast_1d, atleast_2d, atleast_3d</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.array([1, 2]) x.shape (2,)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The following is equivalent to <code>x[np.newaxis, :]</code> or <code>x[np.newaxis]</code>:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>y = np.expand_dims(x, axis=0) y array(<a href="null">1, 2</a>) y.shape (1, 2)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The following is equivalent to <code>x[:, np.newaxis]</code>:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>y = np.expand_dims(x, axis=1) y array(<a href="null">1],
       [2</a>) y.shape (2, 1)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p><code>axis</code> may also be a tuple:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>y = np.expand_dims(x, axis=(0, 1)) y array(<a href="null">[1, 2</a>])</p>
      <p>y = np.expand_dims(x, axis=(2, 0)) y array(<a href="null">[1],
        [2</a>])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Note that some examples may use <code>None</code> instead of <code>np.newaxis</code>. These are the same objects:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.newaxis is None True</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L26991">view source</a></div></div><div class="public anchor" id="var-expm1"><h3>expm1</h3><div class="usage"><code>(expm1 self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>expm1(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Calculate <code>exp(x) - 1</code> for all elements in the array.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Input values. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray or scalar  Element-wise exponential minus one: <code>out = exp(x) - 1</code>.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>log1p : <code>log(1 + x)</code>, the inverse of expm1.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>This function provides greater precision than <code>exp(x) - 1</code> for small values of <code>x</code>.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>The true value of <code>exp(1e-10) - 1</code> is <code>1.00000000005e-10</code> to about 32 significant digits. This example shows the superiority of expm1 in this case.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.expm1(1e-10) 1.00000000005e-10 np.exp(1e-10) - 1 1.000000082740371e-10</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L21080">view source</a></div></div><div class="public anchor" id="var-extract"><h3>extract</h3><div class="usage"><code>(extract &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return the elements of an array that satisfy some condition.</p>
<p>This is equivalent to <code>np.compress(ravel(condition), ravel(arr))</code>. If <code>condition</code> is boolean <code>np.extract</code> is equivalent to <code>arr[condition]</code>.</p>
<p>Note that <code>place</code> does the exact opposite of <code>extract</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>condition : array_like  An array whose nonzero or True entries indicate the elements of <code>arr</code>  to extract. arr : array_like  Input array of the same size as <code>condition</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>extract : ndarray  Rank 1 array of values from <code>arr</code> where <code>condition</code> is True.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>take, put, copyto, compress, place</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>arr = np.arange(12).reshape((3, 4)) arr array(<a href="null"> 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11</a>) condition = np.mod(arr, 3)==0 condition array(<a href="null"> True, False, False,  True],
       [False, False,  True, False],
       [False,  True, False, False</a>) np.extract(condition, arr) array([0, 3, 6, 9])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>If <code>condition</code> is boolean:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>arr[condition] array([0, 3, 6, 9])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L15957">view source</a></div></div><div class="public anchor" id="var-eye"><h3>eye</h3><div class="usage"><code>(eye N &amp; [{M :M, k :k, dtype :dtype, order :order}])</code><code>(eye N &amp; [{M :M, k :k, dtype :dtype}])</code><code>(eye N &amp; [{M :M, k :k}])</code><code>(eye N &amp; [{M :M}])</code><code>(eye N)</code></div><div class="doc"><div class="markdown"><p>Return a 2-D array with ones on the diagonal and zeros elsewhere.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>N : int  Number of rows in the output. M : int, optional  Number of columns in the output. If None, defaults to <code>N</code>. k : int, optional  Index of the diagonal: 0 (the default) refers to the main diagonal,  a positive value refers to an upper diagonal, and a negative value  to a lower diagonal. dtype : data-type, optional  Data-type of the returned array. order : {C, F}, optional  Whether the output should be stored in row-major (C-style) or  column-major (Fortran-style) order in memory.</p>
<pre><code>.. versionadded:: 1.14.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>I : ndarray of shape (N,M)  An array where all elements are equal to zero, except for the <code>k</code>-th  diagonal, whose values are equal to one.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>identity : (almost) equivalent function diag : diagonal 2-D array from a 1-D array specified by the user.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.eye(2, dtype=int) array(<a href="null">1, 0],
       [0, 1</a>) np.eye(3, k=1) array(<a href="null">0.,  1.,  0.],
       [0.,  0.,  1.],
       [0.,  0.,  0.</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L16964">view source</a></div></div><div class="public anchor" id="var-fabs"><h3>fabs</h3><div class="usage"><code>(fabs self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>fabs(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Compute the absolute values element-wise.</p>
<p>This function returns the absolute values (positive magnitude) of the data in <code>x</code>. Complex values are not handled, use <code>absolute</code> to find the absolute values of complex data.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  The array of numbers for which the absolute values are required. If  <code>x</code> is a scalar, the result <code>y</code> will also be a scalar. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray or scalar  The absolute values of <code>x</code>, the returned values are always floats.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>absolute : Absolute values including <code>complex</code> types.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.fabs(-1) 1.0 np.fabs([-1.2, 1.2]) array([ 1.2, 1.2])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L14867">view source</a></div></div><div class="public anchor" id="var-fastCopyAndTranspose"><h3>fastCopyAndTranspose</h3><div class="usage"><code>(fastCopyAndTranspose self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>_fastCopyAndTranspose(a)</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L22354">view source</a></div></div><div class="public anchor" id="var-fft"><h3>fft</h3><div class="usage"></div><div class="doc"><div class="markdown"><h1><a href="#discrete-fourier-transform-mod-" name="discrete-fourier-transform-mod-"></a>Discrete Fourier Transform (:mod:<code>numpy.fft</code>)</h1>
<p>.. currentmodule:: numpy.fft</p>
<h2><a href="#standard-ffts" name="standard-ffts"></a>Standard FFTs</h2>
<p>.. autosummary::  :toctree: generated/</p>
<p>fft Discrete Fourier transform.  ifft Inverse discrete Fourier transform.  fft2 Discrete Fourier transform in two dimensions.  ifft2 Inverse discrete Fourier transform in two dimensions.  fftn Discrete Fourier transform in N-dimensions.  ifftn Inverse discrete Fourier transform in N dimensions.</p>
<h2><a href="#real-ffts" name="real-ffts"></a>Real FFTs</h2>
<p>.. autosummary::  :toctree: generated/</p>
<p>rfft Real discrete Fourier transform.  irfft Inverse real discrete Fourier transform.  rfft2 Real discrete Fourier transform in two dimensions.  irfft2 Inverse real discrete Fourier transform in two dimensions.  rfftn Real discrete Fourier transform in N dimensions.  irfftn Inverse real discrete Fourier transform in N dimensions.</p>
<h2><a href="#hermitian-ffts" name="hermitian-ffts"></a>Hermitian FFTs</h2>
<p>.. autosummary::  :toctree: generated/</p>
<p>hfft Hermitian discrete Fourier transform.  ihfft Inverse Hermitian discrete Fourier transform.</p>
<h2><a href="#helper-routines" name="helper-routines"></a>Helper routines</h2>
<p>.. autosummary::  :toctree: generated/</p>
<p>fftfreq Discrete Fourier Transform sample frequencies.  rfftfreq DFT sample frequencies (for usage with rfft, irfft).  fftshift Shift zero-frequency component to center of spectrum.  ifftshift Inverse of fftshift.</p>
<h2><a href="#background-information" name="background-information"></a>Background information</h2>
<p>Fourier analysis is fundamentally a method for expressing a function as a sum of periodic components, and for recovering the function from those components. When both the function and its Fourier transform are replaced with discretized counterparts, it is called the discrete Fourier transform (DFT). The DFT has become a mainstay of numerical computing in part because of a very fast algorithm for computing it, called the Fast Fourier Transform (FFT), which was known to Gauss (1805) and was brought to light in its current form by Cooley and Tukey [CT]_. Press et al. [NR]_ provide an accessible introduction to Fourier analysis and its applications.</p>
<p>Because the discrete Fourier transform separates its input into components that contribute at discrete frequencies, it has a great number of applications in digital signal processing, e.g., for filtering, and in this context the discretized input to the transform is customarily referred to as a <em>signal</em>, which exists in the <em>time domain</em>. The output is called a <em>spectrum</em> or <em>transform</em> and exists in the <em>frequency domain</em>.</p>
<h2><a href="#implementation-details" name="implementation-details"></a>Implementation details</h2>
<p>There are many ways to define the DFT, varying in the sign of the exponent, normalization, etc. In this implementation, the DFT is defined as</p>
<p>.. math::  A_k = \sum_{m=0}^{n-1} a_m \exp\left{-2\pi i{mk \over n}\right}  \qquad k = 0,\ldots,n-1.</p>
<p>The DFT is in general defined for complex inputs and outputs, and a single-frequency component at linear frequency :math:<code>f</code> is represented by a complex exponential :math:<code>a_m = \exp\{2\pi i\,f m\Delta t\}</code>, where :math:<code>\Delta t</code> is the sampling interval.</p>
<p>The values in the result follow so-called standard order: If <code>A =
fft(a, n)</code>, then <code>A[0]</code> contains the zero-frequency term (the sum of the signal), which is always purely real for real inputs. Then <code>A[1:n/2]</code> contains the positive-frequency terms, and <code>A[n/2+1:]</code> contains the negative-frequency terms, in order of decreasingly negative frequency. For an even number of input points, <code>A[n/2]</code> represents both positive and negative Nyquist frequency, and is also purely real for real input. For an odd number of input points, <code>A[(n-1)/2]</code> contains the largest positive frequency, while <code>A[(n+1)/2]</code> contains the largest negative frequency. The routine <code>np.fft.fftfreq(n)</code> returns an array giving the frequencies of corresponding elements in the output. The routine <code>np.fft.fftshift(A)</code> shifts transforms and their frequencies to put the zero-frequency components in the middle, and <code>np.fft.ifftshift(A)</code> undoes that shift.</p>
<p>When the input <code>a</code> is a time-domain signal and <code>A = fft(a)</code>, <code>np.abs(A)</code> is its amplitude spectrum and <code>np.abs(A)**2</code> is its power spectrum. The phase spectrum is obtained by <code>np.angle(A)</code>.</p>
<p>The inverse DFT is defined as</p>
<p>.. math::  a_m = \frac{1}{n}\sum_{k=0}^{n-1}A_k\exp\left{2\pi i{mk\over n}\right}  \qquad m = 0,\ldots,n-1.</p>
<p>It differs from the forward transform by the sign of the exponential argument and the default normalization by :math:<code>1/n</code>.</p>
<h2><a href="#type-promotion" name="type-promotion"></a>Type Promotion</h2>
<p><code>numpy.fft</code> promotes <code>float32</code> and <code>complex64</code> arrays to <code>float64</code> and <code>complex128</code> arrays respectively. For an FFT implementation that does not promote input arrays, see <code>scipy.fftpack</code>.</p>
<h2><a href="#normalization" name="normalization"></a>Normalization</h2>
<p>The default normalization has the direct transforms unscaled and the inverse transforms are scaled by :math:<code>1/n</code>. It is possible to obtain unitary transforms by setting the keyword argument <code>norm</code> to <code>"ortho"</code> (default is <code>None</code>) so that both direct and inverse transforms will be scaled by :math:<code>1/\sqrt{n}</code>.</p>
<h2><a href="#real-and-hermitian-transforms" name="real-and-hermitian-transforms"></a>Real and Hermitian transforms</h2>
<p>When the input is purely real, its transform is Hermitian, i.e., the component at frequency :math:<code>f_k</code> is the complex conjugate of the component at frequency :math:<code>-f_k</code>, which means that for real inputs there is no information in the negative frequency components that is not already available from the positive frequency components. The family of <code>rfft</code> functions is designed to operate on real inputs, and exploits this symmetry by computing only the positive frequency components, up to and including the Nyquist frequency. Thus, <code>n</code> input points produce <code>n/2+1</code> complex output points. The inverses of this family assumes the same symmetry of its input, and for an output of <code>n</code> points uses <code>n/2+1</code> input points.</p>
<p>Correspondingly, when the spectrum is purely real, the signal is Hermitian. The <code>hfft</code> family of functions exploits this symmetry by using <code>n/2+1</code> complex points in the input (time) domain for <code>n</code> real points in the frequency domain.</p>
<p>In higher dimensions, FFTs are used, e.g., for image analysis and filtering. The computational efficiency of the FFT means that it can also be a faster way to compute large convolutions, using the property that a convolution in the time domain is equivalent to a point-by-point multiplication in the frequency domain.</p>
<h2><a href="#higher-dimensions" name="higher-dimensions"></a>Higher dimensions</h2>
<p>In two dimensions, the DFT is defined as</p>
<p>.. math::  A_{kl} = \sum_{m=0}^{M-1} \sum_{n=0}^{N-1}  a_{mn}\exp\left{-2\pi i \left({mk\over M}+{nl\over N}\right)\right}  \qquad k = 0, \ldots, M-1;\quad l = 0, \ldots, N-1,</p>
<p>which extends in the obvious way to higher dimensions, and the inverses in higher dimensions also extend in the same way.</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [CT] Cooley, James W., and John W. Tukey, 1965, An algorithm for the  machine calculation of complex Fourier series, <em>Math. Comput.</em>  19: 297-301.</p>
<p>.. [NR] Press, W., Teukolsky, S., Vetterline, W.T., and Flannery, B.P.,  2007, <em>Numerical Recipes: The Art of Scientific Computing</em>, ch.  12-13. Cambridge Univ. Press, Cambridge, UK.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>For examples, see the various functions.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L25971">view source</a></div></div><div class="public anchor" id="var-fill_diagonal"><h3>fill_diagonal</h3><div class="usage"><code>(fill_diagonal &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Fill the main diagonal of the given array of any dimensionality.</p>
<p>For an array <code>a</code> with <code>a.ndim &gt;= 2</code>, the diagonal is the list of locations with indices <code>a[i, ..., i]</code> all identical. This function modifies the input array in-place, it does not return a value.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array, at least 2-D.  Array whose diagonal is to be filled, it gets modified in-place.</p>
<p>val : scalar  Value to be written on the diagonal, its type must be compatible with  that of the array a.</p>
<p>wrap : bool  For tall matrices in NumPy version up to 1.6.2, the  diagonal wrapped after N columns. You can have this behavior  with this option. This affects only tall matrices.</p>
<h2><a href="#see-also" name="see-also"></a>See also</h2>
<p>diag_indices, diag_indices_from</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>.. versionadded:: 1.4.0</p>
<p>This functionality can be obtained via <code>diag_indices</code>, but internally this version uses a much faster implementation that never constructs the indices and uses simple slicing.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.zeros((3, 3), int) np.fill_diagonal(a, 5) a array(<a href="null">5, 0, 0],
       [0, 5, 0],
       [0, 0, 5</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The same function can operate on a 4-D array:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.zeros((3, 3, 3, 3), int) np.fill_diagonal(a, 4)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>We only show a few blocks for clarity:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a[0, 0] array(<a href="null">4, 0, 0],
       [0, 0, 0],
       [0, 0, 0</a>) a[1, 1] array(<a href="null">0, 0, 0],
       [0, 4, 0],
       [0, 0, 0</a>) a[2, 2] array(<a href="null">0, 0, 0],
       [0, 0, 0],
       [0, 0, 4</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The wrap option affects only tall matrices:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <h1><a href="#tall-matrices-no-wrap" name="tall-matrices-no-wrap"></a>tall matrices no wrap</h1>
      <p>a = np.zeros((5, 3), int) np.fill_diagonal(a, 4) a array(<a href="null">4, 0, 0],
       [0, 4, 0],
       [0, 0, 4],
       [0, 0, 0],
       [0, 0, 0</a>)</p>
      <h1><a href="#tall-matrices-wrap" name="tall-matrices-wrap"></a>tall matrices wrap</h1>
      <p>a = np.zeros((5, 3), int) np.fill_diagonal(a, 4, wrap=True) a array(<a href="null">4, 0, 0],
       [0, 4, 0],
       [0, 0, 4],
       [0, 0, 0],
       [4, 0, 0</a>)</p>
      <h1><a href="#wide-matrices" name="wide-matrices"></a>wide matrices</h1>
      <p>a = np.zeros((3, 5), int) np.fill_diagonal(a, 4, wrap=True) a array(<a href="null">4, 0, 0, 0, 0],
       [0, 4, 0, 0, 0],
       [0, 0, 4, 0, 0</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The anti-diagonal can be filled by reversing the order of elements using either <code>numpy.flipud</code> or <code>numpy.fliplr</code>.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.zeros((3, 3), int); np.fill_diagonal(np.fliplr(a), [1,2,3]) # Horizontal flip a array(<a href="null">0, 0, 1],
       [0, 2, 0],
       [3, 0, 0</a>) np.fill_diagonal(np.flipud(a), [1,2,3]) # Vertical flip a array(<a href="null">0, 0, 3],
       [0, 2, 0],
       [1, 0, 0</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Note that the order in which the diagonal is filled varies depending on the flip function.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L19631">view source</a></div></div><div class="public anchor" id="var-find_common_type"><h3>find_common_type</h3><div class="usage"><code>(find_common_type array_types scalar_types)</code></div><div class="doc"><div class="markdown"><p>Determine common type following standard coercion rules.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>array_types : sequence  A list of dtypes or dtype convertible objects representing arrays. scalar_types : sequence  A list of dtypes or dtype convertible objects representing scalars.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>datatype : dtype  The common data type, which is the maximum of <code>array_types</code> ignoring  <code>scalar_types</code>, unless the maximum of <code>scalar_types</code> is of a  different kind (<code>dtype.kind</code>). If the kind is not understood, then  None is returned.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>dtype, common_type, can_cast, mintypecode</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.find_common_type([], [np.int64, np.float32, complex]) dtype(complex128) np.find_common_type([np.int64, np.float32], []) dtype(float64)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The standard casting rules ensure that a scalar cannot up-cast an array unless the scalar is of a fundamentally different kind of data (i.e. under a different hierarchy in the data type hierarchy) then the array:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.find_common_type([np.float32], [np.int64, np.float64]) dtype(float32)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Complex is of a different type, so it up-casts the float in the <code>array_types</code> argument:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.find_common_type([np.float32], [complex]) dtype(complex128)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Type specifier strings are convertible to dtypes and can therefore be used instead of dtypes:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.find_common_type([f4, f4, i4], [c8]) dtype(complex128)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L4018">view source</a></div></div><div class="public anchor" id="var-finfo"><h3>finfo</h3><div class="usage"><code>(finfo self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>finfo(dtype)</p>
<p>Machine limits for floating point types.</p>
<h2><a href="#attributes" name="attributes"></a>Attributes</h2>
<p>bits : int  The number of bits occupied by the type. eps : float  The smallest representable positive number such that  <code>1.0 + eps != 1.0</code>. Type of <code>eps</code> is an appropriate floating  point type. epsneg : floating point number of the appropriate type  The smallest representable positive number such that  <code>1.0 - epsneg != 1.0</code>. iexp : int  The number of bits in the exponent portion of the floating point  representation. machar : MachAr  The object which calculated these parameters and holds more  detailed information. machep : int  The exponent that yields <code>eps</code>. max : floating point number of the appropriate type  The largest representable number. maxexp : int  The smallest positive power of the base (2) that causes overflow. min : floating point number of the appropriate type  The smallest representable number, typically <code>-max</code>. minexp : int  The most negative power of the base (2) consistent with there  being no leading 0s in the mantissa. negep : int  The exponent that yields <code>epsneg</code>. nexp : int  The number of bits in the exponent including its sign and bias. nmant : int  The number of bits in the mantissa. precision : int  The approximate number of decimal digits to which this kind of  float is precise. resolution : floating point number of the appropriate type  The approximate decimal resolution of this type, i.e.,  <code>10**-precision</code>. tiny : float  The smallest positive usable number. Type of <code>tiny</code> is an  appropriate floating point type.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>dtype : float, dtype, or instance  Kind of floating point data-type about which to get information.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>MachAr : The implementation of the tests that produce this information. iinfo : The equivalent for integer data types.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>For developers of NumPy: do not instantiate this at the module level. The initial calculation of these parameters is expensive and negatively impacts import times. These objects are cached, so calling <code>finfo()</code> repeatedly inside your functions is not a problem.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L26164">view source</a></div></div><div class="public anchor" id="var-fix"><h3>fix</h3><div class="usage"><code>(fix &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Round to nearest integer towards zero.</p>
<p>Round an array of floats element-wise to nearest integer towards zero. The rounded values are returned as floats.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  An array of floats to be rounded y : ndarray, optional  Output array</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray of floats  The array of rounded numbers</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>trunc, floor, ceil around : Round to given number of decimals</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.fix(3.14) 3.0 np.fix(3) 3.0 np.fix([2.1, 2.9, -2.1, -2.9]) array([ 2., 2., -2., -2.])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L3545">view source</a></div></div><div class="public anchor" id="var-flatiter"><h3>flatiter</h3><div class="usage"><code>(flatiter self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Flat iterator object to iterate over arrays.</p>
<p>A <code>flatiter</code> iterator is returned by <code>x.flat</code> for any array <code>x</code>. It allows iterating over the array as if it were a 1-D array, either in a for-loop or by calling its <code>next</code> method.</p>
<p>Iteration is done in row-major, C-style order (the last index varying the fastest). The iterator can also be indexed using basic slicing or advanced indexing.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>ndarray.flat : Return a flat iterator over an array. ndarray.flatten : Returns a flattened copy of an array.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>A <code>flatiter</code> iterator can not be constructed directly from Python code by calling the <code>flatiter</code> constructor.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.arange(6).reshape(2, 3) fl = x.flat type(fl) &lt;class numpy.flatiter&gt; for item in fl:  print(item)  0 1 2 3 4 5</p>
      <p>fl[2:4] array([2, 3])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L9493">view source</a></div></div><div class="public anchor" id="var-flatnonzero"><h3>flatnonzero</h3><div class="usage"><code>(flatnonzero &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return indices that are non-zero in the flattened version of a.</p>
<p>This is equivalent to np.nonzero(np.ravel(a))[0].</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input data.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>res : ndarray  Output array, containing the indices of the elements of <code>a.ravel()</code>  that are non-zero.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>nonzero : Return the indices of the non-zero elements of the input array. ravel : Return a 1-D array containing the elements of the input array.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.arange(-2, 3) x array([-2, -1, 0, 1, 2]) np.flatnonzero(x) array([0, 1, 3, 4])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Use the indices of the non-zero elements as an index array to extract these elements:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x.ravel()[np.flatnonzero(x)] array([-2, -1, 1, 2])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L819">view source</a></div></div><div class="public anchor" id="var-flexible"><h3>flexible</h3><div class="usage"><code>(flexible self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Abstract base class of all scalar types without predefined length. The actual size of these types depends on the specific <code>np.dtype</code> instantiation.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L353">view source</a></div></div><div class="public anchor" id="var-flip"><h3>flip</h3><div class="usage"><code>(flip &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Reverse the order of elements in an array along the given axis.</p>
<p>The shape of the array is preserved, but the elements are reordered.</p>
<p>.. versionadded:: 1.12.0</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>m : array_like  Input array. axis : None or int or tuple of ints, optional  Axis or axes along which to flip over. The default,  axis=None, will flip over all of the axes of the input array.  If axis is negative it counts from the last to the first axis.</p>
<pre><code> If axis is a tuple of ints, flipping is performed on all of the axes
 specified in the tuple.

 .. versionchanged:: 1.15.0
    None and tuples of axes are supported
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : array_like  A view of <code>m</code> with the entries of axis reversed. Since a view is  returned, this operation is done in constant time.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>flipud : Flip an array vertically (axis=0). fliplr : Flip an array horizontally (axis=1).</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>flip(m, 0) is equivalent to flipud(m).</p>
<p>flip(m, 1) is equivalent to fliplr(m).</p>
<p>flip(m, n) corresponds to <code>m[...,::-1,...]</code> with <code>::-1</code> at position n.</p>
<p>flip(m) corresponds to <code>m[::-1,::-1,...,::-1]</code> with <code>::-1</code> at all positions.</p>
<p>flip(m, (0, 1)) corresponds to <code>m[::-1,::-1,...]</code> with <code>::-1</code> at position 0 and position 1.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>A = np.arange(8).reshape((2,2,2)) A array(<a href="null">[0, 1],
        [2, 3</a>,  <a href="null">4, 5],
        [6, 7</a>]) np.flip(A, 0) array(<a href="null">[4, 5],
        [6, 7</a>,  <a href="null">0, 1],
        [2, 3</a>]) np.flip(A, 1) array(<a href="null">[2, 3],
        [0, 1</a>,  <a href="null">6, 7],
        [4, 5</a>]) np.flip(A) array(<a href="null">[7, 6],
        [5, 4</a>,  <a href="null">3, 2],
        [1, 0</a>]) np.flip(A, (0, 2)) array(<a href="null">[5, 4],
        [7, 6</a>,  <a href="null">1, 0],
        [3, 2</a>]) A = np.random.randn(3,4,5) np.all(np.flip(A,2) == A[:,:,::-1,]) True</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L11453">view source</a></div></div><div class="public anchor" id="var-fliplr"><h3>fliplr</h3><div class="usage"><code>(fliplr &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Flip array in the left/right direction.</p>
<p>Flip the entries in each row in the left/right direction. Columns are preserved, but appear in a different order than before.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>m : array_like  Input array, must be at least 2-D.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>f : ndarray  A view of <code>m</code> with the columns reversed. Since a view  is returned, this operation is :math:<code>\mathcal O(1)</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>flipud : Flip array in the up/down direction. rot90 : Rotate array counterclockwise.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Equivalent to m[:,::-1]. Requires the array to be at least 2-D.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>A = np.diag([1.,2.,3.]) A array(<a href="null">1.,  0.,  0.],
       [0.,  2.,  0.],
       [0.,  0.,  3.</a>) np.fliplr(A) array(<a href="null">0.,  0.,  1.],
       [0.,  2.,  0.],
       [3.,  0.,  0.</a>)</p>
      <p>A = np.random.randn(2,3,5) np.all(np.fliplr(A) == A[:,::-1,]) True</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L27067">view source</a></div></div><div class="public anchor" id="var-flipud"><h3>flipud</h3><div class="usage"><code>(flipud &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Flip array in the up/down direction.</p>
<p>Flip the entries in each column in the up/down direction. Rows are preserved, but appear in a different order than before.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>m : array_like  Input array.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : array_like  A view of <code>m</code> with the rows reversed. Since a view is  returned, this operation is :math:<code>\mathcal O(1)</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>fliplr : Flip array in the left/right direction. rot90 : Rotate array counterclockwise.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Equivalent to <code>m[::-1,...]</code>. Does not require the array to be two-dimensional.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>A = np.diag([1.0, 2, 3]) A array(<a href="null">1.,  0.,  0.],
       [0.,  2.,  0.],
       [0.,  0.,  3.</a>) np.flipud(A) array(<a href="null">0.,  0.,  3.],
       [0.,  2.,  0.],
       [1.,  0.,  0.</a>)</p>
      <p>A = np.random.randn(2,3,5) np.all(np.flipud(A) == A[::-1,]) True</p>
      <p>np.flipud([1,2]) array([2, 1])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L14719">view source</a></div></div><div class="public anchor" id="var-float"><h3>float</h3><div class="usage"><code>(float self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Convert a string or number to a floating point number, if possible.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L79">view source</a></div></div><div class="public anchor" id="var-float128"><h3>float128</h3><div class="usage"><code>(float128 self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Extended-precision floating-point number type, compatible with C <code>long double</code> but not necessarily with IEEE 754 quadruple-precision. Character code: <code>'g'</code>. Canonical name: <code>np.longdouble</code>. Alias: <code>np.longfloat</code>. Alias <em>on this platform</em>: <code>np.float128</code>: 128-bit extended-precision floating-point number type.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L12586">view source</a></div></div><div class="public anchor" id="var-float16"><h3>float16</h3><div class="usage"><code>(float16 self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Half-precision floating-point number type. Character code: <code>'e'</code>. Canonical name: <code>np.half</code>. Alias <em>on this platform</em>: <code>np.float16</code>: 16-bit-precision floating-point number type: sign bit, 5 bits exponent, 10 bits mantissa.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L15803">view source</a></div></div><div class="public anchor" id="var-float32"><h3>float32</h3><div class="usage"><code>(float32 self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Single-precision floating-point number type, compatible with C <code>float</code>. Character code: <code>'f'</code>. Canonical name: <code>np.single</code>. Alias <em>on this platform</em>: <code>np.float32</code>: 32-bit-precision floating-point number type: sign bit, 8 bits exponent, 23 bits mantissa.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L3790">view source</a></div></div><div class="public anchor" id="var-float64"><h3>float64</h3><div class="usage"><code>(float64 self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Double-precision floating-point number type, compatible with Python <code>float</code> and C <code>double</code>. Character code: <code>'d'</code>. Canonical name: <code>np.double</code>. Alias: <code>np.float_</code>. Alias <em>on this platform</em>: <code>np.float64</code>: 64-bit precision floating-point number type: sign bit, 11 bits exponent, 52 bits mantissa.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L5102">view source</a></div></div><div class="public anchor" id="var-float_"><h3>float_</h3><div class="usage"><code>(float_ self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Double-precision floating-point number type, compatible with Python <code>float</code> and C <code>double</code>. Character code: <code>'d'</code>. Canonical name: <code>np.double</code>. Alias: <code>np.float_</code>. Alias <em>on this platform</em>: <code>np.float64</code>: 64-bit precision floating-point number type: sign bit, 11 bits exponent, 52 bits mantissa.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L2536">view source</a></div></div><div class="public anchor" id="var-float_power"><h3>float_power</h3><div class="usage"><code>(float_power self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>float_power(x1, x2, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>First array elements raised to powers from second array, element-wise.</p>
<p>Raise each base in <code>x1</code> to the positionally-corresponding power in <code>x2</code>. <code>x1</code> and <code>x2</code> must be broadcastable to the same shape. This differs from the power function in that integers, float16, and float32 are promoted to floats with a minimum precision of float64 so that the result is always inexact. The intent is that the function will return a usable result for negative powers and seldom overflow for positive powers.</p>
<p>.. versionadded:: 1.12.0</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x1 : array_like  The bases. x2 : array_like  The exponents. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output). out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray  The bases in <code>x1</code> raised to the exponents in <code>x2</code>.  This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>power : power function that preserves type</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>Cube each element in a list.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x1 = range(6) x1 [0, 1, 2, 3, 4, 5] np.float_power(x1, 3) array([ 0., 1., 8., 27., 64., 125.])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Raise the bases to different exponents.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x2 = [1.0, 2.0, 3.0, 3.0, 2.0, 1.0] np.float_power(x1, x2) array([ 0., 1., 8., 27., 16., 5.])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The effect of broadcasting.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x2 = np.array(<a href="null">1, 2, 3, 3, 2, 1], [1, 2, 3, 3, 2, 1</a>) x2 array(<a href="null">1, 2, 3, 3, 2, 1],
       [1, 2, 3, 3, 2, 1</a>) np.float_power(x1, x2) array(<a href="null">  0.,   1.,   8.,  27.,  16.,   5.],
       [  0.,   1.,   8.,  27.,  16.,   5.</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L23815">view source</a></div></div><div class="public anchor" id="var-floating"><h3>floating</h3><div class="usage"><code>(floating self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Abstract base class of all floating-point scalar types.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L13587">view source</a></div></div><div class="public anchor" id="var-FLOATING_POINT_SUPPORT"><h3>FLOATING_POINT_SUPPORT</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L6422">view source</a></div></div><div class="public anchor" id="var-floor"><h3>floor</h3><div class="usage"><code>(floor self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>floor(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Return the floor of the input, element-wise.</p>
<p>The floor of the scalar <code>x</code> is the largest integer <code>i</code>, such that <code>i &lt;= x</code>. It is often denoted as :math:<code>\lfloor x \rfloor</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Input data. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray or scalar  The floor of each element in <code>x</code>.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>ceil, trunc, rint</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Some spreadsheet programs calculate the floor-towards-zero, in other words <code>floor(-2.5) == -2</code>. NumPy instead uses the definition of <code>floor</code> where <code>floor(-2.5) == -3</code>.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0]) np.floor(a) array([-2., -2., -1., 0., 1., 1., 2.])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L386">view source</a></div></div><div class="public anchor" id="var-floor_divide"><h3>floor_divide</h3><div class="usage"><code>(floor_divide self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>floor_divide(x1, x2, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Return the largest integer smaller or equal to the division of the inputs. It is equivalent to the Python <code>//</code> operator and pairs with the Python <code>%</code> (<code>remainder</code>), function so that <code>a = a % b + b * (a // b)</code> up to roundoff.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x1 : array_like  Numerator. x2 : array_like  Denominator. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output). out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray  y = floor(<code>x1</code>/<code>x2</code>)  This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>remainder : Remainder complementary to floor_divide. divmod : Simultaneous floor division and remainder. divide : Standard division. floor : Round a number to the nearest integer toward minus infinity. ceil : Round a number to the nearest integer toward infinity.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.floor_divide(7,3) 2 np.floor_divide([1., 2., 3., 4.], 2.5) array([ 0., 0., 1., 1.])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L2226">view source</a></div></div><div class="public anchor" id="var-fmax"><h3>fmax</h3><div class="usage"><code>(fmax self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>fmax(x1, x2, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Element-wise maximum of array elements.</p>
<p>Compare two arrays and returns a new array containing the element-wise maxima. If one of the elements being compared is a NaN, then the non-nan element is returned. If both elements are NaNs then the first is returned. The latter distinction is important for complex NaNs, which are defined as at least one of the real or imaginary parts being a NaN. The net effect is that NaNs are ignored when possible.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x1, x2 : array_like  The arrays holding the elements to be compared. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output). out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray or scalar  The maximum of <code>x1</code> and <code>x2</code>, element-wise.  This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>fmin :  Element-wise minimum of two arrays, ignores NaNs. maximum :  Element-wise maximum of two arrays, propagates NaNs. amax :  The maximum value of an array along a given axis, propagates NaNs. nanmax :  The maximum value of an array along a given axis, ignores NaNs.</p>
<p>minimum, amin, nanmin</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>.. versionadded:: 1.3.0</p>
<p>The fmax is equivalent to <code>np.where(x1 &gt;= x2, x1, x2)</code> when neither x1 nor x2 are NaNs, but it is faster and does proper broadcasting.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.fmax([2, 3, 4], [1, 5, 2]) array([ 2., 5., 4.])</p>
      <p>np.fmax(np.eye(2), [0.5, 2]) array(<a href="null"> 1. ,  2. ],
       [ 0.5,  2. </a>)</p>
      <p>np.fmax([np.nan, 0, np.nan],[0, np.nan, np.nan]) array([ 0., 0., nan])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L17634">view source</a></div></div><div class="public anchor" id="var-fmin"><h3>fmin</h3><div class="usage"><code>(fmin self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>fmin(x1, x2, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Element-wise minimum of array elements.</p>
<p>Compare two arrays and returns a new array containing the element-wise minima. If one of the elements being compared is a NaN, then the non-nan element is returned. If both elements are NaNs then the first is returned. The latter distinction is important for complex NaNs, which are defined as at least one of the real or imaginary parts being a NaN. The net effect is that NaNs are ignored when possible.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x1, x2 : array_like  The arrays holding the elements to be compared. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output). out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray or scalar  The minimum of <code>x1</code> and <code>x2</code>, element-wise.  This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>fmax :  Element-wise maximum of two arrays, ignores NaNs. minimum :  Element-wise minimum of two arrays, propagates NaNs. amin :  The minimum value of an array along a given axis, propagates NaNs. nanmin :  The minimum value of an array along a given axis, ignores NaNs.</p>
<p>maximum, amax, nanmax</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>.. versionadded:: 1.3.0</p>
<p>The fmin is equivalent to <code>np.where(x1 &lt;= x2, x1, x2)</code> when neither x1 nor x2 are NaNs, but it is faster and does proper broadcasting.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.fmin([2, 3, 4], [1, 5, 2]) array([1, 3, 2])</p>
      <p>np.fmin(np.eye(2), [0.5, 2]) array(<a href="null"> 0.5,  0. ],
       [ 0. ,  1. </a>)</p>
      <p>np.fmin([np.nan, 0, np.nan],[0, np.nan, np.nan]) array([ 0., 0., nan])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L15282">view source</a></div></div><div class="public anchor" id="var-fmod"><h3>fmod</h3><div class="usage"><code>(fmod self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>fmod(x1, x2, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Return the element-wise remainder of division.</p>
<p>This is the NumPy implementation of the C library function fmod, the remainder has the same sign as the dividend <code>x1</code>. It is equivalent to the Matlab(TM) <code>rem</code> function and should not be confused with the Python modulus operator <code>x1 % x2</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x1 : array_like  Dividend. x2 : array_like  Divisor. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output). out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : array_like  The remainder of the division of <code>x1</code> by <code>x2</code>.  This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>remainder : Equivalent to the Python <code>%</code> operator. divide</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The result of the modulo operation for negative dividend and divisors is bound by conventions. For <code>fmod</code>, the sign of result is the sign of the dividend, while for <code>remainder</code> the sign of the result is the sign of the divisor. The <code>fmod</code> function is equivalent to the Matlab(TM) <code>rem</code> function.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.fmod([-3, -2, -1, 1, 2, 3], 2) array([-1, 0, -1, 1, 0, 1]) np.remainder([-3, -2, -1, 1, 2, 3], 2) array([1, 0, 1, 1, 0, 1])</p>
      <p>np.fmod([5, 3], [2, 2.]) array([ 1., 1.]) a = np.arange(-3, 3).reshape(3, 2) a array(<a href="null">-3, -2],
       [-1,  0],
       [ 1,  2</a>) np.fmod(a, [2,2]) array(<a href="null">-1,  0],
       [-1,  0],
       [ 1,  0</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L12072">view source</a></div></div><div class="public anchor" id="var-format_float_positional"><h3>format_float_positional</h3><div class="usage"><code>(format_float_positional x &amp; [{precision :precision, unique :unique, fractional :fractional, trim :trim, sign :sign, pad_left :pad_left, pad_right :pad_right}])</code><code>(format_float_positional x &amp; [{precision :precision, unique :unique, fractional :fractional, trim :trim, sign :sign, pad_left :pad_left}])</code><code>(format_float_positional x &amp; [{precision :precision, unique :unique, fractional :fractional, trim :trim, sign :sign}])</code><code>(format_float_positional x &amp; [{precision :precision, unique :unique, fractional :fractional, trim :trim}])</code><code>(format_float_positional x &amp; [{precision :precision, unique :unique, fractional :fractional}])</code><code>(format_float_positional x &amp; [{precision :precision, unique :unique}])</code><code>(format_float_positional x &amp; [{precision :precision}])</code><code>(format_float_positional x)</code></div><div class="doc"><div class="markdown"><p>Format a floating-point scalar as a decimal string in positional notation.</p>
<p>Provides control over rounding, trimming and padding. Uses and assumes IEEE unbiased rounding. Uses the Dragon4 algorithm.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : python float or numpy floating scalar  Value to format. precision : non-negative integer or None, optional  Maximum number of digits to print. May be None if <code>unique</code> is  <code>True</code>, but must be an integer if unique is <code>False</code>. unique : boolean, optional  If <code>True</code>, use a digit-generation strategy which gives the shortest  representation which uniquely identifies the floating-point number from  other values of the same type, by judicious rounding. If <code>precision</code>  was omitted, print out all necessary digits, otherwise digit generation  is cut off after <code>precision</code> digits and the remaining value is rounded.  If <code>False</code>, digits are generated as if printing an infinite-precision  value and stopping after <code>precision</code> digits, rounding the remaining  value. fractional : boolean, optional  If <code>True</code>, the cutoff of <code>precision</code> digits refers to the total number  of digits after the decimal point, including leading zeros.  If <code>False</code>, <code>precision</code> refers to the total number of significant  digits, before or after the decimal point, ignoring leading zeros. trim : one of k, ., 0, -, optional  Controls post-processing trimming of trailing digits, as follows:</p>
<pre><code>* 'k' : keep trailing zeros, keep decimal point (no trimming)
* '.' : trim all trailing zeros, leave decimal point
* '0' : trim all but the zero before the decimal point. Insert the
  zero if it is missing.
* '-' : trim trailing zeros and any trailing decimal point
</code></pre>
<p>sign : boolean, optional  Whether to show the sign for positive values. pad_left : non-negative integer, optional  Pad the left side of the string with whitespace until at least that  many characters are to the left of the decimal point. pad_right : non-negative integer, optional  Pad the right side of the string with whitespace until at least that  many characters are to the right of the decimal point.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>rep : string  The string representation of the floating point value</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>format_float_scientific</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.format_float_positional(np.float32(np.pi)) 3.1415927 np.format_float_positional(np.float16(np.pi)) 3.14 np.format_float_positional(np.float16(0.3)) 0.3 np.format_float_positional(np.float16(0.3), unique=False, precision=10) 0.3000488281</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L15352">view source</a></div></div><div class="public anchor" id="var-format_float_scientific"><h3>format_float_scientific</h3><div class="usage"><code>(format_float_scientific x &amp; [{precision :precision, unique :unique, trim :trim, sign :sign, pad_left :pad_left, exp_digits :exp_digits}])</code><code>(format_float_scientific x &amp; [{precision :precision, unique :unique, trim :trim, sign :sign, pad_left :pad_left}])</code><code>(format_float_scientific x &amp; [{precision :precision, unique :unique, trim :trim, sign :sign}])</code><code>(format_float_scientific x &amp; [{precision :precision, unique :unique, trim :trim}])</code><code>(format_float_scientific x &amp; [{precision :precision, unique :unique}])</code><code>(format_float_scientific x &amp; [{precision :precision}])</code><code>(format_float_scientific x)</code></div><div class="doc"><div class="markdown"><p>Format a floating-point scalar as a decimal string in scientific notation.</p>
<p>Provides control over rounding, trimming and padding. Uses and assumes IEEE unbiased rounding. Uses the Dragon4 algorithm.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : python float or numpy floating scalar  Value to format. precision : non-negative integer or None, optional  Maximum number of digits to print. May be None if <code>unique</code> is  <code>True</code>, but must be an integer if unique is <code>False</code>. unique : boolean, optional  If <code>True</code>, use a digit-generation strategy which gives the shortest  representation which uniquely identifies the floating-point number from  other values of the same type, by judicious rounding. If <code>precision</code>  was omitted, print all necessary digits, otherwise digit generation is  cut off after <code>precision</code> digits and the remaining value is rounded.  If <code>False</code>, digits are generated as if printing an infinite-precision  value and stopping after <code>precision</code> digits, rounding the remaining  value. trim : one of k, ., 0, -, optional  Controls post-processing trimming of trailing digits, as follows:</p>
<pre><code>* 'k' : keep trailing zeros, keep decimal point (no trimming)
* '.' : trim all trailing zeros, leave decimal point
* '0' : trim all but the zero before the decimal point. Insert the
  zero if it is missing.
* '-' : trim trailing zeros and any trailing decimal point
</code></pre>
<p>sign : boolean, optional  Whether to show the sign for positive values. pad_left : non-negative integer, optional  Pad the left side of the string with whitespace until at least that  many characters are to the left of the decimal point. exp_digits : non-negative integer, optional  Pad the exponent with zeros until it contains at least this many digits.  If omitted, the exponent will be at least 2 digits.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>rep : string  The string representation of the floating point value</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>format_float_positional</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.format_float_scientific(np.float32(np.pi)) 3.1415927e+00 s = np.float32(1.23e24) np.format_float_scientific(s, unique=False, precision=15) 1.230000071797338e+24 np.format_float_scientific(s, exp_digits=4) 1.23e+0024</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L18943">view source</a></div></div><div class="public anchor" id="var-format_parser"><h3>format_parser</h3><div class="usage"><code>(format_parser self formats names titles &amp; [{aligned :aligned, byteorder :byteorder}])</code><code>(format_parser self formats names titles &amp; [{aligned :aligned}])</code><code>(format_parser self formats names titles)</code></div><div class="doc"><div class="markdown"><p>Class to convert formats, names, titles description to a dtype.</p>
<p>After constructing the format_parser object, the dtype attribute is the converted data-type: <code>dtype = format_parser(formats, names, titles).dtype</code></p>
<h2><a href="#attributes" name="attributes"></a>Attributes</h2>
<p>dtype : dtype  The converted data-type.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>formats : str or list of str  The format description, either specified as a string with  comma-separated format descriptions in the form <code>'f8, i4, a5'</code>, or  a list of format description strings in the form  <code>['f8', 'i4', 'a5']</code>. names : str or list/tuple of str  The field names, either specified as a comma-separated string in the  form <code>'col1, col2, col3'</code>, or as a list or tuple of strings in the  form <code>['col1', 'col2', 'col3']</code>.  An empty list can be used, in that case default field names  (f0, f1, ) are used. titles : sequence  Sequence of title strings. An empty list can be used to leave titles  out. aligned : bool, optional  If True, align the fields by padding as the C-compiler would.  Default is False. byteorder : str, optional  If specified, all the fields will be changed to the  provided byte-order. Otherwise, the default byte-order is  used. For all available string specifiers, see <code>dtype.newbyteorder</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>dtype, typename, sctype2char</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.format_parser([&lt;f8, &lt;i4, &lt;a5], [col1, col2, col3],  [T1, T2, T3]).dtype dtype([((T1, col1), &lt;f8), ((T2, col2), &lt;i4), ((T3, col3), S5)])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p><code>names</code> and/or <code>titles</code> can be empty lists. If <code>titles</code> is an empty list, titles will simply not appear. If <code>names</code> is empty, default field names will be used.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.format_parser([f8, i4, a5], [col1, col2, col3],  []).dtype dtype([(col1, &lt;f8), (col2, &lt;i4), (col3, &lt;S5)]) np.format_parser([&lt;f8, &lt;i4, &lt;a5], [], []).dtype dtype([(f0, &lt;f8), (f1, &lt;i4), (f2, S5)])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L3678">view source</a></div></div><div class="public anchor" id="var-FPE_DIVIDEBYZERO"><h3>FPE_DIVIDEBYZERO</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L10118">view source</a></div></div><div class="public anchor" id="var-FPE_INVALID"><h3>FPE_INVALID</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L23619">view source</a></div></div><div class="public anchor" id="var-FPE_OVERFLOW"><h3>FPE_OVERFLOW</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L16804">view source</a></div></div><div class="public anchor" id="var-FPE_UNDERFLOW"><h3>FPE_UNDERFLOW</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L28964">view source</a></div></div><div class="public anchor" id="var-frexp"><h3>frexp</h3><div class="usage"><code>(frexp self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>frexp(x[, out1, out2], / [, out=(None, None)], *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Decompose the elements of x into mantissa and twos exponent.</p>
<p>Returns (<code>mantissa</code>, <code>exponent</code>), where `x = mantissa * 2**exponent``. The mantissa is lies in the open interval(-1, 1), while the twos exponent is a signed integer.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Array of numbers to be decomposed. out1 : ndarray, optional  Output array for the mantissa. Must have the same shape as <code>x</code>. out2 : ndarray, optional  Output array for the exponent. Must have the same shape as <code>x</code>. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>mantissa : ndarray  Floating values between -1 and 1.  This is a scalar if <code>x</code> is a scalar. exponent : ndarray  Integer exponents of 2.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>ldexp : Compute <code>y = x1 * 2**x2</code>, the inverse of <code>frexp</code>.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Complex dtypes are not supported, they will raise a TypeError.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.arange(9) y1, y2 = np.frexp(x) y1 array([ 0. , 0.5 , 0.5 , 0.75 , 0.5 , 0.625, 0.75 , 0.875,  0.5 ]) y2 array([0, 1, 2, 2, 3, 3, 3, 3, 4]) y1 * 2**y2 array([ 0., 1., 2., 3., 4., 5., 6., 7., 8.])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L6573">view source</a></div></div><div class="public anchor" id="var-frombuffer"><h3>frombuffer</h3><div class="usage"><code>(frombuffer self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>frombuffer(buffer, dtype=float, count=-1, offset=0)</p>
<p>Interpret a buffer as a 1-dimensional array.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>buffer : buffer_like  An object that exposes the buffer interface. dtype : data-type, optional  Data-type of the returned array; default: float. count : int, optional  Number of items to read. <code>-1</code> means all data in the buffer. offset : int, optional  Start reading the buffer from this offset (in bytes); default: 0.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>If the buffer has data that is not in machine byte-order, this should be specified as part of the data-type, e.g.::</p>
<p>&gt;&gt;&gt; dt = np.dtype(int)  &gt;&gt;&gt; dt = dt.newbyteorder(&gt;)  &gt;&gt;&gt; np.frombuffer(buf, dtype=dt) # doctest: +SKIP</p>
<p>The data of the resulting array will not be byteswapped, but will be interpreted correctly.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>s = bhello world np.frombuffer(s, dtype=S1, count=5, offset=6) array([bw, bo, br, bl, bd], dtype=|S1)</p>
      <p>np.frombuffer(b\x01\x02, dtype=np.uint8) array([1, 2], dtype=uint8) np.frombuffer(b\x01\x02\x03\x04\x05, dtype=np.uint8, count=3) array([1, 2, 3], dtype=uint8)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L9454">view source</a></div></div><div class="public anchor" id="var-fromfile"><h3>fromfile</h3><div class="usage"><code>(fromfile self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>fromfile(file, dtype=float, count=-1, sep=, offset=0)</p>
<p>Construct an array from data in a text or binary file.</p>
<p>A highly efficient way of reading binary data with a known data-type, as well as parsing simply formatted text files. Data written using the <code>tofile</code> method can be read using this function.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>file : file or str or Path  Open file object or filename.</p>
<pre><code>.. versionchanged:: 1.17.0
    `pathlib.Path` objects are now accepted.
</code></pre>
<p>dtype : data-type  Data type of the returned array.  For binary files, it is used to determine the size and byte-order  of the items in the file.  Most builtin numeric types are supported and extension types may be supported.</p>
<pre><code>.. versionadded:: 1.18.0
    Complex dtypes.
</code></pre>
<p>count : int  Number of items to read. <code>-1</code> means all items (i.e., the complete  file). sep : str  Separator between items if file is a text file.  Empty (") separator means the file should be treated as binary.  Spaces ( ") in the separator match zero or more whitespace characters.  A separator consisting only of spaces must match at least one  whitespace. offset : int  The offset (in bytes) from the files current position. Defaults to 0.  Only permitted for binary files.</p>
<pre><code>.. versionadded:: 1.17.0
</code></pre>
<h2><a href="#see-also" name="see-also"></a>See also</h2>
<p>load, save ndarray.tofile loadtxt : More flexible way of loading data from a text file.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Do not rely on the combination of <code>tofile</code> and <code>fromfile</code> for data storage, as the binary files generated are not platform independent. In particular, no byte-order or data-type information is saved. Data can be stored in the platform independent <code>.npy</code> format using <code>save</code> and <code>load</code> instead.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>Construct an ndarray:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>dt = np.dtype([(time, [(min, np.int64), (sec, np.int64)]),  (temp, float)]) x = np.zeros((1,), dtype=dt) x[time][min] = 10; x[temp] = 98.25 x array([((10, 0), 98.25)],  dtype=[(time, [(min, &lt;i8), (sec, &lt;i8)]), (temp, &lt;f8)])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Save the raw data to disk:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>import tempfile fname = tempfile.mkstemp()[1] x.tofile(fname)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Read the raw data from disk:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.fromfile(fname, dtype=dt) array([((10, 0), 98.25)],  dtype=[(time, [(min, &lt;i8), (sec, &lt;i8)]), (temp, &lt;f8)])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The recommended way to store and load data:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.save(fname, x) np.load(fname + .npy) array([((10, 0), 98.25)],  dtype=[(time, [(min, &lt;i8), (sec, &lt;i8)]), (temp, &lt;f8)])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L5925">view source</a></div></div><div class="public anchor" id="var-fromfunction"><h3>fromfunction</h3><div class="usage"><code>(fromfunction function shape &amp; [{:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Construct an array by executing a function over each coordinate.</p>
<p>The resulting array therefore has a value <code>fn(x, y, z)</code> at coordinate <code>(x, y, z)</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>function : callable  The function is called with N parameters, where N is the rank of  <code>shape</code>. Each parameter represents the coordinates of the array  varying along a specific axis. For example, if <code>shape</code>  were <code>(2, 2)</code>, then the parameters would be  <code>array([[0, 0], [1, 1]])</code> and <code>array([[0, 1], [0, 1]])</code> shape : (N,) tuple of ints  Shape of the output array, which also determines the shape of  the coordinate arrays passed to <code>function</code>. dtype : data-type, optional  Data-type of the coordinate arrays passed to <code>function</code>.  By default, <code>dtype</code> is float.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>fromfunction : any  The result of the call to <code>function</code> is passed back directly.  Therefore the shape of <code>fromfunction</code> is completely determined by  <code>function</code>. If <code>function</code> returns a scalar value, the shape of  <code>fromfunction</code> would not match the <code>shape</code> parameter.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>indices, meshgrid</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Keywords other than <code>dtype</code> are passed to <code>function</code>.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.fromfunction(lambda i, j: i == j, (3, 3), dtype=int) array(<a href="null"> True, False, False],
       [False,  True, False],
       [False, False,  True</a>)</p>
      <p>np.fromfunction(lambda i, j: i + j, (3, 3), dtype=int) array(<a href="null">0, 1, 2],
       [1, 2, 3],
       [2, 3, 4</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L13036">view source</a></div></div><div class="public anchor" id="var-fromiter"><h3>fromiter</h3><div class="usage"><code>(fromiter self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>fromiter(iterable, dtype, count=-1)</p>
<p>Create a new 1-dimensional array from an iterable object.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>iterable : iterable object  An iterable object providing data for the array. dtype : data-type  The data-type of the returned array. count : int, optional  The number of items to read from <em>iterable</em>. The default is -1,  which means all data is read.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  The output array.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Specify <code>count</code> to improve performance. It allows <code>fromiter</code> to pre-allocate the output array, instead of resizing it on demand.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>iterable = (x*x for x in range(5)) np.fromiter(iterable, float) array([ 0., 1., 4., 9., 16.])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L15876">view source</a></div></div><div class="public anchor" id="var-frompyfunc"><h3>frompyfunc</h3><div class="usage"><code>(frompyfunc self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>frompyfunc(func, nin, nout)</p>
<p>Takes an arbitrary Python function and returns a NumPy ufunc.</p>
<p>Can be used, for example, to add broadcasting to a built-in Python function (see Examples section).</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>func : Python function object  An arbitrary Python function. nin : int  The number of input arguments. nout : int  The number of objects returned by <code>func</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ufunc  Returns a NumPy universal function (<code>ufunc</code>) object.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>vectorize : Evaluates pyfunc over input arrays using broadcasting rules of numpy.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The returned ufunc always returns PyObject arrays.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>Use frompyfunc to add broadcasting to the Python function <code>oct</code>:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>oct_array = np.frompyfunc(oct, 1, 1) oct_array(np.array((10, 30, 100))) array([0o12, 0o36, 0o144], dtype=object) np.array((oct(10), oct(30), oct(100))) # for comparison array([0o12, 0o36, 0o144], dtype=&lt;U5)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L26940">view source</a></div></div><div class="public anchor" id="var-fromregex"><h3>fromregex</h3><div class="usage"><code>(fromregex file regexp dtype &amp; [{encoding :encoding}])</code><code>(fromregex file regexp dtype)</code></div><div class="doc"><div class="markdown"><p>Construct an array from a text file, using regular expression parsing.</p>
<p>The returned array is always a structured array, and is constructed from all matches of the regular expression in the file. Groups in the regular expression are converted to fields of the structured array.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>file : str or file  Filename or file object to read. regexp : str or regexp  Regular expression used to parse the file.  Groups in the regular expression correspond to fields in the dtype. dtype : dtype or list of dtypes  Dtype for the structured array. encoding : str, optional  Encoding used to decode the inputfile. Does not apply to input streams.</p>
<pre><code>.. versionadded:: 1.14.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>output : ndarray  The output array, containing the part of the content of <code>file</code> that  was matched by <code>regexp</code>. <code>output</code> is always a structured array.</p>
<h2><a href="#raises" name="raises"></a>Raises</h2>
<p>TypeError  When <code>dtype</code> is not a valid dtype for a structured array.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>fromstring, loadtxt</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Dtypes for structured arrays can be specified in several forms, but all forms specify at least the data type and field name. For details see <code>doc.structured_arrays</code>.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>f = open(test.dat, w) _ = f.write(1312 foo\n1534 bar\n444 qux) f.close()</p>
      <p>regexp = r(\d+)\s+() # match [digits, whitespace, anything] output = np.fromregex(test.dat, regexp,  [(num, np.int64), (key, S3)]) output array([(1312, bfoo), (1534, bbar), ( 444, bqux)],  dtype=[(num, &lt;i8), (key, S3)]) output[num] array([1312, 1534, 444])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L6362">view source</a></div></div><div class="public anchor" id="var-fromstring"><h3>fromstring</h3><div class="usage"><code>(fromstring self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>fromstring(string, dtype=float, count=-1, sep=)</p>
<p>A new 1-D array initialized from text data in a string.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>string : str  A string containing the data. dtype : data-type, optional  The data type of the array; default: float. For binary input data,  the data must be in exactly this format. Most builtin numeric types are  supported and extension types may be supported.</p>
<pre><code>.. versionadded:: 1.18.0
    Complex dtypes.
</code></pre>
<p>count : int, optional  Read this number of <code>dtype</code> elements from the data. If this is  negative (the default), the count will be determined from the  length of the data. sep : str, optional  The string separating numbers in the data; extra whitespace between  elements is also ignored.</p>
<pre><code>.. deprecated:: 1.14
    Passing ``sep=''``, the default, is deprecated since it will
    trigger the deprecated binary mode of this function. This mode
    interprets `string` as binary bytes, rather than ASCII text with
    decimal numbers, an operation which is better spelt
    ``frombuffer(string, dtype, count)``. If `string` contains unicode
    text, the binary mode of `fromstring` will first encode it into
    bytes using either utf-8 (python 3) or the default encoding
    (python 2), neither of which produce sane results.
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>arr : ndarray  The constructed array.</p>
<h2><a href="#raises" name="raises"></a>Raises</h2>
<p>ValueError  If the string is not the correct size to satisfy the requested  <code>dtype</code> and <code>count</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>frombuffer, fromfile, fromiter</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.fromstring(1 2, dtype=int, sep= ) array([1, 2]) np.fromstring(1, 2, dtype=int, sep=,) array([1, 2])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L13669">view source</a></div></div><div class="public anchor" id="var-full"><h3>full</h3><div class="usage"><code>(full shape fill_value &amp; [{dtype :dtype, order :order}])</code><code>(full shape fill_value &amp; [{dtype :dtype}])</code><code>(full shape fill_value)</code></div><div class="doc"><div class="markdown"><p>Return a new array of given shape and type, filled with <code>fill_value</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>shape : int or sequence of ints  Shape of the new array, e.g., <code>(2, 3)</code> or <code>2</code>. fill_value : scalar  Fill value. dtype : data-type, optional  The desired data-type for the array The default, None, means  <code>np.array(fill_value).dtype</code>. order : {C, F}, optional  Whether to store multidimensional data in C- or Fortran-contiguous  (row- or column-wise) order in memory.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  Array of <code>fill_value</code> with the given shape, dtype, and order.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>full_like : Return a new array with shape of input filled with value. empty : Return a new uninitialized array. ones : Return a new array setting values to one. zeros : Return a new array setting values to zero.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.full((2, 2), np.inf) array(<a href="null">inf, inf],
       [inf, inf</a>) np.full((2, 2), 10) array(<a href="null">10, 10],
       [10, 10</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L15917">view source</a></div></div><div class="public anchor" id="var-full_like"><h3>full_like</h3><div class="usage"><code>(full_like &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return a full array with the same shape and type as a given array.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  The shape and data-type of <code>a</code> define these same attributes of  the returned array. fill_value : scalar  Fill value. dtype : data-type, optional  Overrides the data type of the result. order : {C, F, A, or K}, optional  Overrides the memory layout of the result. C means C-order,  F means F-order, A means F if <code>a</code> is Fortran contiguous,  C otherwise. K means match the layout of <code>a</code> as closely  as possible. subok : bool, optional.  If True, then the newly created array will use the sub-class  type of a, otherwise it will be a base-class array. Defaults  to True. shape : int or sequence of ints, optional.  Overrides the shape of the result. If order=K and the number of  dimensions is unchanged, will try to keep order, otherwise,  order=C is implied.</p>
<pre><code>.. versionadded:: 1.17.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  Array of <code>fill_value</code> with the same shape and type as <code>a</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>empty_like : Return an empty array with shape and type of input. ones_like : Return an array of ones with shape and type of input. zeros_like : Return an array of zeros with shape and type of input. full : Return a new array of given shape filled with value.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.arange(6, dtype=int) np.full_like(x, 1) array([1, 1, 1, 1, 1, 1]) np.full_like(x, 0.1) array([0, 0, 0, 0, 0, 0]) np.full_like(x, 0.1, dtype=np.double) array([0.1, 0.1, 0.1, 0.1, 0.1, 0.1]) np.full_like(x, np.nan, dtype=np.double) array([nan, nan, nan, nan, nan, nan])</p>
      <p>y = np.arange(6, dtype=np.double) np.full_like(y, 0.1) array([0.1, 0.1, 0.1, 0.1, 0.1, 0.1])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L21516">view source</a></div></div><div class="public anchor" id="var-fv"><h3>fv</h3><div class="usage"><code>(fv &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Compute the future value.</p>
<p>.. deprecated:: 1.18</p>
<p><code>fv</code> is deprecated; for details, see NEP 32 [1]_.  Use the corresponding function in the numpy-financial library,  <a href="https://pypi.org/project/numpy-financial">https://pypi.org/project/numpy-financial</a>.</p>
<p>Given:  * a present value, <code>pv</code>  * an interest <code>rate</code> compounded once per period, of which  there are  * <code>nper</code> total  * a (fixed) payment, <code>pmt</code>, paid either  * at the beginning (<code>when</code> = {begin, 1}) or the end  (<code>when</code> = {end, 0}) of each period</p>
<p>Return:  the value at the end of the <code>nper</code> periods</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>rate : scalar or array_like of shape(M, )  Rate of interest as decimal (not per cent) per period nper : scalar or array_like of shape(M, )  Number of compounding periods pmt : scalar or array_like of shape(M, )  Payment pv : scalar or array_like of shape(M, )  Present value when : {{begin, 1}, {end, 0}}, {string, int}, optional  When payments are due (begin (1) or end (0)).  Defaults to {end, 0}.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  Future values. If all input is scalar, returns a scalar float. If  any input is array_like, returns future values for each input element.  If multiple inputs are array_like, they all must have the same shape.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The future value is computed by solving the equation::</p>
<p>fv +  pv*(1+rate)**nper +  pmt*(1 + rate*when)/rate*((1 + rate)**nper - 1) == 0</p>
<p>or, when <code>rate == 0</code>::</p>
<p>fv + pv + pmt * nper == 0</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [1] NumPy Enhancement Proposal (NEP) 32,  <a href="https://numpy.org/neps/nep-0032-remove-financial-functions.html">https://numpy.org/neps/nep-0032-remove-financial-functions.html</a> .. [2] Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May).  Open Document Format for Office Applications (OpenDocument)v1.2,  Part 2: Recalculated Formula (OpenFormula) Format - Annotated Version,  Pre-Draft 12. Organization for the Advancement of Structured Information  Standards (OASIS). Billerica, MA, USA. [ODT Document].  Available:  <a href="http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula">http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula</a>  OpenDocument-formula-20090508.odt</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>What is the future value after 10 years of saving $100 now, with an additional monthly savings of $100. Assume the interest rate is 5% (annually) compounded monthly?</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.fv(0.05/12, 10*12, -100, -100) 15692.928894335748</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>By convention, the negative sign represents cash flow out (i.e. money not available today). Thus, saving $100 a month at 5% annual interest leads to $15,692.93 available to spend in 10 years.</p>
<p>If any input is array_like, returns an array of equal shape. Lets compare different interest rates from the example above.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array((0.05, 0.06, 0.07))/12 np.fv(a, 10*12, -100, -100) array([ 15692.92889434, 16569.87435405, 17509.44688102]) # may vary</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L7818">view source</a></div></div><div class="public anchor" id="var-gcd"><h3>gcd</h3><div class="usage"><code>(gcd self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>gcd(x1, x2, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Returns the greatest common divisor of <code>|x1|</code> and <code>|x2|</code></p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x1, x2 : array_like, int  Arrays of values. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output).</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray or scalar  The greatest common divisor of the absolute value of the inputs  This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>lcm : The lowest common multiple</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.gcd(12, 20) 4 np.gcd.reduce([15, 25, 35]) 5 np.gcd(np.arange(6), 20) array([20, 1, 2, 1, 4, 5])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L14914">view source</a></div></div><div class="public anchor" id="var-generic"><h3>generic</h3><div class="usage"><code>(generic self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Base class for numpy scalar types.</p>
<p>Class from which most (all?) numpy scalar types are derived. For consistency, exposes the same API as <code>ndarray</code>, despite many consequent attributes being either get-only, or completely irrelevant. This is the class from which it is strongly suggested users should derive custom scalar types.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L1119">view source</a></div></div><div class="public anchor" id="var-genfromtxt"><h3>genfromtxt</h3><div class="usage"><code>(genfromtxt fname &amp; [{names :names, max_rows :max_rows, encoding :encoding, case_sensitive :case_sensitive, usemask :usemask, dtype :dtype, skip_header :skip_header, autostrip :autostrip, skip_footer :skip_footer, comments :comments, unpack :unpack, converters :converters, filling_values :filling_values, deletechars :deletechars, defaultfmt :defaultfmt, excludelist :excludelist, delimiter :delimiter, loose :loose, invalid_raise :invalid_raise, replace_space :replace_space, missing_values :missing_values, usecols :usecols}])</code><code>(genfromtxt fname &amp; [{names :names, max_rows :max_rows, case_sensitive :case_sensitive, usemask :usemask, dtype :dtype, skip_header :skip_header, autostrip :autostrip, skip_footer :skip_footer, comments :comments, unpack :unpack, converters :converters, filling_values :filling_values, deletechars :deletechars, defaultfmt :defaultfmt, excludelist :excludelist, delimiter :delimiter, loose :loose, invalid_raise :invalid_raise, replace_space :replace_space, missing_values :missing_values, usecols :usecols}])</code><code>(genfromtxt fname &amp; [{names :names, case_sensitive :case_sensitive, usemask :usemask, dtype :dtype, skip_header :skip_header, autostrip :autostrip, skip_footer :skip_footer, comments :comments, unpack :unpack, converters :converters, filling_values :filling_values, deletechars :deletechars, defaultfmt :defaultfmt, excludelist :excludelist, delimiter :delimiter, loose :loose, invalid_raise :invalid_raise, replace_space :replace_space, missing_values :missing_values, usecols :usecols}])</code><code>(genfromtxt fname &amp; [{names :names, case_sensitive :case_sensitive, usemask :usemask, dtype :dtype, skip_header :skip_header, autostrip :autostrip, skip_footer :skip_footer, comments :comments, unpack :unpack, converters :converters, filling_values :filling_values, deletechars :deletechars, defaultfmt :defaultfmt, excludelist :excludelist, delimiter :delimiter, loose :loose, replace_space :replace_space, missing_values :missing_values, usecols :usecols}])</code><code>(genfromtxt fname &amp; [{names :names, case_sensitive :case_sensitive, usemask :usemask, dtype :dtype, skip_header :skip_header, autostrip :autostrip, skip_footer :skip_footer, comments :comments, unpack :unpack, converters :converters, filling_values :filling_values, deletechars :deletechars, defaultfmt :defaultfmt, excludelist :excludelist, delimiter :delimiter, replace_space :replace_space, missing_values :missing_values, usecols :usecols}])</code><code>(genfromtxt fname &amp; [{names :names, case_sensitive :case_sensitive, dtype :dtype, skip_header :skip_header, autostrip :autostrip, skip_footer :skip_footer, comments :comments, unpack :unpack, converters :converters, filling_values :filling_values, deletechars :deletechars, defaultfmt :defaultfmt, excludelist :excludelist, delimiter :delimiter, replace_space :replace_space, missing_values :missing_values, usecols :usecols}])</code><code>(genfromtxt fname &amp; [{names :names, case_sensitive :case_sensitive, dtype :dtype, skip_header :skip_header, autostrip :autostrip, skip_footer :skip_footer, comments :comments, converters :converters, filling_values :filling_values, deletechars :deletechars, defaultfmt :defaultfmt, excludelist :excludelist, delimiter :delimiter, replace_space :replace_space, missing_values :missing_values, usecols :usecols}])</code><code>(genfromtxt fname &amp; [{names :names, case_sensitive :case_sensitive, dtype :dtype, skip_header :skip_header, autostrip :autostrip, skip_footer :skip_footer, comments :comments, converters :converters, filling_values :filling_values, deletechars :deletechars, excludelist :excludelist, delimiter :delimiter, replace_space :replace_space, missing_values :missing_values, usecols :usecols}])</code><code>(genfromtxt fname &amp; [{names :names, dtype :dtype, skip_header :skip_header, autostrip :autostrip, skip_footer :skip_footer, comments :comments, converters :converters, filling_values :filling_values, deletechars :deletechars, excludelist :excludelist, delimiter :delimiter, replace_space :replace_space, missing_values :missing_values, usecols :usecols}])</code><code>(genfromtxt fname &amp; [{names :names, dtype :dtype, skip_header :skip_header, skip_footer :skip_footer, comments :comments, converters :converters, filling_values :filling_values, deletechars :deletechars, excludelist :excludelist, delimiter :delimiter, replace_space :replace_space, missing_values :missing_values, usecols :usecols}])</code><code>(genfromtxt fname &amp; [{names :names, dtype :dtype, skip_header :skip_header, skip_footer :skip_footer, comments :comments, converters :converters, filling_values :filling_values, deletechars :deletechars, excludelist :excludelist, delimiter :delimiter, missing_values :missing_values, usecols :usecols}])</code><code>(genfromtxt fname &amp; [{names :names, dtype :dtype, skip_header :skip_header, skip_footer :skip_footer, comments :comments, converters :converters, filling_values :filling_values, excludelist :excludelist, delimiter :delimiter, missing_values :missing_values, usecols :usecols}])</code><code>(genfromtxt fname &amp; [{names :names, dtype :dtype, skip_header :skip_header, skip_footer :skip_footer, comments :comments, converters :converters, filling_values :filling_values, delimiter :delimiter, missing_values :missing_values, usecols :usecols}])</code><code>(genfromtxt fname &amp; [{dtype :dtype, skip_header :skip_header, skip_footer :skip_footer, comments :comments, converters :converters, filling_values :filling_values, delimiter :delimiter, missing_values :missing_values, usecols :usecols}])</code><code>(genfromtxt fname &amp; [{dtype :dtype, comments :comments, delimiter :delimiter, skip_header :skip_header, skip_footer :skip_footer, converters :converters, missing_values :missing_values, filling_values :filling_values}])</code><code>(genfromtxt fname &amp; [{dtype :dtype, comments :comments, delimiter :delimiter, skip_header :skip_header, skip_footer :skip_footer, converters :converters, missing_values :missing_values}])</code><code>(genfromtxt fname &amp; [{dtype :dtype, comments :comments, delimiter :delimiter, skip_header :skip_header, skip_footer :skip_footer, converters :converters}])</code><code>(genfromtxt fname &amp; [{dtype :dtype, comments :comments, delimiter :delimiter, skip_header :skip_header, skip_footer :skip_footer}])</code><code>(genfromtxt fname &amp; [{dtype :dtype, comments :comments, delimiter :delimiter, skip_header :skip_header}])</code><code>(genfromtxt fname &amp; [{dtype :dtype, comments :comments, delimiter :delimiter}])</code><code>(genfromtxt fname &amp; [{dtype :dtype, comments :comments}])</code><code>(genfromtxt fname &amp; [{dtype :dtype}])</code><code>(genfromtxt fname)</code></div><div class="doc"><div class="markdown"><p>Load data from a text file, with missing values handled as specified.</p>
<p>Each line past the first <code>skip_header</code> lines is split at the <code>delimiter</code> character, and characters following the <code>comments</code> character are discarded.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>fname : file, str, pathlib.Path, list of str, generator  File, filename, list, or generator to read. If the filename  extension is <code>.gz</code> or <code>.bz2</code>, the file is first decompressed. Note  that generators must return byte strings. The strings  in a list or produced by a generator are treated as lines. dtype : dtype, optional  Data type of the resulting array.  If None, the dtypes will be determined by the contents of each  column, individually. comments : str, optional  The character used to indicate the start of a comment.  All the characters occurring on a line after a comment are discarded delimiter : str, int, or sequence, optional  The string used to separate values. By default, any consecutive  whitespaces act as delimiter. An integer or sequence of integers  can also be provided as width(s) of each field. skiprows : int, optional  <code>skiprows</code> was removed in numpy 1.10. Please use <code>skip_header</code> instead. skip_header : int, optional  The number of lines to skip at the beginning of the file. skip_footer : int, optional  The number of lines to skip at the end of the file. converters : variable, optional  The set of functions that convert the data of a column to a value.  The converters can also be used to provide a default value  for missing data: <code>converters = {3: lambda s: float(s or 0)}</code>. missing : variable, optional  <code>missing</code> was removed in numpy 1.10. Please use <code>missing_values</code>  instead. missing_values : variable, optional  The set of strings corresponding to missing data. filling_values : variable, optional  The set of values to be used as default when the data are missing. usecols : sequence, optional  Which columns to read, with 0 being the first. For example,  <code>usecols = (1, 4, 5)</code> will extract the 2nd, 5th and 6th columns. names : {None, True, str, sequence}, optional  If <code>names</code> is True, the field names are read from the first line after  the first <code>skip_header</code> lines. This line can optionally be proceeded  by a comment delimiter. If <code>names</code> is a sequence or a single-string of  comma-separated names, the names will be used to define the field names  in a structured dtype. If <code>names</code> is None, the names of the dtype  fields will be used, if any. excludelist : sequence, optional  A list of names to exclude. This list is appended to the default list  [return,file,print]. Excluded names are appended an underscore:  for example, <code>file</code> would become <code>file_</code>. deletechars : str, optional  A string combining invalid characters that must be deleted from the  names. defaultfmt : str, optional  A format used to define default field names, such as f%i or f_%02i. autostrip : bool, optional  Whether to automatically strip white spaces from the variables. replace_space : char, optional  Character(s) used in replacement of white spaces in the variables  names. By default, use a _. case_sensitive : {True, False, upper, lower}, optional  If True, field names are case sensitive.  If False or upper, field names are converted to upper case.  If lower, field names are converted to lower case. unpack : bool, optional  If True, the returned array is transposed, so that arguments may be  unpacked using <code>x, y, z = loadtxt(...)</code> usemask : bool, optional  If True, return a masked array.  If False, return a regular array. loose : bool, optional  If True, do not raise errors for invalid values. invalid_raise : bool, optional  If True, an exception is raised if an inconsistency is detected in the  number of columns.  If False, a warning is emitted and the offending lines are skipped. max_rows : int, optional  The maximum number of rows to read. Must not be used with skip_footer  at the same time. If given, the value must be at least 1. Default is  to read the entire file.</p>
<pre><code>.. versionadded:: 1.10.0
</code></pre>
<p>encoding : str, optional  Encoding used to decode the inputfile. Does not apply when <code>fname</code> is  a file object. The special value bytes enables backward compatibility  workarounds that ensure that you receive byte arrays when possible  and passes latin1 encoded strings to converters. Override this value to  receive unicode arrays and pass strings as input to converters. If set  to None the system default is used. The default value is bytes.</p>
<pre><code>.. versionadded:: 1.14.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  Data read from the text file. If <code>usemask</code> is True, this is a  masked array.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>numpy.loadtxt : equivalent function when no data is missing.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<ul>
  <li>When spaces are used as delimiters, or when no delimiter has been given  as input, there should not be any missing data between two fields.</li>
  <li>When the variables are named (either by a flexible dtype or with <code>names</code>,  there must not be any header in the file (else a ValueError  exception is raised).</li>
  <li>Individual values are not stripped of spaces by default.  When using a custom converter, make sure the function does remove spaces.</li>
</ul>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [1] NumPy User Guide, section <code>I/O with NumPy
       &lt;https://docs.scipy.org/doc/numpy/user/basics.io.genfromtxt.html&gt;</code>_.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>from io import StringIO import numpy as np</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Comma delimited file with mixed dtype</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>s = StringIO(u1,1.3,abcde) data = np.genfromtxt(s, dtype=[(myint,i8),(myfloat,f8),  (mystring,S5)], delimiter=,) data array((1, 1.3, babcde),  dtype=[(myint, &lt;i8), (myfloat, &lt;f8), (mystring, S5)])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Using dtype = None</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>_ = s.seek(0) # needed for StringIO example only data = np.genfromtxt(s, dtype=None,  names = [myint,myfloat,mystring], delimiter=,) data array((1, 1.3, babcde),  dtype=[(myint, &lt;i8), (myfloat, &lt;f8), (mystring, S5)])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Specifying dtype and names</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>_ = s.seek(0) data = np.genfromtxt(s, dtype=i8,f8,S5,  names=[myint,myfloat,mystring], delimiter=,) data array((1, 1.3, babcde),  dtype=[(myint, &lt;i8), (myfloat, &lt;f8), (mystring, S5)])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>An example with fixed-width columns</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>s = StringIO(u11.3abcde) data = np.genfromtxt(s, dtype=None, names=[intvar,fltvar,strvar],  delimiter=[1,3,5]) data array((1, 1.3, babcde),  dtype=[(intvar, &lt;i8), (fltvar, &lt;f8), (strvar, S5)])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>An example to show comments</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>f = StringIO(  text,# of chars  hello world,11  numpy,5) np.genfromtxt(f, dtype=S12,S12, delimiter=,) array([(btext, b), (bhello world, b11), (bnumpy, b5)],  dtype=[(f0, S12), (f1, S12)])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L10682">view source</a></div></div><div class="public anchor" id="var-geomspace"><h3>geomspace</h3><div class="usage"><code>(geomspace &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return numbers spaced evenly on a log scale (a geometric progression).</p>
<p>This is similar to <code>logspace</code>, but with endpoints specified directly. Each output sample is a constant multiple of the previous.</p>
<p>.. versionchanged:: 1.16.0  Non-scalar <code>start</code> and <code>stop</code> are now supported.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>start : array_like  The starting value of the sequence. stop : array_like  The final value of the sequence, unless <code>endpoint</code> is False.  In that case, <code>num + 1</code> values are spaced over the  interval in log-space, of which all but the last (a sequence of  length <code>num</code>) are returned. num : integer, optional  Number of samples to generate. Default is 50. endpoint : boolean, optional  If true, <code>stop</code> is the last sample. Otherwise, it is not included.  Default is True. dtype : dtype  The type of the output array. If <code>dtype</code> is not given, infer the data  type from the other input arguments. axis : int, optional  The axis in the result to store the samples. Relevant only if start  or stop are array-like. By default (0), the samples will be along a  new axis inserted at the beginning. Use -1 to get an axis at the end.</p>
<pre><code>.. versionadded:: 1.16.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>samples : ndarray  <code>num</code> samples, equally spaced on a log scale.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>logspace : Similar to geomspace, but with endpoints specified using log  and base. linspace : Similar to geomspace, but with arithmetic instead of geometric  progression. arange : Similar to linspace, with the step size specified instead of the  number of samples.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>If the inputs or dtype are complex, the output will follow a logarithmic spiral in the complex plane. (There are an infinite number of spirals passing through two points; the output will follow the shortest such path.)</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.geomspace(1, 1000, num=4) array([ 1., 10., 100., 1000.]) np.geomspace(1, 1000, num=3, endpoint=False) array([ 1., 10., 100.]) np.geomspace(1, 1000, num=4, endpoint=False) array([ 1. , 5.62341325, 31.6227766 , 177.827941 ]) np.geomspace(1, 256, num=9) array([ 1., 2., 4., 8., 16., 32., 64., 128., 256.])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Note that the above may not produce exact integers:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.geomspace(1, 256, num=9, dtype=int) array([ 1, 2, 4, 7, 16, 32, 63, 127, 256]) np.around(np.geomspace(1, 256, num=9)).astype(int) array([ 1, 2, 4, 8, 16, 32, 64, 128, 256])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Negative, decreasing, and complex inputs are allowed:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.geomspace(1000, 1, num=4) array([1000., 100., 10., 1.]) np.geomspace(-1000, -1, num=4) array([-1000., -100., -10., -1.]) np.geomspace(1j, 1000j, num=4) # Straight line array([0. +1.j, 0. +10.j, 0. +100.j, 0.+1000.j]) np.geomspace(-1+0j, 1+0j, num=5) # Circle array([-1.00000000e+00+1.22464680e-16j, -7.07106781e-01+7.07106781e-01j,  6.12323400e-17+1.00000000e+00j, 7.07106781e-01+7.07106781e-01j,  1.00000000e+00+0.00000000e+00j])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Graphical illustration of <code>endpoint</code> parameter:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>import matplotlib.pyplot as plt N = 10 y = np.zeros(N) plt.semilogx(np.geomspace(1, 1000, N, endpoint=True), y + 1, o) [&lt;matplotlib.lines.Line2D object at 0x&gt;] plt.semilogx(np.geomspace(1, 1000, N, endpoint=False), y + 2, o) [&lt;matplotlib.lines.Line2D object at 0x&gt;] plt.axis([0.5, 2000, 0, 3]) [0.5, 2000, 0, 3] plt.grid(True, color=0.7, linestyle=-, which=both, axis=both) plt.show()</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L25499">view source</a></div></div><div class="public anchor" id="var-get_array_wrap"><h3>get_array_wrap</h3><div class="usage"><code>(get_array_wrap &amp; [args])</code></div><div class="doc"><div class="markdown"><p>Find the wrapper for the array with the highest priority.</p>
<p>In case of ties, leftmost wins. If no wrapper is found, return None</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L6916">view source</a></div></div><div class="public anchor" id="var-get_include"><h3>get_include</h3><div class="usage"><code>(get_include)</code></div><div class="doc"><div class="markdown"><p>Return the directory that contains the NumPy *.h header files.</p>
<p>Extension modules that need to compile against NumPy should use this function to locate the appropriate include directory.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>When using <code>distutils</code>, for example in <code>setup.py</code>. ::</p>
<pre><code>import numpy as np
...
Extension('extension_name', ...
        include_dirs=[np.get_include()])
...
</code></pre></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L1373">view source</a></div></div><div class="public anchor" id="var-get_printoptions"><h3>get_printoptions</h3><div class="usage"><code>(get_printoptions)</code></div><div class="doc"><div class="markdown"><p>Return the current print options.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>print_opts : dict  Dictionary of current print options with keys</p>
<pre><code>  - precision : int
  - threshold : int
  - edgeitems : int
  - linewidth : int
  - suppress : bool
  - nanstr : str
  - infstr : str
  - formatter : dict of callables
  - sign : str

For a full description of these options, see `set_printoptions`.
</code></pre>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>set_printoptions, printoptions, set_string_function</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L24367">view source</a></div></div><div class="public anchor" id="var-getbufsize"><h3>getbufsize</h3><div class="usage"><code>(getbufsize)</code></div><div class="doc"><div class="markdown"><p>Return the size of the buffer used in ufuncs.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>getbufsize : int  Size of ufunc buffer in bytes.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L20766">view source</a></div></div><div class="public anchor" id="var-geterr"><h3>geterr</h3><div class="usage"><code>(geterr)</code></div><div class="doc"><div class="markdown"><p>Get the current way of handling floating-point errors.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>res : dict  A dictionary with keys divide, over, under, and invalid,  whose values are from the strings ignore, print, log, warn,  raise, and call. The keys represent possible floating-point  exceptions, and the values define how these exceptions are handled.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>geterrcall, seterr, seterrcall</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>For complete documentation of the types of floating-point exceptions and treatment options, see <code>seterr</code>.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>from collections import OrderedDict sorted(np.geterr().items()) [(divide, warn), (invalid, warn), (over, warn), (under, ignore)] np.arange(3.) / np.arange(3.) array([nan, 1., 1.])</p>
      <p>oldsettings = np.seterr(all=warn, over=raise) OrderedDict(sorted(np.geterr().items())) OrderedDict([(divide, warn), (invalid, warn), (over, raise), (under, warn)]) np.arange(3.) / np.arange(3.) array([nan, 1., 1.])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L16927">view source</a></div></div><div class="public anchor" id="var-geterrcall"><h3>geterrcall</h3><div class="usage"><code>(geterrcall)</code></div><div class="doc"><div class="markdown"><p>Return the current callback function used on floating-point errors.</p>
<p>When the error handling for a floating-point error (one of divide, over, under, or invalid) is set to call or log, the function that is called or the log instance that is written to is returned by <code>geterrcall</code>. This function or log instance has been set with <code>seterrcall</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>errobj : callable, log instance or None  The current error handler. If no handler was set through <code>seterrcall</code>,  <code>None</code> is returned.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>seterrcall, seterr, geterr</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>For complete documentation of the types of floating-point exceptions and treatment options, see <code>seterr</code>.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.geterrcall() # we did not yet set a handler, returns None</p>
      <p>oldsettings = np.seterr(all=call) def err_handler(type, flag):  print(Floating point error (%s), with flag %s % (type, flag)) oldhandler = np.seterrcall(err_handler) np.array([1, 2, 3]) / 0.0 Floating point error (divide by zero), with flag 1 array([inf, inf, inf])</p>
      <p>cur_handler = np.geterrcall() cur_handler is err_handler True</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L23215">view source</a></div></div><div class="public anchor" id="var-geterrobj"><h3>geterrobj</h3><div class="usage"><code>(geterrobj self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>geterrobj()</p>
<p>Return the current object that defines floating-point error handling.</p>
<p>The error object contains all information that defines the error handling behavior in NumPy. <code>geterrobj</code> is used internally by the other functions that get and set error handling behavior (<code>geterr</code>, <code>seterr</code>, <code>geterrcall</code>, <code>seterrcall</code>).</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>errobj : list  The error object, a list containing three elements:  [internal numpy buffer size, error mask, error callback function].</p>
<pre><code>The error mask is a single integer that holds the treatment information
on all four floating point errors. The information for each error type
is contained in three bits of the integer. If we print it in base 8, we
can see what treatment is set for "invalid", "under", "over", and
"divide" (in that order). The printed string can be interpreted with

* 0 : 'ignore'
* 1 : 'warn'
* 2 : 'raise'
* 3 : 'call'
* 4 : 'print'
* 5 : 'log'
</code></pre>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>seterrobj, seterr, geterr, seterrcall, geterrcall getbufsize, setbufsize</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>For complete documentation of the types of floating-point exceptions and treatment options, see <code>seterr</code>.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.geterrobj() # first get the defaults [8192, 521, None]</p>
      <p>def err_handler(type, flag):  print(Floating point error (%s), with flag %s % (type, flag))  old_bufsize = np.setbufsize(20000) old_err = np.seterr(divide=raise) old_handler = np.seterrcall(err_handler) np.geterrobj() [8192, 521, <function err_handler="" at="" 0x91dcaac="">]</function></p>
      <p>old_err = np.seterr(all=ignore) np.base_repr(np.geterrobj()[1], 8) 0 old_err = np.seterr(divide=warn, over=log, under=call,  invalid=print) np.base_repr(np.geterrobj()[1], 8) 4351</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L20044">view source</a></div></div><div class="public anchor" id="var-gradient"><h3>gradient</h3><div class="usage"><code>(gradient &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return the gradient of an N-dimensional array.</p>
<p>The gradient is computed using second order accurate central differences in the interior points and either first or second order accurate one-sides (forward or backwards) differences at the boundaries. The returned gradient hence has the same shape as the input array.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>f : array_like  An N-dimensional array containing samples of a scalar function. varargs : list of scalar or array, optional  Spacing between f values. Default unitary spacing for all dimensions.  Spacing can be specified using:</p>
<pre><code>1. single scalar to specify a sample distance for all dimensions.
2. N scalars to specify a constant sample distance for each dimension.
   i.e. `dx`, `dy`, `dz`, ...
3. N arrays to specify the coordinates of the values along each
   dimension of F. The length of the array must match the size of
   the corresponding dimension
4. Any combination of N scalars/arrays with the meaning of 2. and 3.

If `axis` is given, the number of varargs must equal the number of axes.
Default: 1.
</code></pre>
<p>edge_order : {1, 2}, optional  Gradient is calculated using N-th order accurate differences  at the boundaries. Default: 1.</p>
<pre><code>.. versionadded:: 1.9.1
</code></pre>
<p>axis : None or int or tuple of ints, optional  Gradient is calculated only along the given axis or axes  The default (axis = None) is to calculate the gradient for all the axes  of the input array. axis may be negative, in which case it counts from  the last to the first axis.</p>
<pre><code>.. versionadded:: 1.11.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>gradient : ndarray or list of ndarray  A set of ndarrays (or a single ndarray if there is only one dimension)  corresponding to the derivatives of f with respect to each dimension.  Each derivative has the same shape as f.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>f = np.array([1, 2, 4, 7, 11, 16], dtype=float) np.gradient(f) array([1. , 1.5, 2.5, 3.5, 4.5, 5. ]) np.gradient(f, 2) array([0.5 , 0.75, 1.25, 1.75, 2.25, 2.5 ])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Spacing can be also specified with an array that represents the coordinates of the values F along the dimensions. For instance a uniform spacing:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.arange(f.size) np.gradient(f, x) array([1. , 1.5, 2.5, 3.5, 4.5, 5. ])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Or a non uniform one:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.array([0., 1., 1.5, 3.5, 4., 6.], dtype=float) np.gradient(f, x) array([1. , 3. , 3.5, 6.7, 6.9, 2.5])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>For two dimensional arrays, the return will be two arrays ordered by axis. In this example the first array stands for the gradient in rows and the second one in columns direction:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.gradient(np.array(<a href="null">1, 2, 6], [3, 4, 5</a>, dtype=float)) [array([[ 2., 2., -1.],  [ 2., 2., -1.]]), array([[1. , 2.5, 4. ],  [1. , 1. , 1. ]])]</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>In this example the spacing is also specified: uniform for axis=0 and non uniform for axis=1</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>dx = 2. y = [1., 1.5, 3.5] np.gradient(np.array(<a href="null">1, 2, 6], [3, 4, 5</a>, dtype=float), dx, y) [array([[ 1. , 1. , -0.5],  [ 1. , 1. , -0.5]]), array([[2. , 2. , 2. ],  [2. , 1.7, 0.5]])]</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>It is possible to specify how boundaries are treated using <code>edge_order</code></p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.array([0, 1, 2, 3, 4]) f = x**2 np.gradient(f, edge_order=1) array([1., 2., 4., 6., 7.]) np.gradient(f, edge_order=2) array([0., 2., 4., 6., 8.])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The <code>axis</code> keyword can be used to specify a subset of axes of which the gradient is calculated</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.gradient(np.array(<a href="null">1, 2, 6], [3, 4, 5</a>, dtype=float), axis=0) array(<a href="null"> 2.,  2., -1.],
       [ 2.,  2., -1.</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Assuming that :math:<code>f\in C^{3}</code> (i.e., :math:<code>f</code> has at least 3 continuous derivatives) and let :math:<code>h_{*}</code> be a non-homogeneous stepsize, we minimize the consistency error :math:<code>\eta_{i}</code> between the true gradient and its estimate from a linear combination of the neighboring grid-points:</p>
<p>.. math::</p>
<pre><code>\eta_{i} = f_{i}^{\left(1\right)} -
            \left[ \alpha f\left(x_{i}\right) +
                    \beta f\left(x_{i} + h_{d}\right) +
                    \gamma f\left(x_{i}-h_{s}\right)
            \right]
</code></pre>
<p>By substituting :math:<code>f(x_{i} + h_{d})</code> and :math:<code>f(x_{i} - h_{s})</code> with their Taylor series expansion, this translates into solving the following the linear system:</p>
<p>.. math::</p>
<pre><code>\left\{
    \begin{array}{r}
        \alpha+\beta+\gamma=0 \\
        \beta h_{d}-\gamma h_{s}=1 \\
        \beta h_{d}^{2}+\gamma h_{s}^{2}=0
    \end{array}
\right.
</code></pre>
<p>The resulting approximation of :math:<code>f_{i}^{(1)}</code> is the following:</p>
<p>.. math::</p>
<pre><code>\hat f_{i}^{(1)} =
    \frac{
        h_{s}^{2}f\left(x_{i} + h_{d}\right)
        + \left(h_{d}^{2} - h_{s}^{2}\right)f\left(x_{i}\right)
        - h_{d}^{2}f\left(x_{i}-h_{s}\right)}
        { h_{s}h_{d}\left(h_{d} + h_{s}\right)}
    + \mathcal{O}\left(\frac{h_{d}h_{s}^{2}
                        + h_{s}h_{d}^{2}}{h_{d}
                        + h_{s}}\right)
</code></pre>
<p>It is worth noting that if :math:<code>h_{s}=h_{d}</code> (i.e., data are evenly spaced) we find the standard second order approximation:</p>
<p>.. math::</p>
<pre><code>\hat f_{i}^{(1)}=
    \frac{f\left(x_{i+1}\right) - f\left(x_{i-1}\right)}{2h}
    + \mathcal{O}\left(h^{2}\right)
</code></pre>
<p>With a similar procedure the forward/backward approximations used for boundaries can be derived.</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [1] Quarteroni A., Sacco R., Saleri F. (2007) Numerical Mathematics  (Texts in Applied Mathematics). New York: Springer. .. [2] Durran D. R. (1999) Numerical Methods for Wave Equations  in Geophysical Fluid Dynamics. New York: Springer. .. [3] Fornberg B. (1988) Generation of Finite Difference Formulas on  Arbitrarily Spaced Grids,  Mathematics of Computation 51, no. 184 : 699-706.  <code>PDF &lt;http://www.ams.org/journals/mcom/1988-51-184/
        S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf&gt;</code>_.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L3796">view source</a></div></div><div class="public anchor" id="var-greater"><h3>greater</h3><div class="usage"><code>(greater self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>greater(x1, x2, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Return the truth value of (x1 &gt; x2) element-wise.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x1, x2 : array_like  Input arrays. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output). out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray or scalar  Output array, element-wise comparison of <code>x1</code> and <code>x2</code>.  Typically of type bool, unless <code>dtype=object</code> is passed.  This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>greater_equal, less, less_equal, equal, not_equal</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.greater([4,2],[2,2]) array([ True, False])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>If the inputs are ndarrays, then np.greater is equivalent to &gt;.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array([4,2]) b = np.array([2,2]) a &gt; b array([ True, False])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L12594">view source</a></div></div><div class="public anchor" id="var-greater_equal"><h3>greater_equal</h3><div class="usage"><code>(greater_equal self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>greater_equal(x1, x2, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Return the truth value of (x1 &gt;= x2) element-wise.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x1, x2 : array_like  Input arrays. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output). out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : bool or ndarray of bool  Output array, element-wise comparison of <code>x1</code> and <code>x2</code>.  Typically of type bool, unless <code>dtype=object</code> is passed.  This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>greater, less, less_equal, equal, not_equal</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.greater_equal([4, 2, 1], [2, 2, 2]) array([ True, True, False])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L17156">view source</a></div></div><div class="public anchor" id="var-half"><h3>half</h3><div class="usage"><code>(half self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Half-precision floating-point number type. Character code: <code>'e'</code>. Canonical name: <code>np.half</code>. Alias <em>on this platform</em>: <code>np.float16</code>: 16-bit-precision floating-point number type: sign bit, 5 bits exponent, 10 bits mantissa.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L16281">view source</a></div></div><div class="public anchor" id="var-hamming"><h3>hamming</h3><div class="usage"><code>(hamming M)</code></div><div class="doc"><div class="markdown"><p>Return the Hamming window.</p>
<p>The Hamming window is a taper formed by using a weighted cosine.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>M : int  Number of points in the output window. If zero or less, an  empty array is returned.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  The window, with the maximum value normalized to one (the value  one appears only if the number of samples is odd).</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>bartlett, blackman, hanning, kaiser</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The Hamming window is defined as</p>
<p>.. math:: w(n) = 0.54 - 0.46cos\left(\frac{2\pi{n}}{M-1}\right)  \qquad 0 \leq n \leq M-1</p>
<p>The Hamming was named for R. W. Hamming, an associate of J. W. Tukey and is described in Blackman and Tukey. It was recommended for smoothing the truncated autocovariance function in the time domain. Most references to the Hamming window come from the signal processing literature, where it is used as one of many windowing functions for smoothing values. It is also known as an apodization (which means removing the foot, i.e. smoothing discontinuities at the beginning and end of the sampled signal) or tapering function.</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power  spectra, Dover Publications, New York. .. [2] E.R. Kanasewich, Time Sequence Analysis in Geophysics, The  University of Alberta Press, 1975, pp. 109-110. .. [3] Wikipedia, Window function,  <a href="https://en.wikipedia.org/wiki/Window_function">https://en.wikipedia.org/wiki/Window_function</a> .. [4] W.H. Press, B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,  Numerical Recipes, Cambridge University Press, 1986, page 425.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.hamming(12) array([ 0.08 , 0.15302337, 0.34890909, 0.60546483, 0.84123594, # may vary  0.98136677, 0.98136677, 0.84123594, 0.60546483, 0.34890909,  0.15302337, 0.08 ])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Plot the window and the frequency response:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>import matplotlib.pyplot as plt from numpy.fft import fft, fftshift window = np.hamming(51) plt.plot(window) [&lt;matplotlib.lines.Line2D object at 0x&gt;] plt.title(Hamming window) Text(0.5, 1.0, Hamming window) plt.ylabel(Amplitude) Text(0, 0.5, Amplitude) plt.xlabel(Sample) Text(0.5, 0, Sample) plt.show()</p>
      <p>plt.figure() </p><figure size="" 640x480="" with="" 0="" axes=""> A = fft(window, 2048) / 25.5 mag = np.abs(fftshift(A)) freq = np.linspace(-0.5, 0.5, len(A)) response = 20 * np.log10(mag) response = np.clip(response, -100, 100) plt.plot(freq, response) [&lt;matplotlib.lines.Line2D object at 0x&gt;] plt.title(Frequency response of Hamming window) Text(0.5, 1.0, Frequency response of Hamming window) plt.ylabel(Magnitude [dB]) Text(0, 0.5, Magnitude [dB]) plt.xlabel(Normalized frequency [cycles per sample]) Text(0.5, 0, Normalized frequency [cycles per sample]) plt.axis(tight)  plt.show()<p></p>
    </figure></blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L14035">view source</a></div></div><div class="public anchor" id="var-hanning"><h3>hanning</h3><div class="usage"><code>(hanning M)</code></div><div class="doc"><div class="markdown"><p>Return the Hanning window.</p>
<p>The Hanning window is a taper formed by using a weighted cosine.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>M : int  Number of points in the output window. If zero or less, an  empty array is returned.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray, shape(M,)  The window, with the maximum value normalized to one (the value  one appears only if <code>M</code> is odd).</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>bartlett, blackman, hamming, kaiser</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The Hanning window is defined as</p>
<p>.. math:: w(n) = 0.5 - 0.5cos\left(\frac{2\pi{n}}{M-1}\right)  \qquad 0 \leq n \leq M-1</p>
<p>The Hanning was named for Julius von Hann, an Austrian meteorologist. It is also known as the Cosine Bell. Some authors prefer that it be called a Hann window, to help avoid confusion with the very similar Hamming window.</p>
<p>Most references to the Hanning window come from the signal processing literature, where it is used as one of many windowing functions for smoothing values. It is also known as an apodization (which means removing the foot, i.e. smoothing discontinuities at the beginning and end of the sampled signal) or tapering function.</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power  spectra, Dover Publications, New York. .. [2] E.R. Kanasewich, Time Sequence Analysis in Geophysics,  The University of Alberta Press, 1975, pp. 106-108. .. [3] Wikipedia, Window function,  <a href="https://en.wikipedia.org/wiki/Window_function">https://en.wikipedia.org/wiki/Window_function</a> .. [4] W.H. Press, B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,  Numerical Recipes, Cambridge University Press, 1986, page 425.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.hanning(12) array([0. , 0.07937323, 0.29229249, 0.57115742, 0.82743037,  0.97974649, 0.97974649, 0.82743037, 0.57115742, 0.29229249,  0.07937323, 0. ])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Plot the window and its frequency response:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>import matplotlib.pyplot as plt from numpy.fft import fft, fftshift window = np.hanning(51) plt.plot(window) [&lt;matplotlib.lines.Line2D object at 0x&gt;] plt.title(Hann window) Text(0.5, 1.0, Hann window) plt.ylabel(Amplitude) Text(0, 0.5, Amplitude) plt.xlabel(Sample) Text(0.5, 0, Sample) plt.show()</p>
      <p>plt.figure() </p><figure size="" 640x480="" with="" 0="" axes=""> A = fft(window, 2048) / 25.5 mag = np.abs(fftshift(A)) freq = np.linspace(-0.5, 0.5, len(A)) with np.errstate(divide=ignore, invalid=ignore):  response = 20 * np.log10(mag)  response = np.clip(response, -100, 100) plt.plot(freq, response) [&lt;matplotlib.lines.Line2D object at 0x&gt;] plt.title(Frequency response of the Hann window) Text(0.5, 1.0, Frequency response of the Hann window) plt.ylabel(Magnitude [dB]) Text(0, 0.5, Magnitude [dB]) plt.xlabel(Normalized frequency [cycles per sample]) Text(0.5, 0, Normalized frequency [cycles per sample]) plt.axis(tight)  plt.show()<p></p>
    </figure></blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L23621">view source</a></div></div><div class="public anchor" id="var-heaviside"><h3>heaviside</h3><div class="usage"><code>(heaviside self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>heaviside(x1, x2, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Compute the Heaviside step function.</p>
<p>The Heaviside step function is defined as::</p>
<pre><code>                      0   if x1 &lt; 0
heaviside(x1, x2) =  x2   if x1 == 0
                      1   if x1 &gt; 0
</code></pre>
<p>where <code>x2</code> is often taken to be 0.5, but 0 and 1 are also sometimes used.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x1 : array_like  Input values. x2 : array_like  The value of the function when x1 is 0. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output). out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray or scalar  The output array, element-wise Heaviside step function of <code>x1</code>.  This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>.. versionadded:: 1.13.0</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. Wikipedia, Heaviside step function,  <a href="https://en.wikipedia.org/wiki/Heaviside_step_function">https://en.wikipedia.org/wiki/Heaviside_step_function</a></p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.heaviside([-1.5, 0, 2.0], 0.5) array([ 0. , 0.5, 1. ]) np.heaviside([-1.5, 0, 2.0], 1) array([ 0., 1., 1.])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L17009">view source</a></div></div><div class="public anchor" id="var-histogram"><h3>histogram</h3><div class="usage"><code>(histogram &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Compute the histogram of a set of data.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input data. The histogram is computed over the flattened array. bins : int or sequence of scalars or str, optional  If <code>bins</code> is an int, it defines the number of equal-width  bins in the given range (10, by default). If <code>bins</code> is a  sequence, it defines a monotonically increasing array of bin edges,  including the rightmost edge, allowing for non-uniform bin widths.</p>
<pre><code>.. versionadded:: 1.11.0

If `bins` is a string, it defines the method used to calculate the
optimal bin width, as defined by `histogram_bin_edges`.
</code></pre>
<p>range : (float, float), optional  The lower and upper range of the bins. If not provided, range  is simply <code>(a.min(), a.max())</code>. Values outside the range are  ignored. The first element of the range must be less than or  equal to the second. <code>range</code> affects the automatic bin  computation as well. While bin width is computed to be optimal  based on the actual data within <code>range</code>, the bin count will fill  the entire range including portions containing no data. normed : bool, optional</p>
<pre><code>.. deprecated:: 1.6.0

This is equivalent to the `density` argument, but produces incorrect
results for unequal bin widths. It should not be used.

.. versionchanged:: 1.15.0
    DeprecationWarnings are actually emitted.
</code></pre>
<p>weights : array_like, optional  An array of weights, of the same shape as <code>a</code>. Each value in  <code>a</code> only contributes its associated weight towards the bin count  (instead of 1). If <code>density</code> is True, the weights are  normalized, so that the integral of the density over the range  remains 1. density : bool, optional  If <code>False</code>, the result will contain the number of samples in  each bin. If <code>True</code>, the result is the value of the  probability <em>density</em> function at the bin, normalized such that  the <em>integral</em> over the range is 1. Note that the sum of the  histogram values will not be equal to 1 unless bins of unity  width are chosen; it is not a probability <em>mass</em> function.</p>
<pre><code>Overrides the ``normed`` keyword if given.
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>hist : array  The values of the histogram. See <code>density</code> and <code>weights</code> for a  description of the possible semantics. bin_edges : array of dtype float  Return the bin edges <code>(length(hist)+1)</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>histogramdd, bincount, searchsorted, digitize, histogram_bin_edges</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>All but the last (righthand-most) bin is half-open. In other words, if <code>bins</code> is::</p>
<p>[1, 2, 3, 4]</p>
<p>then the first bin is <code>[1, 2)</code> (including 1, but excluding 2) and the second <code>[2, 3)</code>. The last bin, however, is <code>[3, 4]</code>, which <em>includes</em> 4.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.histogram([1, 2, 1], bins=[0, 1, 2, 3]) (array([0, 2, 1]), array([0, 1, 2, 3])) np.histogram(np.arange(4), bins=np.arange(5), density=True) (array([0.25, 0.25, 0.25, 0.25]), array([0, 1, 2, 3, 4])) np.histogram(<a href="null">1, 2, 1], [1, 0, 1</a>, bins=[0,1,2,3]) (array([1, 4, 1]), array([0, 1, 2, 3]))</p>
      <p>a = np.arange(5) hist, bin_edges = np.histogram(a, density=True) hist array([0.5, 0. , 0.5, 0. , 0. , 0.5, 0. , 0.5, 0. , 0.5]) hist.sum() 2.4999999999999996 np.sum(hist * np.diff(bin_edges)) 1.0</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>.. versionadded:: 1.11.0</p>
<p>Automated Bin Selection Methods example, using 2 peak random data with 2000 points:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>import matplotlib.pyplot as plt rng = np.random.RandomState(10) # deterministic random data a = np.hstack((rng.normal(size=1000),  rng.normal(loc=5, scale=2, size=1000))) _ = plt.hist(a, bins=auto) # arguments are passed to np.histogram plt.title(Histogram with auto bins) Text(0.5, 1.0, Histogram with auto bins) plt.show()</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L15624">view source</a></div></div><div class="public anchor" id="var-histogram2d"><h3>histogram2d</h3><div class="usage"><code>(histogram2d &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Compute the bi-dimensional histogram of two data samples.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like, shape (N,)  An array containing the x coordinates of the points to be  histogrammed. y : array_like, shape (N,)  An array containing the y coordinates of the points to be  histogrammed. bins : int or array_like or [int, int] or [array, array], optional  The bin specification:</p>
<pre><code>  * If int, the number of bins for the two dimensions (nx=ny=bins).
  * If array_like, the bin edges for the two dimensions
    (x_edges=y_edges=bins).
  * If [int, int], the number of bins in each dimension
    (nx, ny = bins).
  * If [array, array], the bin edges in each dimension
    (x_edges, y_edges = bins).
  * A combination [int, array] or [array, int], where int
    is the number of bins and array is the bin edges.
</code></pre>
<p>range : array_like, shape(2,2), optional  The leftmost and rightmost edges of the bins along each dimension  (if not specified explicitly in the <code>bins</code> parameters):  <code>[[xmin, xmax], [ymin, ymax]]</code>. All values outside of this range  will be considered outliers and not tallied in the histogram. density : bool, optional  If False, the default, returns the number of samples in each bin.  If True, returns the probability <em>density</em> function at the bin,  <code>bin_count / sample_count / bin_area</code>. normed : bool, optional  An alias for the density argument that behaves identically. To avoid  confusion with the broken normed argument to <code>histogram</code>, <code>density</code>  should be preferred. weights : array_like, shape(N,), optional  An array of values <code>w_i</code> weighing each sample <code>(x_i, y_i)</code>.  Weights are normalized to 1 if <code>normed</code> is True. If <code>normed</code> is  False, the values of the returned histogram are equal to the sum of  the weights belonging to the samples falling into each bin.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>H : ndarray, shape(nx, ny)  The bi-dimensional histogram of samples <code>x</code> and <code>y</code>. Values in <code>x</code>  are histogrammed along the first dimension and values in <code>y</code> are  histogrammed along the second dimension. xedges : ndarray, shape(nx+1,)  The bin edges along the first dimension. yedges : ndarray, shape(ny+1,)  The bin edges along the second dimension.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>histogram : 1D histogram histogramdd : Multidimensional histogram</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>When <code>normed</code> is True, then the returned histogram is the sample density, defined such that the sum over bins of the product <code>bin_value * bin_area</code> is 1.</p>
<p>Please note that the histogram does not follow the Cartesian convention where <code>x</code> values are on the abscissa and <code>y</code> values on the ordinate axis. Rather, <code>x</code> is histogrammed along the first dimension of the array (vertical), and <code>y</code> along the second dimension of the array (horizontal). This ensures compatibility with <code>histogramdd</code>.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>from matplotlib.image import NonUniformImage import matplotlib.pyplot as plt</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Construct a 2-D histogram with variable bin width. First define the bin edges:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>xedges = [0, 1, 3, 5] yedges = [0, 2, 3, 4, 6]</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Next we create a histogram H with random bin content:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.random.normal(2, 1, 100) y = np.random.normal(1, 1, 100) H, xedges, yedges = np.histogram2d(x, y, bins=(xedges, yedges)) H = H.T # Let each row list bins with common y range.</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>:func:<code>imshow &lt;matplotlib.pyplot.imshow&gt;</code> can only display square bins:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>fig = plt.figure(figsize=(7, 3)) ax = fig.add_subplot(131, title=imshow: square bins) plt.imshow(H, interpolation=nearest, origin=low,  extent=[xedges[0], xedges[-1], yedges[0], yedges[-1]]) &lt;matplotlib.image.AxesImage object at 0x&gt;</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>:func:<code>pcolormesh &lt;matplotlib.pyplot.pcolormesh&gt;</code> can display actual edges:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>ax = fig.add_subplot(132, title=pcolormesh: actual edges,  aspect=equal) X, Y = np.meshgrid(xedges, yedges) ax.pcolormesh(X, Y, H) &lt;matplotlib.collections.QuadMesh object at 0x&gt;</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>:class:<code>NonUniformImage &lt;matplotlib.image.NonUniformImage&gt;</code> can be used to display actual bin edges with interpolation:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>ax = fig.add_subplot(133, title=NonUniformImage: interpolated,  aspect=equal, xlim=xedges<a href="null">0, -1</a>, ylim=yedges<a href="null">0, -1</a>) im = NonUniformImage(ax, interpolation=bilinear) xcenters = (xedges[:-1] + xedges[1:]) / 2 ycenters = (yedges[:-1] + yedges[1:]) / 2 im.set_data(xcenters, ycenters, H) ax.images.append(im) plt.show()</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L1916">view source</a></div></div><div class="public anchor" id="var-histogram_bin_edges"><h3>histogram_bin_edges</h3><div class="usage"><code>(histogram_bin_edges &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Function to calculate only the edges of the bins used by the <code>histogram</code> function.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input data. The histogram is computed over the flattened array. bins : int or sequence of scalars or str, optional  If <code>bins</code> is an int, it defines the number of equal-width  bins in the given range (10, by default). If <code>bins</code> is a  sequence, it defines the bin edges, including the rightmost  edge, allowing for non-uniform bin widths.</p>
<pre><code>If `bins` is a string from the list below, `histogram_bin_edges` will use
the method chosen to calculate the optimal bin width and
consequently the number of bins (see `Notes` for more detail on
the estimators) from the data that falls within the requested
range. While the bin width will be optimal for the actual data
in the range, the number of bins will be computed to fill the
entire range, including the empty portions. For visualisation,
using the 'auto' option is suggested. Weighted data is not
supported for automated bin size selection.

'auto'
    Maximum of the 'sturges' and 'fd' estimators. Provides good
    all around performance.

'fd' (Freedman Diaconis Estimator)
    Robust (resilient to outliers) estimator that takes into
    account data variability and data size.

'doane'
    An improved version of Sturges' estimator that works better
    with non-normal datasets.

'scott'
    Less robust estimator that that takes into account data
    variability and data size.

'stone'
    Estimator based on leave-one-out cross-validation estimate of
    the integrated squared error. Can be regarded as a generalization
    of Scott's rule.

'rice'
    Estimator does not take variability into account, only data
    size. Commonly overestimates number of bins required.

'sturges'
    R's default method, only accounts for data size. Only
    optimal for gaussian data and underestimates number of bins
    for large non-gaussian datasets.

'sqrt'
    Square root (of data size) estimator, used by Excel and
    other programs for its speed and simplicity.
</code></pre>
<p>range : (float, float), optional  The lower and upper range of the bins. If not provided, range  is simply <code>(a.min(), a.max())</code>. Values outside the range are  ignored. The first element of the range must be less than or  equal to the second. <code>range</code> affects the automatic bin  computation as well. While bin width is computed to be optimal  based on the actual data within <code>range</code>, the bin count will fill  the entire range including portions containing no data.</p>
<p>weights : array_like, optional  An array of weights, of the same shape as <code>a</code>. Each value in  <code>a</code> only contributes its associated weight towards the bin count  (instead of 1). This is currently not used by any of the bin estimators,  but may be in the future.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>bin_edges : array of dtype float  The edges to pass into <code>histogram</code></p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>histogram</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The methods to estimate the optimal number of bins are well founded in literature, and are inspired by the choices R provides for histogram visualisation. Note that having the number of bins proportional to :math:<code>n^{1/3}</code> is asymptotically optimal, which is why it appears in most estimators. These are simply plug-in methods that give good starting points for number of bins. In the equations below, :math:<code>h</code> is the binwidth and :math:<code>n_h</code> is the number of bins. All estimators that compute bin counts are recast to bin width using the <code>ptp</code> of the data. The final bin count is obtained from <code>np.round(np.ceil(range / h))</code>.</p>
<p>auto (maximum of the sturges and fd estimators)  A compromise to get a good value. For small datasets the Sturges  value will usually be chosen, while larger datasets will usually  default to FD. Avoids the overly conservative behaviour of FD  and Sturges for small and large datasets respectively.  Switchover point is usually :math:<code>a.size \approx 1000</code>.</p>
<p>fd (Freedman Diaconis Estimator)  .. math:: h = 2 \frac{IQR}{n^{1/3}}</p>
<pre><code>The binwidth is proportional to the interquartile range (IQR)
and inversely proportional to cube root of a.size. Can be too
conservative for small datasets, but is quite good for large
datasets. The IQR is very robust to outliers.
</code></pre>
<p>scott  .. math:: h = \sigma \sqrt[3]{\frac{24 * \sqrt{\pi}}{n}}</p>
<pre><code>The binwidth is proportional to the standard deviation of the
data and inversely proportional to cube root of ``x.size``. Can
be too conservative for small datasets, but is quite good for
large datasets. The standard deviation is not very robust to
outliers. Values are very similar to the Freedman-Diaconis
estimator in the absence of outliers.
</code></pre>
<p>rice  .. math:: n_h = 2n^{1/3}</p>
<pre><code>The number of bins is only proportional to cube root of
``a.size``. It tends to overestimate the number of bins and it
does not take into account data variability.
</code></pre>
<p>sturges  .. math:: n_h = \log _{2}n+1</p>
<pre><code>The number of bins is the base 2 log of ``a.size``.  This
estimator assumes normality of data and is too conservative for
larger, non-normal datasets. This is the default method in R's
``hist`` method.
</code></pre>
<p>doane  .. math:: n_h = 1 + \log_{2}(n) +  \log_{2}(1 + \frac{|g_1|}{\sigma_{g_1}})</p>
<pre><code>    g_1 = mean[(\frac{x - \mu}{\sigma})^3]

    \sigma_{g_1} = \sqrt{\frac{6(n - 2)}{(n + 1)(n + 3)}}

An improved version of Sturges' formula that produces better
estimates for non-normal datasets. This estimator attempts to
account for the skew of the data.
</code></pre>
<p>sqrt  .. math:: n_h = \sqrt n</p>
<pre><code>The simplest and fastest estimator. Only takes into account the
data size.
</code></pre>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>arr = np.array([0, 0, 0, 1, 2, 3, 3, 4, 5]) np.histogram_bin_edges(arr, bins=auto, range=(0, 1)) array([0. , 0.25, 0.5 , 0.75, 1. ]) np.histogram_bin_edges(arr, bins=2) array([0. , 2.5, 5. ])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>For consistency with histogram, an array of pre-computed bins is passed through unmodified:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.histogram_bin_edges(arr, [1, 2]) array([1, 2])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>This function allows one set of bins to be computed, and reused across multiple histograms:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>shared_bins = np.histogram_bin_edges(arr, bins=auto) shared_bins array([0., 1., 2., 3., 4., 5.])</p>
      <p>group_id = np.array([0, 1, 1, 0, 1, 1, 0, 1, 1]) hist_0, _ = np.histogram(arr[group_id == 0], bins=shared_bins) hist_1, _ = np.histogram(arr[group_id == 1], bins=shared_bins)</p>
      <p>hist_0; hist_1 array([1, 1, 0, 1, 0]) array([2, 0, 1, 1, 2])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Which gives more easily comparable results than using separate bins for each histogram:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>hist_0, bins_0 = np.histogram(arr[group_id == 0], bins=auto) hist_1, bins_1 = np.histogram(arr[group_id == 1], bins=auto) hist_0; hist_1 array([1, 1, 1]) array([2, 1, 1, 2]) bins_0; bins_1 array([0., 1., 2., 3.]) array([0. , 1.25, 2.5 , 3.75, 5. ])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L3186">view source</a></div></div><div class="public anchor" id="var-histogramdd"><h3>histogramdd</h3><div class="usage"><code>(histogramdd &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Compute the multidimensional histogram of some data.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>sample : (N, D) array, or (D, N) array_like  The data to be histogrammed.</p>
<pre><code>Note the unusual interpretation of sample when an array_like:

* When an array, each row is a coordinate in a D-dimensional space -
  such as ``histogramgramdd(np.array([p1, p2, p3]))``.
* When an array_like, each element is the list of values for single
  coordinate - such as ``histogramgramdd((X, Y, Z))``.

The first form should be preferred.
</code></pre>
<p>bins : sequence or int, optional  The bin specification:</p>
<pre><code>* A sequence of arrays describing the monotonically increasing bin
  edges along each dimension.
* The number of bins for each dimension (nx, ny, ... =bins)
* The number of bins for all dimensions (nx=ny=...=bins).
</code></pre>
<p>range : sequence, optional  A sequence of length D, each an optional (lower, upper) tuple giving  the outer bin edges to be used if the edges are not given explicitly in  <code>bins</code>.  An entry of None in the sequence results in the minimum and maximum  values being used for the corresponding dimension.  The default, None, is equivalent to passing a tuple of D None values. density : bool, optional  If False, the default, returns the number of samples in each bin.  If True, returns the probability <em>density</em> function at the bin,  <code>bin_count / sample_count / bin_volume</code>. normed : bool, optional  An alias for the density argument that behaves identically. To avoid  confusion with the broken normed argument to <code>histogram</code>, <code>density</code>  should be preferred. weights : (N,) array_like, optional  An array of values <code>w_i</code> weighing each sample <code>(x_i, y_i, z_i, ...)</code>.  Weights are normalized to 1 if normed is True. If normed is False,  the values of the returned histogram are equal to the sum of the  weights belonging to the samples falling into each bin.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>H : ndarray  The multidimensional histogram of sample x. See normed and weights  for the different possible semantics. edges : list  A list of D arrays describing the bin edges for each dimension.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>histogram: 1-D histogram histogram2d: 2-D histogram</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>r = np.random.randn(100,3) H, edges = np.histogramdd(r, bins = (5, 8, 4)) H.shape, edges[0].size, edges[1].size, edges[2].size ((5, 8, 4), 6, 9, 5)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L5110">view source</a></div></div><div class="public anchor" id="var-hsplit"><h3>hsplit</h3><div class="usage"><code>(hsplit &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Split an array into multiple sub-arrays horizontally (column-wise).</p>
<p>Please refer to the <code>split</code> documentation. <code>hsplit</code> is equivalent to <code>split</code> with <code>axis=1</code>, the array is always split along the second axis regardless of the array dimension.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>split : Split an array into multiple sub-arrays of equal size.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.arange(16.0).reshape(4, 4) x array(<a href="null"> 0.,   1.,   2.,   3.],
       [ 4.,   5.,   6.,   7.],
       [ 8.,   9.,  10.,  11.],
       [12.,  13.,  14.,  15.</a>) np.hsplit(x, 2) [array([[ 0., 1.],  [ 4., 5.],  [ 8., 9.],  [12., 13.]]),  array([[ 2., 3.],  [ 6., 7.],  [10., 11.],  [14., 15.]])] np.hsplit(x, np.array([3, 6])) [array([[ 0., 1., 2.],  [ 4., 5., 6.],  [ 8., 9., 10.],  [12., 13., 14.]]),  array([[ 3.],  [ 7.],  [11.],  [15.]]),  array([], shape=(4, 0), dtype=float64)]</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>With a higher dimensional array the split is still along the second axis.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.arange(8.0).reshape(2, 2, 2) x array(<a href="null">[0.,  1.],
        [2.,  3.</a>,  <a href="null">4.,  5.],
        [6.,  7.</a>]) np.hsplit(x, 2) [array([[[0., 1.]],  [[4., 5.]]]),  array([[[2., 3.]],  [[6., 7.]]])]</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L27302">view source</a></div></div><div class="public anchor" id="var-hstack"><h3>hstack</h3><div class="usage"><code>(hstack &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Stack arrays in sequence horizontally (column wise).</p>
<p>This is equivalent to concatenation along the second axis, except for 1-D arrays where it concatenates along the first axis. Rebuilds arrays divided by <code>hsplit</code>.</p>
<p>This function makes most sense for arrays with up to 3 dimensions. For instance, for pixel-data with a height (first axis), width (second axis), and r/g/b channels (third axis). The functions <code>concatenate</code>, <code>stack</code> and <code>block</code> provide more general stacking and concatenation operations.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>tup : sequence of ndarrays  The arrays must have the same shape along all but the second axis,  except 1-D arrays which can be any length.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>stacked : ndarray  The array formed by stacking the given arrays.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>stack : Join a sequence of arrays along a new axis. vstack : Stack arrays in sequence vertically (row wise). dstack : Stack arrays in sequence depth wise (along third axis). concatenate : Join a sequence of arrays along an existing axis. hsplit : Split array along second axis. block : Assemble arrays from blocks.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array((1,2,3)) b = np.array((2,3,4)) np.hstack((a,b)) array([1, 2, 3, 2, 3, 4]) a = np.array(<a href="null">1],[2],[3</a>) b = np.array(<a href="null">2],[3],[4</a>) np.hstack((a,b)) array(<a href="null">1, 2],
       [2, 3],
       [3, 4</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L25776">view source</a></div></div><div class="public anchor" id="var-hypot"><h3>hypot</h3><div class="usage"><code>(hypot self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>hypot(x1, x2, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Given the legs of a right triangle, return its hypotenuse.</p>
<p>Equivalent to <code>sqrt(x1**2 + x2**2)</code>, element-wise. If <code>x1</code> or <code>x2</code> is scalar_like (i.e., unambiguously cast-able to a scalar type), it is broadcast for use with each element of the other argument. (See Examples)</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x1, x2 : array_like  Leg of the triangle(s). If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output). out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>z : ndarray  The hypotenuse of the triangle(s).  This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.hypot(3*np.ones((3, 3)), 4*np.ones((3, 3))) array(<a href="null"> 5.,  5.,  5.],
       [ 5.,  5.,  5.],
       [ 5.,  5.,  5.</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Example showing broadcast of scalar_like argument:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.hypot(3*np.ones((3, 3)), [4]) array(<a href="null"> 5.,  5.,  5.],
       [ 5.,  5.,  5.],
       [ 5.,  5.,  5.</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L14943">view source</a></div></div><div class="public anchor" id="var-i0"><h3>i0</h3><div class="usage"><code>(i0 &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Modified Bessel function of the first kind, order 0.</p>
<p>Usually denoted :math:<code>I_0</code>. This function does broadcast, but will <em>not</em> up-cast int dtype arguments unless accompanied by at least one float or complex dtype argument (see Raises below).</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like, dtype float or complex  Argument of the Bessel function.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray, shape = x.shape, dtype = x.dtype  The modified Bessel function evaluated at each of the elements of <code>x</code>.</p>
<h2><a href="#raises" name="raises"></a>Raises</h2>
<p>TypeError: array cannot be safely cast to required type  If argument consists exclusively of int dtypes.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>scipy.special.i0, scipy.special.iv, scipy.special.ive</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The scipy implementation is recommended over this function: it is a proper ufunc written in C, and more than an order of magnitude faster.</p>
<p>We use the algorithm published by Clenshaw [1]_ and referenced by Abramowitz and Stegun [2]_, for which the function domain is partitioned into the two intervals [0,8] and (8,inf), and Chebyshev polynomial expansions are employed in each interval. Relative error on the domain [0,30] using IEEE arithmetic is documented [3]_ as having a peak of 5.8e-16 with an rms of 1.4e-16 (n = 30000).</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [1] C. W. Clenshaw, Chebyshev series for mathematical functions, in  <em>National Physical Laboratory Mathematical Tables</em>, vol. 5, London:  Her Majestys Stationery Office, 1962. .. [2] M. Abramowitz and I. A. Stegun, <em>Handbook of Mathematical  Functions</em>, 10th printing, New York: Dover, 1964, pp. 379.  <a href="http://www.math.sfu.ca/~cbm/aands/page_379.htm">http://www.math.sfu.ca/~cbm/aands/page_379.htm</a> .. [3] <a href="http://kobesearch.cpan.org/htdocs/Math-Cephes/Math/Cephes.html">http://kobesearch.cpan.org/htdocs/Math-Cephes/Math/Cephes.html</a></p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.i0(0.) array(1.0) # may vary np.i0([0., 1. + 2j]) array([ 1.00000000+0.j , 0.18785373+0.64616944j]) # may vary</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L13950">view source</a></div></div><div class="public anchor" id="var-identity"><h3>identity</h3><div class="usage"><code>(identity n &amp; [{dtype :dtype}])</code><code>(identity n)</code></div><div class="doc"><div class="markdown"><p>Return the identity array.</p>
<p>The identity array is a square array with ones on the main diagonal.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>n : int  Number of rows (and columns) in <code>n</code> x <code>n</code> output. dtype : data-type, optional  Data-type of the output. Defaults to <code>float</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  <code>n</code> x <code>n</code> array with its main diagonal set to one,  and all other elements 0.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.identity(3) array(<a href="null">1.,  0.,  0.],
       [0.,  1.,  0.],
       [0.,  0.,  1.</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L16898">view source</a></div></div><div class="public anchor" id="var-iinfo"><h3>iinfo</h3><div class="usage"><code>(iinfo self int_type)</code></div><div class="doc"><div class="markdown"><p>iinfo(type)</p>
<p>Machine limits for integer types.</p>
<h2><a href="#attributes" name="attributes"></a>Attributes</h2>
<p>bits : int  The number of bits occupied by the type. min : int  The smallest integer expressible by the type. max : int  The largest integer expressible by the type.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>int_type : integer type, dtype, or instance  The kind of integer data type to get information about.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>finfo : The equivalent for floating point data types.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>With types:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>ii16 = np.iinfo(np.int16) ii16.min -32768 ii16.max 32767 ii32 = np.iinfo(np.int32) ii32.min -2147483648 ii32.max 2147483647</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>With instances:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>ii32 = np.iinfo(np.int32(10)) ii32.min -2147483648 ii32.max 2147483647</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L21405">view source</a></div></div><div class="public anchor" id="var-imag"><h3>imag</h3><div class="usage"><code>(imag &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return the imaginary part of the complex argument.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>val : array_like  Input array.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray or scalar  The imaginary component of the complex argument. If <code>val</code> is real,  the type of <code>val</code> is used for the output. If <code>val</code> has complex  elements, the returned type is float.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>real, angle, real_if_close</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array([1+2j, 3+4j, 5+6j]) a.imag array([2., 4., 6.]) a.imag = np.array([8, 10, 12]) a array([1. +8.j, 3.+10.j, 5.+12.j]) np.imag(1 + 1j) 1.0</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L12504">view source</a></div></div><div class="public anchor" id="var-in1d"><h3>in1d</h3><div class="usage"><code>(in1d &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Test whether each element of a 1-D array is also present in a second array.</p>
<p>Returns a boolean array the same length as <code>ar1</code> that is True where an element of <code>ar1</code> is in <code>ar2</code> and False otherwise.</p>
<p>We recommend using :func:<code>isin</code> instead of <code>in1d</code> for new code.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>ar1 : (M,) array_like  Input array. ar2 : array_like  The values against which to test each value of <code>ar1</code>. assume_unique : bool, optional  If True, the input arrays are both assumed to be unique, which  can speed up the calculation. Default is False. invert : bool, optional  If True, the values in the returned array are inverted (that is,  False where an element of <code>ar1</code> is in <code>ar2</code> and True otherwise).  Default is False. <code>np.in1d(a, b, invert=True)</code> is equivalent  to (but is faster than) <code>np.invert(in1d(a, b))</code>.</p>
<pre><code>.. versionadded:: 1.8.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>in1d : (M,) ndarray, bool  The values <code>ar1[in1d]</code> are in <code>ar2</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>isin : Version of this function that preserves the  shape of ar1. numpy.lib.arraysetops : Module with a number of other functions for  performing set operations on arrays.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p><code>in1d</code> can be considered as an element-wise function version of the python keyword <code>in</code>, for 1-D sequences. <code>in1d(a, b)</code> is roughly equivalent to <code>np.array([item in b for item in a])</code>. However, this idea fails if <code>ar2</code> is a set, or similar (non-sequence) container: As <code>ar2</code> is converted to an array, in those cases <code>asarray(ar2)</code> is an object array rather than the expected array of contained values.</p>
<p>.. versionadded:: 1.4.0</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>test = np.array([0, 1, 2, 5, 0]) states = [0, 2] mask = np.in1d(test, states) mask array([ True, False, True, False, True]) test[mask] array([0, 2, 0]) mask = np.in1d(test, states, invert=True) mask array([False, True, False, True, False]) test[mask] array([1, 5])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L4898">view source</a></div></div><div class="public anchor" id="var-index_exp"><h3>index_exp</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>A nicer way to build up index tuples for arrays.</p>
<p>.. note::  Use one of the two predefined instances <code>index_exp</code> or <code>s_</code>  rather than directly using <code>IndexExpression</code>.</p>
<p>For any index combination, including slicing and axis insertion, <code>a[indices]</code> is the same as <code>a[np.index_exp[indices]]</code> for any array <code>a</code>. However, <code>np.index_exp[indices]</code> can be used anywhere in Python code and returns a tuple of slice objects that can be used in the construction of complex index expressions.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>maketuple : bool  If True, always returns a tuple.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>index_exp : Predefined instance that always returns a tuple:  <code>index_exp = IndexExpression(maketuple=True)</code>. s_ : Predefined instance without tuple conversion:  <code>s_ = IndexExpression(maketuple=False)</code>.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>You can do all this with <code>slice()</code> plus a few special objects, but theres a lot to remember and this version is simpler because it uses the standard array indexing syntax.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.s_[2::2] slice(2, None, 2) np.index_exp[2::2] (slice(2, None, 2),)</p>
      <p>np.array([0, 1, 2, 3, 4])[np.s_[2::2]] array([2, 4])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L18097">view source</a></div></div><div class="public anchor" id="var-indices"><h3>indices</h3><div class="usage"><code>(indices dimensions &amp; [{dtype :dtype, sparse :sparse}])</code><code>(indices dimensions &amp; [{dtype :dtype}])</code><code>(indices dimensions)</code></div><div class="doc"><div class="markdown"><p>Return an array representing the indices of a grid.</p>
<p>Compute an array where the subarrays contain index values 0, 1,  varying only along the corresponding axis.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>dimensions : sequence of ints  The shape of the grid. dtype : dtype, optional  Data type of the result. sparse : boolean, optional  Return a sparse representation of the grid instead of a dense  representation. Default is False.</p>
<pre><code>.. versionadded:: 1.17
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>grid : one ndarray or tuple of ndarrays  If sparse is False:  Returns one array of grid indices,  <code>grid.shape = (len(dimensions),) + tuple(dimensions)</code>.  If sparse is True:  Returns a tuple of arrays, with  <code>grid[i].shape = (1, ..., 1, dimensions[i], 1, ..., 1)</code> with  dimensions[i] in the ith place</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>mgrid, ogrid, meshgrid</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The output shape in the dense case is obtained by prepending the number of dimensions in front of the tuple of dimensions, i.e. if <code>dimensions</code> is a tuple <code>(r0, ..., rN-1)</code> of length <code>N</code>, the output shape is <code>(N, r0, ..., rN-1)</code>.</p>
<p>The subarrays <code>grid[k]</code> contains the N-D array of indices along the <code>k-th</code> axis. Explicitly::</p>
<pre><code>grid[k, i0, i1, ..., iN-1] = ik
</code></pre>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>grid = np.indices((2, 3)) grid.shape (2, 2, 3) grid[0] # row indices array(<a href="null">0, 0, 0],
       [1, 1, 1</a>) grid[1] # column indices array(<a href="null">0, 1, 2],
       [0, 1, 2</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The indices can be used as an index into an array.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.arange(20).reshape(5, 4) row, col = np.indices((2, 3)) x[row, col] array(<a href="null">0, 1, 2],
       [4, 5, 6</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Note that it would be more straightforward in the above example to extract the required elements directly with <code>x[:2, :3]</code>.</p>
<p>If sparse is set to true, the grid will be returned in a sparse representation.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>i, j = np.indices((2, 3), sparse=True) i.shape (2, 1) j.shape (1, 3) i # row indices array(<a href="null">0],
       [1</a>) j # column indices array(<a href="null">0, 1, 2</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L28529">view source</a></div></div><div class="public anchor" id="var-inexact"><h3>inexact</h3><div class="usage"><code>(inexact self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Abstract base class of all numeric scalar types with a (potentially) inexact representation of the values in its range, such as floating-point numbers.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L381">view source</a></div></div><div class="public anchor" id="var-Inf"><h3>Inf</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L24060">view source</a></div></div><div class="public anchor" id="var-inf"><h3>inf</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L4408">view source</a></div></div><div class="public anchor" id="var-Infinity"><h3>Infinity</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L14129">view source</a></div></div><div class="public anchor" id="var-info"><h3>info</h3><div class="usage"><code>(info &amp; [{object :object, maxwidth :maxwidth, output :output, toplevel :toplevel}])</code><code>(info &amp; [{object :object, maxwidth :maxwidth, output :output}])</code><code>(info &amp; [{object :object, maxwidth :maxwidth}])</code><code>(info &amp; [{object :object}])</code><code>(info)</code></div><div class="doc"><div class="markdown"><p>Get help information for a function, class, or module.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>object : object or str, optional  Input object or name to get information about. If <code>object</code> is a  numpy object, its docstring is given. If it is a string, available  modules are searched for matching objects. If None, information  about <code>info</code> itself is returned. maxwidth : int, optional  Printing width. output : file like object, optional  File like object that the output is written to, default is  <code>stdout</code>. The object has to be opened in w or a mode. toplevel : str, optional  Start search at this level.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>source, lookfor</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>When used interactively with an object, <code>np.info(obj)</code> is equivalent to <code>help(obj)</code> on the Python prompt or <code>obj?</code> on the IPython prompt.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.info(np.polyval) # doctest: +SKIP  polyval(p, x)  Evaluate the polynomial p at x.  </p>
    </blockquote>
  </blockquote>
</blockquote>
<p>When using a string for <code>object</code> it is possible to get multiple results.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.info(fft) # doctest: +SKIP  *** Found in numpy *** Core FFT routines   *** Found in numpy.fft ***  fft(a, n=None, axis=-1)   *** Repeat reference found in numpy.fft.fftpack ***  *** Total of 3 references found. ***</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L9162">view source</a></div></div><div class="public anchor" id="var-infty"><h3>infty</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L2739">view source</a></div></div><div class="public anchor" id="var-inner"><h3>inner</h3><div class="usage"><code>(inner &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>inner(a, b)</p>
<p>Inner product of two arrays.</p>
<p>Ordinary inner product of vectors for 1-D arrays (without complex conjugation), in higher dimensions a sum product over the last axes.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a, b : array_like  If <code>a</code> and <code>b</code> are nonscalar, their last dimensions must match.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  <code>out.shape = a.shape[:-1] + b.shape[:-1]</code></p>
<h2><a href="#raises" name="raises"></a>Raises</h2>
<p>ValueError  If the last dimension of <code>a</code> and <code>b</code> has different size.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>tensordot : Sum products over arbitrary axes. dot : Generalised matrix product, using second last dimension of <code>b</code>. einsum : Einstein summation convention.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>For vectors (1-D arrays) it computes the ordinary inner-product::</p>
<pre><code>np.inner(a, b) = sum(a[:]*b[:])
</code></pre>
<p>More generally, if <code>ndim(a) = r &gt; 0</code> and <code>ndim(b) = s &gt; 0</code>::</p>
<pre><code>np.inner(a, b) = np.tensordot(a, b, axes=(-1,-1))
</code></pre>
<p>or explicitly::</p>
<pre><code>np.inner(a, b)[i0,...,ir-1,j0,...,js-1]
     = sum(a[i0,...,ir-1,:]*b[j0,...,js-1,:])
</code></pre>
<p>In addition <code>a</code> or <code>b</code> may be scalars, in which case::</p>
<p>np.inner(a,b) = a*b</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>Ordinary inner product for vectors:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array([1,2,3]) b = np.array([0,1,0]) np.inner(a, b) 2</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>A multidimensional example:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.arange(24).reshape((2,3,4)) b = np.arange(4) np.inner(a, b) array(<a href="null"> 14,  38,  62],
       [ 86, 110, 134</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>An example where <code>b</code> is a scalar:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.inner(np.eye(2), 7) array(<a href="null">7., 0.],
       [0., 7.</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L22990">view source</a></div></div><div class="public anchor" id="var-insert"><h3>insert</h3><div class="usage"><code>(insert &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Insert values along the given axis before the given indices.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>arr : array_like  Input array. obj : int, slice or sequence of ints  Object that defines the index or indices before which <code>values</code> is  inserted.</p>
<pre><code>.. versionadded:: 1.8.0

Support for multiple insertions when `obj` is a single scalar or a
sequence with one element (similar to calling insert multiple
times).
</code></pre>
<p>values : array_like  Values to insert into <code>arr</code>. If the type of <code>values</code> is different  from that of <code>arr</code>, <code>values</code> is converted to the type of <code>arr</code>.  <code>values</code> should be shaped so that <code>arr[...,obj,...] = values</code>  is legal. axis : int, optional  Axis along which to insert <code>values</code>. If <code>axis</code> is None then <code>arr</code>  is flattened first.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  A copy of <code>arr</code> with <code>values</code> inserted. Note that <code>insert</code>  does not occur in-place: a new array is returned. If  <code>axis</code> is None, <code>out</code> is a flattened array.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>append : Append elements at the end of an array. concatenate : Join a sequence of arrays along an existing axis. delete : Delete elements from an array.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Note that for higher dimensional inserts <code>obj=0</code> behaves very different from <code>obj=[0]</code> just like <code>arr[:,0,:] = values</code> is different from <code>arr[:,[0],:] = values</code>.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array(<a href="null">1, 1], [2, 2], [3, 3</a>) a array(<a href="null">1, 1],
       [2, 2],
       [3, 3</a>) np.insert(a, 1, 5) array([1, 5, 1, , 2, 3, 3]) np.insert(a, 1, 5, axis=1) array(<a href="null">1, 5, 1],
       [2, 5, 2],
       [3, 5, 3</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Difference between sequence and scalars:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.insert(a, [1], <a href="null">1],[2],[3</a>, axis=1) array(<a href="null">1, 1, 1],
       [2, 2, 2],
       [3, 3, 3</a>) np.array_equal(np.insert(a, 1, [1, 2, 3], axis=1),  np.insert(a, [1], <a href="null">1],[2],[3</a>, axis=1)) True</p>
      <p>b = a.flatten() b array([1, 1, 2, 2, 3, 3]) np.insert(b, [2, 2], [5, 6]) array([1, 1, 5, , 2, 3, 3])</p>
      <p>np.insert(b, slice(2, 4), [5, 6]) array([1, 1, 5, , 2, 3, 3])</p>
      <p>np.insert(b, [2, 2], [7.13, False]) # type casting array([1, 1, 7, , 2, 3, 3])</p>
      <p>x = np.arange(8).reshape(2, 4) idx = (1, 3) np.insert(x, idx, 999, axis=1) array(<a href="null">  0, 999,   1,   2, 999,   3],
       [  4, 999,   5,   6, 999,   7</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L21809">view source</a></div></div><div class="public anchor" id="var-int"><h3>int</h3><div class="usage"><code>(int self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>int([x]) -&gt; integer int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by + or - and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>int(0b100, base=0) 4</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L710">view source</a></div></div><div class="public anchor" id="var-int0"><h3>int0</h3><div class="usage"><code>(int0 self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Signed integer type, compatible with Python <code>int</code> anc C <code>long</code>. Character code: <code>'l'</code>. Canonical name: <code>np.int_</code>. Alias <em>on this platform</em>: <code>np.int64</code>: 64-bit signed integer (-9223372036854775808 to 9223372036854775807). Alias <em>on this platform</em>: <code>np.intp</code>: Signed integer large enough to fit pointer, compatible with C <code>intptr_t</code>.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L22529">view source</a></div></div><div class="public anchor" id="var-int16"><h3>int16</h3><div class="usage"><code>(int16 self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Signed integer type, compatible with C <code>short</code>. Character code: <code>'h'</code>. Canonical name: <code>np.short</code>. Alias <em>on this platform</em>: <code>np.int16</code>: 16-bit signed integer (-32768 to 32767).</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L195">view source</a></div></div><div class="public anchor" id="var-int32"><h3>int32</h3><div class="usage"><code>(int32 self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Signed integer type, compatible with C <code>int</code>. Character code: <code>'i'</code>. Canonical name: <code>np.intc</code>. Alias <em>on this platform</em>: <code>np.int32</code>: 32-bit signed integer (-2147483648 to 2147483647).</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L5536">view source</a></div></div><div class="public anchor" id="var-int64"><h3>int64</h3><div class="usage"><code>(int64 self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Signed integer type, compatible with Python <code>int</code> anc C <code>long</code>. Character code: <code>'l'</code>. Canonical name: <code>np.int_</code>. Alias <em>on this platform</em>: <code>np.int64</code>: 64-bit signed integer (-9223372036854775808 to 9223372036854775807). Alias <em>on this platform</em>: <code>np.intp</code>: Signed integer large enough to fit pointer, compatible with C <code>intptr_t</code>.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L7604">view source</a></div></div><div class="public anchor" id="var-int8"><h3>int8</h3><div class="usage"><code>(int8 self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Signed integer type, compatible with C <code>char</code>. Character code: <code>'b'</code>. Canonical name: <code>np.byte</code>. Alias <em>on this platform</em>: <code>np.int8</code>: 8-bit signed integer (-128 to 127).</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L20131">view source</a></div></div><div class="public anchor" id="var-int_"><h3>int_</h3><div class="usage"><code>(int_ self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Signed integer type, compatible with Python <code>int</code> anc C <code>long</code>. Character code: <code>'l'</code>. Canonical name: <code>np.int_</code>. Alias <em>on this platform</em>: <code>np.int64</code>: 64-bit signed integer (-9223372036854775808 to 9223372036854775807). Alias <em>on this platform</em>: <code>np.intp</code>: Signed integer large enough to fit pointer, compatible with C <code>intptr_t</code>.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L19065">view source</a></div></div><div class="public anchor" id="var-int_asbuffer"><h3>int_asbuffer</h3><div class="usage"><code>(int_asbuffer self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L1593">view source</a></div></div><div class="public anchor" id="var-intc"><h3>intc</h3><div class="usage"><code>(intc self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Signed integer type, compatible with C <code>int</code>. Character code: <code>'i'</code>. Canonical name: <code>np.intc</code>. Alias <em>on this platform</em>: <code>np.int32</code>: 32-bit signed integer (-2147483648 to 2147483647).</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L5530">view source</a></div></div><div class="public anchor" id="var-integer"><h3>integer</h3><div class="usage"><code>(integer self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Abstract base class of all integer scalar types.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L20041">view source</a></div></div><div class="public anchor" id="var-interp"><h3>interp</h3><div class="usage"><code>(interp &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>One-dimensional linear interpolation.</p>
<p>Returns the one-dimensional piecewise linear interpolant to a function with given discrete data points (<code>xp</code>, <code>fp</code>), evaluated at <code>x</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  The x-coordinates at which to evaluate the interpolated values.</p>
<p>xp : 1-D sequence of floats  The x-coordinates of the data points, must be increasing if argument  <code>period</code> is not specified. Otherwise, <code>xp</code> is internally sorted after  normalizing the periodic boundaries with <code>xp = xp % period</code>.</p>
<p>fp : 1-D sequence of float or complex  The y-coordinates of the data points, same length as <code>xp</code>.</p>
<p>left : optional float or complex corresponding to fp  Value to return for <code>x &lt; xp[0]</code>, default is <code>fp[0]</code>.</p>
<p>right : optional float or complex corresponding to fp  Value to return for <code>x &gt; xp[-1]</code>, default is <code>fp[-1]</code>.</p>
<p>period : None or float, optional  A period for the x-coordinates. This parameter allows the proper  interpolation of angular x-coordinates. Parameters <code>left</code> and <code>right</code>  are ignored if <code>period</code> is specified.</p>
<pre><code>.. versionadded:: 1.10.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : float or complex (corresponding to fp) or ndarray  The interpolated values, same shape as <code>x</code>.</p>
<h2><a href="#raises" name="raises"></a>Raises</h2>
<p>ValueError  If <code>xp</code> and <code>fp</code> have different length  If <code>xp</code> or <code>fp</code> are not 1-D sequences  If <code>period == 0</code></p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The x-coordinate sequence is expected to be increasing, but this is not explicitly enforced. However, if the sequence <code>xp</code> is non-increasing, interpolation results are meaningless.</p>
<p>Note that, since NaN is unsortable, <code>xp</code> also cannot contain NaNs.</p>
<p>A simple check for <code>xp</code> being strictly increasing is::</p>
<pre><code>np.all(np.diff(xp) &gt; 0)
</code></pre>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>xp = [1, 2, 3] fp = [3, 2, 0] np.interp(2.5, xp, fp) 1.0 np.interp([0, 1, 1.5, 2.72, 3.14], xp, fp) array([3. , 3. , 2.5 , 0.56, 0. ]) UNDEF = -99.0 np.interp(3.14, xp, fp, right=UNDEF) -99.0</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Plot an interpolant to the sine function:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.linspace(0, 2*np.pi, 10) y = np.sin(x) xvals = np.linspace(0, 2*np.pi, 50) yinterp = np.interp(xvals, x, y) import matplotlib.pyplot as plt plt.plot(x, y, o) [&lt;matplotlib.lines.Line2D object at 0x&gt;] plt.plot(xvals, yinterp, -x) [&lt;matplotlib.lines.Line2D object at 0x&gt;] plt.show()</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Interpolation with periodic x-coordinates:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = [-180, -170, -185, 185, -10, -5, 0, 365] xp = [190, -190, 350, -350] fp = [5, 10, 3, 4] np.interp(x, xp, fp, period=360) array([7.5 , 5. , 8.75, 6.25, 3. , 3.25, 3.5 , 3.75])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Complex interpolation:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = [1.5, 4.0] xp = [2,3,5] fp = [1.0j, 0, 2+3j] np.interp(x, xp, fp) array([0.+1.j , 1.+1.5j])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L10582">view source</a></div></div><div class="public anchor" id="var-intersect1d"><h3>intersect1d</h3><div class="usage"><code>(intersect1d &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Find the intersection of two arrays.</p>
<p>Return the sorted, unique values that are in both of the input arrays.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>ar1, ar2 : array_like  Input arrays. Will be flattened if not already 1D. assume_unique : bool  If True, the input arrays are both assumed to be unique, which  can speed up the calculation. Default is False. return_indices : bool  If True, the indices which correspond to the intersection of the two  arrays are returned. The first instance of a value is used if there are  multiple. Default is False.</p>
<pre><code>.. versionadded:: 1.15.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>intersect1d : ndarray  Sorted 1D array of common and unique elements. comm1 : ndarray  The indices of the first occurrences of the common values in <code>ar1</code>.  Only provided if <code>return_indices</code> is True. comm2 : ndarray  The indices of the first occurrences of the common values in <code>ar2</code>.  Only provided if <code>return_indices</code> is True.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>numpy.lib.arraysetops : Module with a number of other functions for  performing set operations on arrays.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.intersect1d([1, 3, 4, 3], [3, 1, 2, 1]) array([1, 3])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>To intersect more than two arrays, use functools.reduce:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>from functools import reduce reduce(np.intersect1d, ([1, 3, 4, 3], [3, 1, 2, 1], [6, 3, 4, 2])) array([3])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>To return the indices of the values common to the input arrays along with the intersected values:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.array([1, 1, 2, 3, 4]) y = np.array([2, 1, 4, 6]) xy, x_ind, y_ind = np.intersect1d(x, y, return_indices=True) x_ind, y_ind (array([0, 2, 4]), array([1, 0, 2])) xy, x[x_ind], y[y_ind] (array([1, 2, 4]), array([1, 2, 4]), array([1, 2, 4]))</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L19570">view source</a></div></div><div class="public anchor" id="var-intp"><h3>intp</h3><div class="usage"><code>(intp self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Signed integer type, compatible with Python <code>int</code> anc C <code>long</code>. Character code: <code>'l'</code>. Canonical name: <code>np.int_</code>. Alias <em>on this platform</em>: <code>np.int64</code>: 64-bit signed integer (-9223372036854775808 to 9223372036854775807). Alias <em>on this platform</em>: <code>np.intp</code>: Signed integer large enough to fit pointer, compatible with C <code>intptr_t</code>.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L4070">view source</a></div></div><div class="public anchor" id="var-invert"><h3>invert</h3><div class="usage"><code>(invert self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>invert(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Compute bit-wise inversion, or bit-wise NOT, element-wise.</p>
<p>Computes the bit-wise NOT of the underlying binary representation of the integers in the input arrays. This ufunc implements the C/Python operator <code>~</code>.</p>
<p>For signed integer inputs, the twos complement is returned. In a twos-complement system negative numbers are represented by the twos complement of the absolute value. This is the most common method of representing signed integers on computers [1]_. A N-bit twos-complement system can represent every integer in the range :math:<code>-2^{N-1}</code> to :math:<code>+2^{N-1}-1</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Only integer and boolean types are handled. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray or scalar  Result.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>bitwise_and, bitwise_or, bitwise_xor logical_not binary_repr :  Return the binary representation of the input number as a string.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p><code>bitwise_not</code> is an alias for <code>invert</code>:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.bitwise_not is np.invert True</p>
    </blockquote>
  </blockquote>
</blockquote>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [1] Wikipedia, Twos complement,  <a href="https://en.wikipedia.org/wiki/Two's_complement">https://en.wikipedia.org/wiki/Two's_complement</a></p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>Weve seen that 13 is represented by <code>00001101</code>. The invert or bit-wise NOT of 13 is then:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.invert(np.array(13, dtype=np.uint8)) x 242 np.binary_repr(x, width=8) 11110010</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The result depends on the bit-width:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.invert(np.array(13, dtype=np.uint16)) x 65522 np.binary_repr(x, width=16) 1111111111110010</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>When using signed integer types the result is the twos complement of the result for the unsigned type:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.invert(np.array([13], dtype=np.int8)) array([-14], dtype=int8) np.binary_repr(-14, width=8) 11110010</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Booleans are accepted as well:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.invert(np.array([True, False])) array([False, True])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L2133">view source</a></div></div><div class="public anchor" id="var-ipmt"><h3>ipmt</h3><div class="usage"><code>(ipmt &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Compute the interest portion of a payment.</p>
<p>.. deprecated:: 1.18</p>
<p><code>ipmt</code> is deprecated; for details, see NEP 32 [1]_.  Use the corresponding function in the numpy-financial library,  <a href="https://pypi.org/project/numpy-financial">https://pypi.org/project/numpy-financial</a>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>rate : scalar or array_like of shape(M, )  Rate of interest as decimal (not per cent) per period per : scalar or array_like of shape(M, )  Interest paid against the loan changes during the life or the loan.  The <code>per</code> is the payment period to calculate the interest amount. nper : scalar or array_like of shape(M, )  Number of compounding periods pv : scalar or array_like of shape(M, )  Present value fv : scalar or array_like of shape(M, ), optional  Future value when : {{begin, 1}, {end, 0}}, {string, int}, optional  When payments are due (begin (1) or end (0)).  Defaults to {end, 0}.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  Interest portion of payment. If all input is scalar, returns a scalar  float. If any input is array_like, returns interest payment for each  input element. If multiple inputs are array_like, they all must have  the same shape.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>ppmt, pmt, pv</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The total payment is made up of payment against principal plus interest.</p>
<p><code>pmt = ppmt + ipmt</code></p>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [1] NumPy Enhancement Proposal (NEP) 32,  <a href="https://numpy.org/neps/nep-0032-remove-financial-functions.html">https://numpy.org/neps/nep-0032-remove-financial-functions.html</a></p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>What is the amortization schedule for a 1 year loan of $2500 at 8.24% interest per year compounded monthly?</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>principal = 2500.00</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The per variable represents the periods of the loan. Remember that financial equations start the period count at 1!</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>per = np.arange(1*12) + 1 ipmt = np.ipmt(0.0824/12, per, 1*12, principal) ppmt = np.ppmt(0.0824/12, per, 1*12, principal)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Each element of the sum of the ipmt and ppmt arrays should equal pmt.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>pmt = np.pmt(0.0824/12, 1*12, principal) np.allclose(ipmt + ppmt, pmt) True</p>
      <p>fmt = {0:2d} {1:8.2f} {2:8.2f} {3:8.2f} for payment in per:  index = payment - 1  principal = principal + ppmt[index]  print(fmt.format(payment, ppmt[index], ipmt[index], principal))  1 -200.58 -17.17 2299.42  2 -201.96 -15.79 2097.46  3 -203.35 -14.40 1894.11  4 -204.74 -13.01 1689.37  5 -206.15 -11.60 1483.22  6 -207.56 -10.18 1275.66  7 -208.99 -8.76 1066.67  8 -210.42 -7.32 856.25  9 -211.87 -5.88 644.38 10 -213.32 -4.42 431.05 11 -214.79 -2.96 216.26 12 -216.26 -1.49 -0.00</p>
      <p>interestpd = np.sum(ipmt) np.round(interestpd, 2) -112.98</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L9913">view source</a></div></div><div class="public anchor" id="var-irr"><h3>irr</h3><div class="usage"><code>(irr &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return the Internal Rate of Return (IRR).</p>
<p>.. deprecated:: 1.18</p>
<p><code>irr</code> is deprecated; for details, see NEP 32 [1]_.  Use the corresponding function in the numpy-financial library,  <a href="https://pypi.org/project/numpy-financial">https://pypi.org/project/numpy-financial</a>.</p>
<p>This is the average periodically compounded rate of return that gives a net present value of 0.0; for a more complete explanation, see Notes below.</p>
<p>:class:<code>decimal.Decimal</code> type is not supported.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>values : array_like, shape(N,)  Input cash flows per time period. By convention, net deposits  are negative and net withdrawals are positive. Thus, for  example, at least the first element of <code>values</code>, which represents  the initial investment, will typically be negative.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : float  Internal Rate of Return for periodic input values.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The IRR is perhaps best understood through an example (illustrated using np.irr in the Examples section below). Suppose one invests 100 units and then makes the following withdrawals at regular (fixed) intervals: 39, 59, 55, 20. Assuming the ending value is 0, ones 100 unit investment yields 173 units; however, due to the combination of compounding and the periodic withdrawals, the average rate of return is neither simply 0.73/4 nor (1.73)^0.25-1. Rather, it is the solution (for :math:<code>r</code>) of the equation:</p>
<p>.. math:: -100 + \frac{39}{1+r} + \frac{59}{(1+r)^2}  + \frac{55}{(1+r)^3} + \frac{20}{(1+r)^4} = 0</p>
<p>In general, for <code>values</code> :math:<code>= [v_0, v_1, ... v_M]</code>, irr is the solution of the equation: [2]_</p>
<p>.. math:: \sum_{t=0}^M{\frac{v_t}{(1+irr)^{t}}} = 0</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [1] NumPy Enhancement Proposal (NEP) 32,  <a href="https://numpy.org/neps/nep-0032-remove-financial-functions.html">https://numpy.org/neps/nep-0032-remove-financial-functions.html</a> .. [2] L. J. Gitman, Principles of Managerial Finance, Brief, 3rd ed.,  Addison-Wesley, 2003, pg. 348.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>round(np.irr([-100, 39, 59, 55, 20]), 5) 0.28095 round(np.irr([-100, 0, 0, 74]), 5) -0.0955 round(np.irr([-100, 100, 0, -7]), 5) -0.0833 round(np.irr([-100, 100, 0, 7]), 5) 0.06206 round(np.irr([-5, 10.5, 1, -8, 1]), 5) 0.0886</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L18661">view source</a></div></div><div class="public anchor" id="var-is_busday"><h3>is_busday</h3><div class="usage"><code>(is_busday &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>is_busday(dates, weekmask=1111100, holidays=None, busdaycal=None, out=None)</p>
<p>Calculates which of the given dates are valid days, and which are not.</p>
<p>.. versionadded:: 1.7.0</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>dates : array_like of datetime64[D]  The array of dates to process. weekmask : str or array_like of bool, optional  A seven-element array indicating which of Monday through Sunday are  valid days. May be specified as a length-seven list or array, like  [1,1,1,1,1,0,0]; a length-seven string, like 1111100; or a string  like Mon Tue Wed Thu Fri, made up of 3-character abbreviations for  weekdays, optionally separated by white space. Valid abbreviations  are: Mon Tue Wed Thu Fri Sat Sun holidays : array_like of datetime64[D], optional  An array of dates to consider as invalid dates. They may be  specified in any order, and NaT (not-a-time) dates are ignored.  This list is saved in a normalized form that is suited for  fast calculations of valid days. busdaycal : busdaycalendar, optional  A <code>busdaycalendar</code> object which specifies the valid days. If this  parameter is provided, neither weekmask nor holidays may be  provided. out : array of bool, optional  If provided, this array is filled with the result.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : array of bool  An array with the same shape as <code>dates</code>, containing True for  each valid day, and False for each invalid day.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>busdaycalendar: An object that specifies a custom set of valid days. busday_offset : Applies an offset counted in valid days. busday_count : Counts how many valid days are in a half-open date range.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <h1><a href="#the-weekdays-are-friday-saturday-and-monday" name="the-weekdays-are-friday-saturday-and-monday"></a>The weekdays are Friday, Saturday, and Monday</h1>
      <p> np.is_busday([2011-07-01, 2011-07-02, 2011-07-18],  holidays=[2011-07-01, 2011-07-04, 2011-07-17]) array([False, False, True])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L5768">view source</a></div></div><div class="public anchor" id="var-isclose"><h3>isclose</h3><div class="usage"><code>(isclose &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Returns a boolean array where two arrays are element-wise equal within a tolerance.</p>
<p>The tolerance values are positive, typically very small numbers. The relative difference (<code>rtol</code> * abs(<code>b</code>)) and the absolute difference <code>atol</code> are added together to compare against the absolute difference between <code>a</code> and <code>b</code>.</p>
<p>.. warning:: The default <code>atol</code> is not appropriate for comparing numbers  that are much smaller than one (see Notes).</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a, b : array_like  Input arrays to compare. rtol : float  The relative tolerance parameter (see Notes). atol : float  The absolute tolerance parameter (see Notes). equal_nan : bool  Whether to compare NaNs as equal. If True, NaNs in <code>a</code> will be  considered equal to NaNs in <code>b</code> in the output array.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : array_like  Returns a boolean array of where <code>a</code> and <code>b</code> are equal within the  given tolerance. If both <code>a</code> and <code>b</code> are scalars, returns a single  boolean value.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>allclose</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>.. versionadded:: 1.7.0</p>
<p>For finite values, isclose uses the following equation to test whether two floating point values are equivalent.</p>
<p>absolute(<code>a</code> - <code>b</code>) &lt;= (<code>atol</code> + <code>rtol</code> * absolute(<code>b</code>))</p>
<p>Unlike the built-in <code>math.isclose</code>, the above equation is not symmetric in <code>a</code> and <code>b</code>  it assumes <code>b</code> is the reference value  so that <code>isclose(a, b)</code> might be different from <code>isclose(b, a)</code>. Furthermore, the default value of atol is not zero, and is used to determine what small values should be considered close to zero. The default value is appropriate for expected values of order unity: if the expected values are significantly smaller than one, it can result in false positives. <code>atol</code> should be carefully selected for the use case at hand. A zero value for <code>atol</code> will result in <code>False</code> if either <code>a</code> or <code>b</code> is zero.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.isclose([1e10,1e-7], [1.00001e10,1e-8]) array([ True, False]) np.isclose([1e10,1e-8], [1.00001e10,1e-9]) array([ True, True]) np.isclose([1e10,1e-8], [1.0001e10,1e-9]) array([False, True]) np.isclose([1.0, np.nan], [1.0, np.nan]) array([ True, False]) np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True) array([ True, True]) np.isclose([1e-8, 1e-7], [0.0, 0.0]) array([ True, False]) np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0) array([False, False]) np.isclose([1e-10, 1e-10], [1e-20, 0.0]) array([ True, True]) np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0) array([False, True])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L22359">view source</a></div></div><div class="public anchor" id="var-iscomplex"><h3>iscomplex</h3><div class="usage"><code>(iscomplex &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Returns a bool array, where True if input element is complex.</p>
<p>What is tested is whether the input has a non-zero imaginary part, not if the input type is complex.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Input array.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray of bools  Output array.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>isreal iscomplexobj : Return True if x is a complex type or an array of complex  numbers.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.iscomplex([1+1j, 1+0j, 4.5, 3, 2, 2j]) array([ True, False, False, False, False, True])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L12036">view source</a></div></div><div class="public anchor" id="var-iscomplexobj"><h3>iscomplexobj</h3><div class="usage"><code>(iscomplexobj &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Check for a complex type or an array of complex numbers.</p>
<p>The type of the input is checked, not the value. Even if the input has an imaginary part equal to zero, <code>iscomplexobj</code> evaluates to True.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : any  The input can be of any type and shape.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>iscomplexobj : bool  The return value, True if <code>x</code> is of a complex type or has at least  one complex element.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>isrealobj, iscomplex</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.iscomplexobj(1) False np.iscomplexobj(1+0j) True np.iscomplexobj([3, 1+0j, True]) True</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L5276">view source</a></div></div><div class="public anchor" id="var-isfinite"><h3>isfinite</h3><div class="usage"><code>(isfinite self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>isfinite(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Test element-wise for finiteness (not infinity or not Not a Number).</p>
<p>The result is returned as a boolean array.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Input values. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray, bool  True where <code>x</code> is not positive infinity, negative infinity,  or NaN; false otherwise.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>isinf, isneginf, isposinf, isnan</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Not a Number, positive infinity and negative infinity are considered to be non-finite.</p>
<p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754). This means that Not a Number is not equivalent to infinity. Also that positive infinity is not equivalent to negative infinity. But infinity is equivalent to positive infinity. Errors result if the second argument is also supplied when <code>x</code> is a scalar input, or if first and second arguments have different shapes.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.isfinite(1) True np.isfinite(0) True np.isfinite(np.nan) False np.isfinite(np.inf) False np.isfinite(np.NINF) False np.isfinite([np.log(-1.),1.,np.log(0)]) array([False, True, False])</p>
      <p>x = np.array([-np.inf, 0., np.inf]) y = np.array([2, 2, 2]) np.isfinite(x, y) array([0, 1, 0]) y array([0, 1, 0])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L12890">view source</a></div></div><div class="public anchor" id="var-isfortran"><h3>isfortran</h3><div class="usage"><code>(isfortran a)</code></div><div class="doc"><div class="markdown"><p>Check if the array is Fortran contiguous but <em>not</em> C contiguous.</p>
<p>This function is obsolete and, because of changes due to relaxed stride checking, its return value for the same array may differ for versions of NumPy &gt;= 1.10.0 and previous versions. If you only want to check if an array is Fortran contiguous use <code>a.flags.f_contiguous</code> instead.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : ndarray  Input array.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>isfortran : bool  Returns True if the array is Fortran contiguous but <em>not</em> C contiguous.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>np.array allows to specify whether the array is written in C-contiguous order (last index varies the fastest), or FORTRAN-contiguous order in memory (first index varies the fastest).</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array(<a href="null">1, 2, 3], [4, 5, 6</a>, order=C) a array(<a href="null">1, 2, 3],
       [4, 5, 6</a>) np.isfortran(a) False</p>
      <p>b = np.array(<a href="null">1, 2, 3], [4, 5, 6</a>, order=F) b array(<a href="null">1, 2, 3],
       [4, 5, 6</a>) np.isfortran(b) True</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The transpose of a C-ordered array is a FORTRAN-ordered array.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array(<a href="null">1, 2, 3], [4, 5, 6</a>, order=C) a array(<a href="null">1, 2, 3],
       [4, 5, 6</a>) np.isfortran(a) False b = a.T b array(<a href="null">1, 4],
       [2, 5],
       [3, 6</a>) np.isfortran(b) True</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>C-ordered arrays evaluate as False even if they are also FORTRAN-ordered.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.isfortran(np.array([1, 2], order=F)) False</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L15738">view source</a></div></div><div class="public anchor" id="var-isin"><h3>isin</h3><div class="usage"><code>(isin &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Calculates <code>element in test_elements</code>, broadcasting over <code>element</code> only. Returns a boolean array of the same shape as <code>element</code> that is True where an element of <code>element</code> is in <code>test_elements</code> and False otherwise.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>element : array_like  Input array. test_elements : array_like  The values against which to test each value of <code>element</code>.  This argument is flattened if it is an array or array_like.  See notes for behavior with non-array-like parameters. assume_unique : bool, optional  If True, the input arrays are both assumed to be unique, which  can speed up the calculation. Default is False. invert : bool, optional  If True, the values in the returned array are inverted, as if  calculating <code>element not in test_elements</code>. Default is False.  <code>np.isin(a, b, invert=True)</code> is equivalent to (but faster  than) <code>np.invert(np.isin(a, b))</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>isin : ndarray, bool  Has the same shape as <code>element</code>. The values <code>element[isin]</code>  are in <code>test_elements</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>in1d : Flattened version of this function. numpy.lib.arraysetops : Module with a number of other functions for  performing set operations on arrays.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p><code>isin</code> is an element-wise function version of the python keyword <code>in</code>. <code>isin(a, b)</code> is roughly equivalent to <code>np.array([item in b for item in a])</code> if <code>a</code> and <code>b</code> are 1-D sequences.</p>
<p><code>element</code> and <code>test_elements</code> are converted to arrays if they are not already. If <code>test_elements</code> is a set (or other non-sequence collection) it will be converted to an object array with one element, rather than an array of the values contained in <code>test_elements</code>. This is a consequence of the <code>array</code> constructors way of handling non-sequence collections. Converting the set to a list usually gives the desired behavior.</p>
<p>.. versionadded:: 1.13.0</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>element = 2*np.arange(4).reshape((2, 2)) element array(<a href="null">0, 2],
       [4, 6</a>) test_elements = [1, 2, 4, 8] mask = np.isin(element, test_elements) mask array(<a href="null">False,  True],
       [ True, False</a>) element[mask] array([2, 4])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The indices of the matched values can be obtained with <code>nonzero</code>:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.nonzero(mask) (array([0, 1]), array([1, 0]))</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The test can also be inverted:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>mask = np.isin(element, test_elements, invert=True) mask array(<a href="null"> True, False],
       [False,  True</a>) element[mask] array([0, 6])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Because of how <code>array</code> handles sets, the following does not work as expected:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>test_set = {1, 2, 4, 8} np.isin(element, test_set) array(<a href="null">False, False],
       [False, False</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Casting the set to a list gives the expected result:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.isin(element, list(test_set)) array(<a href="null">False,  True],
       [ True, False</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L11101">view source</a></div></div><div class="public anchor" id="var-isinf"><h3>isinf</h3><div class="usage"><code>(isinf self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>isinf(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Test element-wise for positive or negative infinity.</p>
<p>Returns a boolean array of the same shape as <code>x</code>, True where <code>x ==
+/-inf</code>, otherwise False.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Input values out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : bool (scalar) or boolean ndarray  True where <code>x</code> is positive or negative infinity, false otherwise.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>isneginf, isposinf, isnan, isfinite</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754).</p>
<p>Errors result if the second argument is supplied when the first argument is a scalar, or if the first and second arguments have different shapes.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.isinf(np.inf) True np.isinf(np.nan) False np.isinf(np.NINF) True np.isinf([np.inf, -np.inf, 1.0, np.nan]) array([ True, True, False, False])</p>
      <p>x = np.array([-np.inf, 0., np.inf]) y = np.array([2, 2, 2]) np.isinf(x, y) array([1, 0, 1]) y array([1, 0, 1])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L2426">view source</a></div></div><div class="public anchor" id="var-isnan"><h3>isnan</h3><div class="usage"><code>(isnan self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>isnan(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Test element-wise for NaN and return result as a boolean array.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Input array. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray or bool  True where <code>x</code> is NaN, false otherwise.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>isinf, isneginf, isposinf, isfinite, isnat</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754). This means that Not a Number is not equivalent to infinity.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.isnan(np.nan) True np.isnan(np.inf) False np.isnan([np.log(-1.),1.,np.log(0)]) array([ True, False, False])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L10259">view source</a></div></div><div class="public anchor" id="var-isnat"><h3>isnat</h3><div class="usage"><code>(isnat self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>isnat(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Test element-wise for NaT (not a time) and return result as a boolean array.</p>
<p>.. versionadded:: 1.13.0</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Input array with datetime or timedelta data type. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray or bool  True where <code>x</code> is NaT, false otherwise.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>isnan, isinf, isneginf, isposinf, isfinite</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.isnat(np.datetime64(NaT)) True np.isnat(np.datetime64(2016-01-01)) False np.isnat(np.array([NaT, 2016-01-01], dtype=datetime64[ns])) array([ True, False])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L8951">view source</a></div></div><div class="public anchor" id="var-isneginf"><h3>isneginf</h3><div class="usage"><code>(isneginf &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Test element-wise for negative infinity, return result as bool array.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  The input array. out : array_like, optional  A boolean array with the same shape and type as <code>x</code> to store the  result.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  A boolean array with the same dimensions as the input.  If second argument is not supplied then a numpy boolean array is  returned with values True where the corresponding element of the  input is negative infinity and values False where the element of  the input is not negative infinity.</p>
<pre><code>If a second argument is supplied the result is stored there. If the
type of that array is a numeric type the result is represented as
zeros and ones, if the type is boolean then as False and True. The
return value `out` is then a reference to that array.
</code></pre>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>isinf, isposinf, isnan, isfinite</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754).</p>
<p>Errors result if the second argument is also supplied when x is a scalar input, if first and second arguments have different shapes, or if the first argument has complex values.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.isneginf(np.NINF) True np.isneginf(np.inf) False np.isneginf(np.PINF) False np.isneginf([-np.inf, 0., np.inf]) array([ True, False, False])</p>
      <p>x = np.array([-np.inf, 0., np.inf]) y = np.array([2, 2, 2]) np.isneginf(x, y) array([1, 0, 0]) y array([1, 0, 0])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L3486">view source</a></div></div><div class="public anchor" id="var-isposinf"><h3>isposinf</h3><div class="usage"><code>(isposinf &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Test element-wise for positive infinity, return result as bool array.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  The input array. y : array_like, optional  A boolean array with the same shape as <code>x</code> to store the result.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  A boolean array with the same dimensions as the input.  If second argument is not supplied then a boolean array is returned  with values True where the corresponding element of the input is  positive infinity and values False where the element of the input is  not positive infinity.</p>
<pre><code>If a second argument is supplied the result is stored there. If the
type of that array is a numeric type the result is represented as zeros
and ones, if the type is boolean then as False and True.
The return value `out` is then a reference to that array.
</code></pre>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>isinf, isneginf, isfinite, isnan</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754).</p>
<p>Errors result if the second argument is also supplied when x is a scalar input, if first and second arguments have different shapes, or if the first argument has complex values</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.isposinf(np.PINF) True np.isposinf(np.inf) True np.isposinf(np.NINF) False np.isposinf([-np.inf, 0., np.inf]) array([False, False, True])</p>
      <p>x = np.array([-np.inf, 0., np.inf]) y = np.array([2, 2, 2]) np.isposinf(x, y) array([0, 0, 1]) y array([0, 0, 1])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L22108">view source</a></div></div><div class="public anchor" id="var-isreal"><h3>isreal</h3><div class="usage"><code>(isreal &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Returns a bool array, where True if input element is real.</p>
<p>If element has complex type with zero complex part, the return value for that element is True.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Input array.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray, bool  Boolean array of same shape as <code>x</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>iscomplex isrealobj : Return True if x is not a complex type.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.isreal([1+1j, 1+0j, 4.5, 3, 2, 2j]) array([False, True, True, True, True, False])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L16806">view source</a></div></div><div class="public anchor" id="var-isrealobj"><h3>isrealobj</h3><div class="usage"><code>(isrealobj &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return True if x is a not complex type or an array of complex numbers.</p>
<p>The type of the input is checked, not the value. So even if the input has an imaginary part equal to zero, <code>isrealobj</code> evaluates to False if the data type is complex.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : any  The input can be of any type and shape.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : bool  The return value, False if <code>x</code> is of a complex type.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>iscomplexobj, isreal</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.isrealobj(1) True np.isrealobj(1+0j) False np.isrealobj([3, 1+0j, True]) False</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L25694">view source</a></div></div><div class="public anchor" id="var-isscalar"><h3>isscalar</h3><div class="usage"><code>(isscalar element)</code></div><div class="doc"><div class="markdown"><p>Returns True if the type of <code>element</code> is a scalar type.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>element : any  Input argument, can be of any type and shape.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>val : bool  True if <code>element</code> is a scalar type, False if it is not.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>ndim : Get the number of dimensions of an array</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>If you need a stricter way to identify a <em>numerical</em> scalar, use <code>isinstance(x, numbers.Number)</code>, as that returns <code>False</code> for most non-numerical elements such as strings.</p>
<p>In most cases <code>np.ndim(x) == 0</code> should be used instead of this function, as that will also return true for 0d arrays. This is how numpy overloads functions in the style of the <code>dx</code> arguments to <code>gradient</code> and the <code>bins</code> argument to <code>histogram</code>. Some key differences:</p>
<p>+++-+ | x |<code>isscalar(x)</code>|<code>np.ndim(x) == 0</code>| +======================================+===============+===================+ | PEP 3141 numeric objects (including | <code>True</code> | <code>True</code> | | builtins) | | | +++-+ | builtin string and buffer objects | <code>True</code> | <code>True</code> | +++-+ | other builtin objects, like | <code>False</code> | <code>True</code> | | <code>pathlib.Path</code>, <code>Exception</code>, | | | | the result of <code>re.compile</code> | | | +++-+ | third-party objects like | <code>False</code> | <code>True</code> | | <code>matplotlib.figure.Figure</code> | | | +++-+ | zero-dimensional numpy arrays | <code>False</code> | <code>True</code> | +++-+ | other numpy arrays | <code>False</code> | <code>False</code> | +++-+ | <code>list</code>, <code>tuple</code>, and other sequence | <code>False</code> | <code>False</code> | | objects | | | +++-+</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.isscalar(3.1) True np.isscalar(np.array(3.1)) False np.isscalar([3.1]) False np.isscalar(False) True np.isscalar(numpy) True</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>NumPy supports PEP 3141 numbers:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>from fractions import Fraction np.isscalar(Fraction(5, 17)) True from numbers import Number np.isscalar(Number()) True</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L857">view source</a></div></div><div class="public anchor" id="var-issctype"><h3>issctype</h3><div class="usage"><code>(issctype rep)</code></div><div class="doc"><div class="markdown"><p>Determines whether the given object represents a scalar data-type.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>rep : any  If <code>rep</code> is an instance of a scalar dtype, True is returned. If not,  False is returned.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : bool  Boolean result of check whether <code>rep</code> is a scalar dtype.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>issubsctype, issubdtype, obj2sctype, sctype2char</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.issctype(np.int32) True np.issctype(list) False np.issctype(1.1) False</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Strings are also a scalar type:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.issctype(np.dtype(str)) True</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L18149">view source</a></div></div><div class="public anchor" id="var-issubclass_"><h3>issubclass_</h3><div class="usage"><code>(issubclass_ arg1 arg2)</code></div><div class="doc"><div class="markdown"><p>Determine if a class is a subclass of a second class.</p>
<p><code>issubclass_</code> is equivalent to the Python built-in <code>issubclass</code>, except that it returns False instead of raising a TypeError if one of the arguments is not a class.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>arg1 : class  Input class. True is returned if <code>arg1</code> is a subclass of <code>arg2</code>. arg2 : class or tuple of classes.  Input class. If a tuple of classes, True is returned if <code>arg1</code> is a  subclass of any of the tuple elements.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : bool  Whether <code>arg1</code> is a subclass of <code>arg2</code> or not.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>issubsctype, issubdtype, issctype</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.issubclass_(np.int32, int) False # True on Python 2.7 np.issubclass_(np.int32, float) False</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L7674">view source</a></div></div><div class="public anchor" id="var-issubdtype"><h3>issubdtype</h3><div class="usage"><code>(issubdtype arg1 arg2)</code></div><div class="doc"><div class="markdown"><p>Returns True if first argument is a typecode lower/equal in type hierarchy.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>arg1, arg2 : dtype_like  dtype or string representing a typecode.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : bool</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>issubsctype, issubclass_ numpy.core.numerictypes : Overview of numpy type hierarchy.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.issubdtype(S1, np.string_) True np.issubdtype(np.float64, np.float32) False</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L26233">view source</a></div></div><div class="public anchor" id="var-issubsctype"><h3>issubsctype</h3><div class="usage"><code>(issubsctype arg1 arg2)</code></div><div class="doc"><div class="markdown"><p>Determine if the first argument is a subclass of the second argument.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>arg1, arg2 : dtype or dtype specifier  Data-types.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : bool  The result.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>issctype, issubdtype, obj2sctype</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.issubsctype(S8, str) False np.issubsctype(np.array([1]), int) True np.issubsctype(np.array([1]), float) False</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L21981">view source</a></div></div><div class="public anchor" id="var-iterable"><h3>iterable</h3><div class="usage"><code>(iterable y)</code></div><div class="doc"><div class="markdown"><p>Check whether or not an object can be iterated over.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>y : object  Input object.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>b : bool  Return <code>True</code> if the object has an iterator method or is a  sequence and <code>False</code> otherwise.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.iterable([1, 2, 3]) True np.iterable(2) False</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L21309">view source</a></div></div><div class="public anchor" id="var-ix_"><h3>ix_</h3><div class="usage"><code>(ix_ &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Construct an open mesh from multiple sequences.</p>
<p>This function takes N 1-D sequences and returns N outputs with N dimensions each, such that the shape is 1 in all but one dimension and the dimension with the non-unit shape value cycles through all N dimensions.</p>
<p>Using <code>ix_</code> one can quickly construct index arrays that will index the cross product. <code>a[np.ix_([1,3],[2,5])]</code> returns the array <code>[[a[1,2] a[1,5]], [a[3,2] a[3,5]]]</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>args : 1-D sequences  Each sequence should be of integer or boolean type.  Boolean sequences will be interpreted as boolean masks for the  corresponding dimension (equivalent to passing in  <code>np.nonzero(boolean_sequence)</code>).</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : tuple of ndarrays  N arrays with N dimensions each, with N the number of input  sequences. Together these arrays form an open mesh.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>ogrid, mgrid, meshgrid</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.arange(10).reshape(2, 5) a array(<a href="null">0, 1, 2, 3, 4],
       [5, 6, 7, 8, 9</a>) ixgrid = np.ix_([0, 1], [2, 4]) ixgrid (array(<a href="null">0],
       [1</a>), array(<a href="null">2, 4</a>)) ixgrid[0].shape, ixgrid[1].shape ((2, 1), (1, 2)) a[ixgrid] array(<a href="null">2, 4],
       [7, 9</a>)</p>
      <p>ixgrid = np.ix_([True, True], [2, 4]) a[ixgrid] array(<a href="null">2, 4],
       [7, 9</a>) ixgrid = np.ix_([True, True], [False, False, True, False, True]) a[ixgrid] array(<a href="null">2, 4],
       [7, 9</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L1533">view source</a></div></div><div class="public anchor" id="var-kaiser"><h3>kaiser</h3><div class="usage"><code>(kaiser M beta)</code></div><div class="doc"><div class="markdown"><p>Return the Kaiser window.</p>
<p>The Kaiser window is a taper formed by using a Bessel function.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>M : int  Number of points in the output window. If zero or less, an  empty array is returned. beta : float  Shape parameter for window.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : array  The window, with the maximum value normalized to one (the value  one appears only if the number of samples is odd).</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>bartlett, blackman, hamming, hanning</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The Kaiser window is defined as</p>
<p>.. math:: w(n) = I_0\left( \beta \sqrt{1-\frac{4n^2}{(M-1)^2}}  \right)/I_0(\beta)</p>
<p>with</p>
<p>.. math:: \quad -\frac{M-1}{2} \leq n \leq \frac{M-1}{2},</p>
<p>where :math:<code>I_0</code> is the modified zeroth-order Bessel function.</p>
<p>The Kaiser was named for Jim Kaiser, who discovered a simple approximation to the DPSS window based on Bessel functions. The Kaiser window is a very good approximation to the Digital Prolate Spheroidal Sequence, or Slepian window, which is the transform which maximizes the energy in the main lobe of the window relative to total energy.</p>
<p>The Kaiser can approximate many other windows by varying the beta parameter.</p>
<p>==== ======================= beta Window shape ==== ======================= 0 Rectangular 5 Similar to a Hamming 6 Similar to a Hanning 8.6 Similar to a Blackman ==== =======================</p>
<p>A beta value of 14 is probably a good starting point. Note that as beta gets large, the window narrows, and so the number of samples needs to be large enough to sample the increasingly narrow spike, otherwise NaNs will get returned.</p>
<p>Most references to the Kaiser window come from the signal processing literature, where it is used as one of many windowing functions for smoothing values. It is also known as an apodization (which means removing the foot, i.e. smoothing discontinuities at the beginning and end of the sampled signal) or tapering function.</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [1] J. F. Kaiser, Digital Filters - Ch 7 in Systems analysis by  digital computer, Editors: F.F. Kuo and J.F. Kaiser, p 218-285.  John Wiley and Sons, New York, (1966). .. [2] E.R. Kanasewich, Time Sequence Analysis in Geophysics, The  University of Alberta Press, 1975, pp. 177-178. .. [3] Wikipedia, Window function,  <a href="https://en.wikipedia.org/wiki/Window_function">https://en.wikipedia.org/wiki/Window_function</a></p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>import matplotlib.pyplot as plt np.kaiser(12, 14)  array([7.72686684e-06, 3.46009194e-03, 4.65200189e-02, # may vary  2.29737120e-01, 5.99885316e-01, 9.45674898e-01,  9.45674898e-01, 5.99885316e-01, 2.29737120e-01,  4.65200189e-02, 3.46009194e-03, 7.72686684e-06])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Plot the window and the frequency response:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>from numpy.fft import fft, fftshift window = np.kaiser(51, 14) plt.plot(window) [&lt;matplotlib.lines.Line2D object at 0x&gt;] plt.title(Kaiser window) Text(0.5, 1.0, Kaiser window) plt.ylabel(Amplitude) Text(0, 0.5, Amplitude) plt.xlabel(Sample) Text(0.5, 0, Sample) plt.show()</p>
      <p>plt.figure() </p><figure size="" 640x480="" with="" 0="" axes=""> A = fft(window, 2048) / 25.5 mag = np.abs(fftshift(A)) freq = np.linspace(-0.5, 0.5, len(A)) response = 20 * np.log10(mag) response = np.clip(response, -100, 100) plt.plot(freq, response) [&lt;matplotlib.lines.Line2D object at 0x&gt;] plt.title(Frequency response of Kaiser window) Text(0.5, 1.0, Frequency response of Kaiser window) plt.ylabel(Magnitude [dB]) Text(0, 0.5, Magnitude [dB]) plt.xlabel(Normalized frequency [cycles per sample]) Text(0.5, 0, Normalized frequency [cycles per sample]) plt.axis(tight) (-0.5, 0.5, -100.0, ) # may vary plt.show()<p></p>
    </figure></blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L8447">view source</a></div></div><div class="public anchor" id="var-kron"><h3>kron</h3><div class="usage"><code>(kron &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Kronecker product of two arrays.</p>
<p>Computes the Kronecker product, a composite array made of blocks of the second array scaled by the first.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a, b : array_like</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>outer : The outer product</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The function assumes that the number of dimensions of <code>a</code> and <code>b</code> are the same, if necessary prepending the smallest with ones. If <code>a.shape = (r0,r1,..,rN)</code> and <code>b.shape = (s0,s1,...,sN)</code>, the Kronecker product has shape <code>(r0*s0, r1*s1, ..., rN*SN)</code>. The elements are products of elements from <code>a</code> and <code>b</code>, organized explicitly by::</p>
<pre><code>kron(a,b)[k0,k1,...,kN] = a[i0,i1,...,iN] * b[j0,j1,...,jN]
</code></pre>
<p>where::</p>
<pre><code>kt = it * st + jt,  t = 0,...,N
</code></pre>
<p>In the common 2-D case (N=1), the block structure can be visualized::</p>
<pre><code>[[ a[0,0]*b,   a[0,1]*b,  ... , a[0,-1]*b  ],
 [  ...                              ...   ],
 [ a[-1,0]*b,  a[-1,1]*b, ... , a[-1,-1]*b ]]
</code></pre>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.kron([1,10,100], [5,6,7]) array([ 5, 6, 7, , 500, 600, 700]) np.kron([5,6,7], [1,10,100]) array([ 5, 50, 500, , 7, 70, 700])</p>
      <p>np.kron(np.eye(2), np.ones((2,2))) array(<a href="null">1.,  1.,  0.,  0.],
       [1.,  1.,  0.,  0.],
       [0.,  0.,  1.,  1.],
       [0.,  0.,  1.,  1.</a>)</p>
      <p>a = np.arange(100).reshape((2,5,2,5)) b = np.arange(24).reshape((2,3,4)) c = np.kron(a,b) c.shape (2, 10, 6, 20) I = (1,3,0,2) J = (0,2,1) J1 = (0,) + J # extend to ndim=4 S1 = (1,) + b.shape K = tuple(np.array(I) * np.array(S1) + np.array(J1)) c[K] == a[I]*b[J] True</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L284">view source</a></div></div><div class="public anchor" id="var-lcm"><h3>lcm</h3><div class="usage"><code>(lcm self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>lcm(x1, x2, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Returns the lowest common multiple of <code>|x1|</code> and <code>|x2|</code></p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x1, x2 : array_like, int  Arrays of values. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output).</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray or scalar  The lowest common multiple of the absolute value of the inputs  This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>gcd : The greatest common divisor</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.lcm(12, 20) 60 np.lcm.reduce([3, 12, 20]) 60 np.lcm.reduce([40, 12, 20]) 120 np.lcm(np.arange(6), 20) array([ 0, 20, 20, 60, 20, 20])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L5622">view source</a></div></div><div class="public anchor" id="var-ldexp"><h3>ldexp</h3><div class="usage"><code>(ldexp self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>ldexp(x1, x2, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Returns x1 * 2**x2, element-wise.</p>
<p>The mantissas <code>x1</code> and twos exponents <code>x2</code> are used to construct floating point numbers <code>x1 * 2**x2</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x1 : array_like  Array of multipliers. x2 : array_like, int  Array of twos exponents. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output). out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray or scalar  The result of <code>x1 * 2**x2</code>.  This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>frexp : Return (y1, y2) from <code>x = y1 * 2**y2</code>, inverse to <code>ldexp</code>.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Complex dtypes are not supported, they will raise a TypeError.</p>
<p><code>ldexp</code> is useful as the inverse of <code>frexp</code>, if used by itself it is more clear to simply use the expression <code>x1 * 2**x2</code>.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.ldexp(5, np.arange(4)) array([ 5., 10., 20., 40.], dtype=float16)</p>
      <p>x = np.arange(6) np.ldexp(*np.frexp(x)) array([ 0., 1., 2., 3., 4., 5.])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L22536">view source</a></div></div><div class="public anchor" id="var-left_shift"><h3>left_shift</h3><div class="usage"><code>(left_shift self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>left_shift(x1, x2, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Shift the bits of an integer to the left.</p>
<p>Bits are shifted to the left by appending <code>x2</code> 0s at the right of <code>x1</code>. Since the internal representation of numbers is in binary format, this operation is equivalent to multiplying <code>x1</code> by <code>2**x2</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x1 : array_like of integer type  Input values. x2 : array_like of integer type  Number of zeros to append to <code>x1</code>. Has to be non-negative.  If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output). out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : array of integer type  Return <code>x1</code> with bits shifted <code>x2</code> times to the left.  This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>right_shift : Shift the bits of an integer to the right. binary_repr : Return the binary representation of the input number  as a string.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.binary_repr(5) 101 np.left_shift(5, 2) 20 np.binary_repr(20) 10100</p>
      <p>np.left_shift(5, [1,2,3]) array([10, 20, 40])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L27574">view source</a></div></div><div class="public anchor" id="var-less"><h3>less</h3><div class="usage"><code>(less self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>less(x1, x2, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Return the truth value of (x1 &lt; x2) element-wise.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x1, x2 : array_like  Input arrays. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output). out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray or scalar  Output array, element-wise comparison of <code>x1</code> and <code>x2</code>.  Typically of type bool, unless <code>dtype=object</code> is passed.  This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>greater, less_equal, greater_equal, equal, not_equal</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.less([1, 2], [2, 2]) array([ True, False])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L20461">view source</a></div></div><div class="public anchor" id="var-less_equal"><h3>less_equal</h3><div class="usage"><code>(less_equal self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>less_equal(x1, x2, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Return the truth value of (x1 =&lt; x2) element-wise.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x1, x2 : array_like  Input arrays. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output). out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray or scalar  Output array, element-wise comparison of <code>x1</code> and <code>x2</code>.  Typically of type bool, unless <code>dtype=object</code> is passed.  This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>greater, less, greater_equal, equal, not_equal</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.less_equal([4, 2, 1], [2, 2, 2]) array([False, True, True])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L8406">view source</a></div></div><div class="public anchor" id="var-lexsort"><h3>lexsort</h3><div class="usage"><code>(lexsort &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>lexsort(keys, axis=-1)</p>
<p>Perform an indirect stable sort using a sequence of keys.</p>
<p>Given multiple sorting keys, which can be interpreted as columns in a spreadsheet, lexsort returns an array of integer indices that describes the sort order by multiple columns. The last key in the sequence is used for the primary sort order, the second-to-last key for the secondary sort order, and so on. The keys argument must be a sequence of objects that can be converted to arrays of the same shape. If a 2D array is provided for the keys argument, its rows are interpreted as the sorting keys and sorting is according to the last row, second last row etc.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>keys : (k, N) array or tuple containing k (N,)-shaped sequences  The <code>k</code> different columns to be sorted. The last column (or row if  <code>keys</code> is a 2D array) is the primary sort key. axis : int, optional  Axis to be indirectly sorted. By default, sort over the last axis.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>indices : (N,) ndarray of ints  Array of indices that sort the keys along the specified axis.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>argsort : Indirect sort. ndarray.sort : In-place sort. sort : Return a sorted copy of an array.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>Sort names: first by surname, then by name.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>surnames = (Hertz, Galilei, Hertz) first_names = (Heinrich, Galileo, Gustav) ind = np.lexsort((first_names, surnames)) ind array([1, 2, 0])</p>
      <p>[surnames[i] + ,  + first_names[i] for i in ind]
[Galilei, Galileo, Hertz, Gustav, Hertz, Heinrich]</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Sort two columns of numbers:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = [1,5,1,4,3,4,4] # First column b = [9,4,0,4,0,2,1] # Second column ind = np.lexsort((b,a)) # Sort by a, then by b ind array([2, 0, 4, 6, 5, 3, 1])</p>
      <p>[(a[i],b[i]) for i in ind]
[(1, 0), (1, 9), (3, 0), (4, 1), (4, 2), (4, 4), (5, 4)]</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Note that sorting is first according to the elements of <code>a</code>. Secondary sorting is according to the elements of <code>b</code>.</p>
<p>A normal <code>argsort</code> would have yielded:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>[(a[i],b[i]) for i in np.argsort(a)]
[(1, 9), (1, 0), (3, 0), (4, 4), (4, 2), (4, 1), (5, 4)]</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Structured arrays are sorted lexically by <code>argsort</code>:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.array([(1,9), (5,4), (1,0), (4,4), (3,0), (4,2), (4,1)],  dtype=np.dtype([(x, int), (y, int)]))</p>
      <p>np.argsort(x) # or np.argsort(x, order=(x, y)) array([2, 0, 4, 6, 5, 3, 1])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L16672">view source</a></div></div><div class="public anchor" id="var-lib"><h3>lib</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><strong>Note:</strong> almost all functions in the <code>numpy.lib</code> namespace are also present in the main <code>numpy</code> namespace. Please use the functions as <code>np.&lt;funcname&gt;</code> where possible.</p>
<p><code>numpy.lib</code> is mostly a space for implementing functions that dont belong in core or in another NumPy submodule with a clear purpose (e.g. <code>random</code>, <code>fft</code>, <code>linalg</code>, <code>ma</code>).</p>
<p>Most contains basic functions that are used by several submodules and are useful to have in the main name-space.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L20181">view source</a></div></div><div class="public anchor" id="var-linalg"><h3>linalg</h3><div class="usage"></div><div class="doc"><div class="markdown"><h1><code>numpy.linalg</code></h1>
<p>The NumPy linear algebra functions rely on BLAS and LAPACK to provide efficient low level implementations of standard linear algebra algorithms. Those libraries may be provided by NumPy itself using C versions of a subset of their reference implementations but, when possible, highly optimized libraries that take advantage of specialized processor functionality are preferred. Examples of such libraries are OpenBLAS, MKL (TM), and ATLAS. Because those libraries are multithreaded and processor dependent, environmental variables and external packages such as threadpoolctl may be needed to control the number of threads or specify the processor architecture.</p>
<ul>
  <li>OpenBLAS: <a href="https://www.openblas.net/">https://www.openblas.net/</a></li>
  <li>threadpoolctl: <a href="https://github.com/joblib/threadpoolctl">https://github.com/joblib/threadpoolctl</a></li>
</ul>
<p>Please note that the most-used linear algebra functions in NumPy are present in the main <code>numpy</code> namespace rather than in <code>numpy.linalg</code>. There are: <code>dot</code>, <code>vdot</code>, <code>inner</code>, <code>outer</code>, <code>matmul</code>, <code>tensordot</code>, <code>einsum</code>, <code>einsum_path</code> and <code>kron</code>.</p>
<p>Functions present in numpy.linalg are listed below.</p>
<h2><a href="#matrix-and-vector-products" name="matrix-and-vector-products"></a>Matrix and vector products</h2>
<p>multi_dot  matrix_power</p>
<h2><a href="#decompositions" name="decompositions"></a>Decompositions</h2>
<p>cholesky  qr  svd</p>
<h2><a href="#matrix-eigenvalues" name="matrix-eigenvalues"></a>Matrix eigenvalues</h2>
<p>eig  eigh  eigvals  eigvalsh</p>
<h2><a href="#norms-and-other-numbers" name="norms-and-other-numbers"></a>Norms and other numbers</h2>
<p>norm  cond  det  matrix_rank  slogdet</p>
<h2><a href="#solving-equations-and-inverting-matrices" name="solving-equations-and-inverting-matrices"></a>Solving equations and inverting matrices</h2>
<p>solve  tensorsolve  lstsq  inv  pinv  tensorinv</p>
<h2><a href="#exceptions" name="exceptions"></a>Exceptions</h2>
<p>LinAlgError</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L19742">view source</a></div></div><div class="public anchor" id="var-linspace"><h3>linspace</h3><div class="usage"><code>(linspace &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return evenly spaced numbers over a specified interval.</p>
<p>Returns <code>num</code> evenly spaced samples, calculated over the interval [<code>start</code>, <code>stop</code>].</p>
<p>The endpoint of the interval can optionally be excluded.</p>
<p>.. versionchanged:: 1.16.0  Non-scalar <code>start</code> and <code>stop</code> are now supported.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>start : array_like  The starting value of the sequence. stop : array_like  The end value of the sequence, unless <code>endpoint</code> is set to False.  In that case, the sequence consists of all but the last of <code>num + 1</code>  evenly spaced samples, so that <code>stop</code> is excluded. Note that the step  size changes when <code>endpoint</code> is False. num : int, optional  Number of samples to generate. Default is 50. Must be non-negative. endpoint : bool, optional  If True, <code>stop</code> is the last sample. Otherwise, it is not included.  Default is True. retstep : bool, optional  If True, return (<code>samples</code>, <code>step</code>), where <code>step</code> is the spacing  between samples. dtype : dtype, optional  The type of the output array. If <code>dtype</code> is not given, infer the data  type from the other input arguments.</p>
<pre><code>.. versionadded:: 1.9.0
</code></pre>
<p>axis : int, optional  The axis in the result to store the samples. Relevant only if start  or stop are array-like. By default (0), the samples will be along a  new axis inserted at the beginning. Use -1 to get an axis at the end.</p>
<pre><code>.. versionadded:: 1.16.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>samples : ndarray  There are <code>num</code> equally spaced samples in the closed interval  <code>[start, stop]</code> or the half-open interval <code>[start, stop)</code>  (depending on whether <code>endpoint</code> is True or False). step : float, optional  Only returned if <code>retstep</code> is True</p>
<pre><code>Size of spacing between samples.
</code></pre>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>arange : Similar to <code>linspace</code>, but uses a step size (instead of the  number of samples). geomspace : Similar to <code>linspace</code>, but with numbers spaced evenly on a log  scale (a geometric progression). logspace : Similar to <code>geomspace</code>, but with the end points specified as  logarithms.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.linspace(2.0, 3.0, num=5) array([2. , 2.25, 2.5 , 2.75, 3. ]) np.linspace(2.0, 3.0, num=5, endpoint=False) array([2. , 2.2, 2.4, 2.6, 2.8]) np.linspace(2.0, 3.0, num=5, retstep=True) (array([2. , 2.25, 2.5 , 2.75, 3. ]), 0.25)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Graphical illustration:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>import matplotlib.pyplot as plt N = 8 y = np.zeros(N) x1 = np.linspace(0, 10, N, endpoint=True) x2 = np.linspace(0, 10, N, endpoint=False) plt.plot(x1, y, o) [&lt;matplotlib.lines.Line2D object at 0x&gt;] plt.plot(x2, y + 0.5, o) [&lt;matplotlib.lines.Line2D object at 0x&gt;] plt.ylim([-0.5, 1]) (-0.5, 1) plt.show()</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L9332">view source</a></div></div><div class="public anchor" id="var-little_endian"><h3>little_endian</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L25024">view source</a></div></div><div class="public anchor" id="var-load"><h3>load</h3><div class="usage"><code>(load file &amp; [{mmap_mode :mmap_mode, allow_pickle :allow_pickle, fix_imports :fix_imports, encoding :encoding}])</code><code>(load file &amp; [{mmap_mode :mmap_mode, allow_pickle :allow_pickle, fix_imports :fix_imports}])</code><code>(load file &amp; [{mmap_mode :mmap_mode, allow_pickle :allow_pickle}])</code><code>(load file &amp; [{mmap_mode :mmap_mode}])</code><code>(load file)</code></div><div class="doc"><div class="markdown"><p>Load arrays or pickled objects from <code>.npy</code>, <code>.npz</code> or pickled files.</p>
<p>.. warning:: Loading files that contain object arrays uses the <code>pickle</code>  module, which is not secure against erroneous or maliciously  constructed data. Consider passing <code>allow_pickle=False</code> to  load data that is known not to contain object arrays for the  safer handling of untrusted sources.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>file : file-like object, string, or pathlib.Path  The file to read. File-like objects must support the  <code>seek()</code> and <code>read()</code> methods. Pickled files require that the  file-like object support the <code>readline()</code> method as well. mmap_mode : {None, r+, r, w+, c}, optional  If not None, then memory-map the file, using the given mode (see  <code>numpy.memmap</code> for a detailed description of the modes). A  memory-mapped array is kept on disk. However, it can be accessed  and sliced like any ndarray. Memory mapping is especially useful  for accessing small fragments of large files without reading the  entire file into memory. allow_pickle : bool, optional  Allow loading pickled object arrays stored in npy files. Reasons for  disallowing pickles include security, as loading pickled data can  execute arbitrary code. If pickles are disallowed, loading object  arrays will fail. Default: False</p>
<pre><code>.. versionchanged:: 1.16.3
    Made default False in response to CVE-2019-6446.
</code></pre>
<p>fix_imports : bool, optional  Only useful when loading Python 2 generated pickled files on Python 3,  which includes npy/npz files containing object arrays. If <code>fix_imports</code>  is True, pickle will try to map the old Python 2 names to the new names  used in Python 3. encoding : str, optional  What encoding to use when reading Python 2 strings. Only useful when  loading Python 2 generated pickled files in Python 3, which includes  npy/npz files containing object arrays. Values other than latin1,  ASCII, and bytes are not allowed, as they can corrupt numerical  data. Default: ASCII</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>result : array, tuple, dict, etc.  Data stored in the file. For <code>.npz</code> files, the returned instance  of NpzFile class must be closed to avoid leaking file descriptors.</p>
<h2><a href="#raises" name="raises"></a>Raises</h2>
<p>IOError  If the input file does not exist or cannot be read. ValueError  The file contains an object array, but allow_pickle=False given.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>save, savez, savez_compressed, loadtxt memmap : Create a memory-map to an array stored in a file on disk. lib.format.open_memmap : Create or load a memory-mapped <code>.npy</code> file.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<ul>
  <li>If the file contains pickle data, then whatever object is stored  in the pickle is returned.</li>
  <li>If the file is a <code>.npy</code> file, then a single array is returned.</li>
  <li>If the file is a <code>.npz</code> file, then a dictionary-like object is  returned, containing <code>{filename: array}</code> key-value pairs, one for  each file in the archive.</li>
  <li>If the file is a <code>.npz</code> file, the returned value supports the  context manager protocol in a similar fashion to the open function::
    <p>with load(foo.npz) as data:  a = data[a]</p>
  </li>
</ul>
<p>The underlying file descriptor is closed when exiting the with  block.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>Store data to disk, and load it again:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.save(/tmp/123, np.array(<a href="null">1, 2, 3], [4, 5, 6</a>)) np.load(/tmp/123.npy) array(<a href="null">1, 2, 3],
       [4, 5, 6</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Store compressed data to disk, and load it again:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a=np.array(<a href="null">1, 2, 3], [4, 5, 6</a>) b=np.array([1, 2]) np.savez(/tmp/123.npz, a=a, b=b) data = np.load(/tmp/123.npz) data[a] array(<a href="null">1, 2, 3],
       [4, 5, 6</a>) data[b] array([1, 2]) data.close()</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Mem-map the stored array, and then access the second row directly from disk:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>X = np.load(/tmp/123.npy, mmap_mode=r) X[1, :] memmap([4, 5, 6])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L7359">view source</a></div></div><div class="public anchor" id="var-loads"><h3>loads</h3><div class="usage"><code>(loads &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L18867">view source</a></div></div><div class="public anchor" id="var-loadtxt"><h3>loadtxt</h3><div class="usage"><code>(loadtxt fname &amp; [{max_rows :max_rows, encoding :encoding, ndmin :ndmin, dtype :dtype, comments :comments, unpack :unpack, converters :converters, delimiter :delimiter, skiprows :skiprows, usecols :usecols}])</code><code>(loadtxt fname &amp; [{encoding :encoding, ndmin :ndmin, dtype :dtype, comments :comments, unpack :unpack, converters :converters, delimiter :delimiter, skiprows :skiprows, usecols :usecols}])</code><code>(loadtxt fname &amp; [{dtype :dtype, comments :comments, delimiter :delimiter, converters :converters, skiprows :skiprows, usecols :usecols, unpack :unpack, ndmin :ndmin}])</code><code>(loadtxt fname &amp; [{dtype :dtype, comments :comments, delimiter :delimiter, converters :converters, skiprows :skiprows, usecols :usecols, unpack :unpack}])</code><code>(loadtxt fname &amp; [{dtype :dtype, comments :comments, delimiter :delimiter, converters :converters, skiprows :skiprows, usecols :usecols}])</code><code>(loadtxt fname &amp; [{dtype :dtype, comments :comments, delimiter :delimiter, converters :converters, skiprows :skiprows}])</code><code>(loadtxt fname &amp; [{dtype :dtype, comments :comments, delimiter :delimiter, converters :converters}])</code><code>(loadtxt fname &amp; [{dtype :dtype, comments :comments, delimiter :delimiter}])</code><code>(loadtxt fname &amp; [{dtype :dtype, comments :comments}])</code><code>(loadtxt fname &amp; [{dtype :dtype}])</code><code>(loadtxt fname)</code></div><div class="doc"><div class="markdown"><p>Load data from a text file.</p>
<p>Each row in the text file must have the same number of values.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>fname : file, str, or pathlib.Path  File, filename, or generator to read. If the filename extension is  <code>.gz</code> or <code>.bz2</code>, the file is first decompressed. Note that  generators should return byte strings. dtype : data-type, optional  Data-type of the resulting array; default: float. If this is a  structured data-type, the resulting array will be 1-dimensional, and  each row will be interpreted as an element of the array. In this  case, the number of columns used must match the number of fields in  the data-type. comments : str or sequence of str, optional  The characters or list of characters used to indicate the start of a  comment. None implies no comments. For backwards compatibility, byte  strings will be decoded as latin1. The default is #. delimiter : str, optional  The string used to separate values. For backwards compatibility, byte  strings will be decoded as latin1. The default is whitespace. converters : dict, optional  A dictionary mapping column number to a function that will parse the  column string into the desired value. E.g., if column 0 is a date  string: <code>converters = {0: datestr2num}</code>. Converters can also be  used to provide a default value for missing data (but see also  <code>genfromtxt</code>): <code>converters = {3: lambda s: float(s.strip() or 0)}</code>.  Default: None. skiprows : int, optional  Skip the first <code>skiprows</code> lines, including comments; default: 0. usecols : int or sequence, optional  Which columns to read, with 0 being the first. For example,  <code>usecols = (1,4,5)</code> will extract the 2nd, 5th and 6th columns.  The default, None, results in all columns being read.</p>
<pre><code>.. versionchanged:: 1.11.0
    When a single column has to be read it is possible to use
    an integer instead of a tuple. E.g ``usecols = 3`` reads the
    fourth column the same way as ``usecols = (3,)`` would.
</code></pre>
<p>unpack : bool, optional  If True, the returned array is transposed, so that arguments may be  unpacked using <code>x, y, z = loadtxt(...)</code>. When used with a structured  data-type, arrays are returned for each field. Default is False. ndmin : int, optional  The returned array will have at least <code>ndmin</code> dimensions.  Otherwise mono-dimensional axes will be squeezed.  Legal values: 0 (default), 1 or 2.</p>
<pre><code>.. versionadded:: 1.6.0
</code></pre>
<p>encoding : str, optional  Encoding used to decode the inputfile. Does not apply to input streams.  The special value bytes enables backward compatibility workarounds  that ensures you receive byte arrays as results if possible and passes  latin1 encoded strings to converters. Override this value to receive  unicode arrays and pass strings as input to converters. If set to None  the system default is used. The default value is bytes.</p>
<pre><code>.. versionadded:: 1.14.0
</code></pre>
<p>max_rows : int, optional  Read <code>max_rows</code> lines of content after <code>skiprows</code> lines. The default  is to read all the lines.</p>
<pre><code>.. versionadded:: 1.16.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  Data read from the text file.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>load, fromstring, fromregex genfromtxt : Load data with missing values handled as specified. scipy.io.loadmat : reads MATLAB data files</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>This function aims to be a fast reader for simply formatted files. The <code>genfromtxt</code> function provides more sophisticated handling of, e.g., lines with missing values.</p>
<p>.. versionadded:: 1.10.0</p>
<p>The strings produced by the Python float.hex method can be used as input for floats.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>from io import StringIO # StringIO behaves like a file object c = StringIO(u0 1\n2 3) np.loadtxt(c) array(<a href="null">0., 1.],
       [2., 3.</a>)</p>
      <p>d = StringIO(uM 21 72\nF 35 58) np.loadtxt(d, dtype={names: (gender, age, weight),  formats: (S1, i4, f4)}) array([(bM, 21, 72.), (bF, 35, 58.)],  dtype=[(gender, S1), (age, &lt;i4), (weight, &lt;f4)])</p>
      <p>c = StringIO(u1,0,2\n3,0,4) x, y = np.loadtxt(c, delimiter=,, usecols=(0, 2), unpack=True) x array([1., 3.]) y array([2., 4.])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L6922">view source</a></div></div><div class="public anchor" id="var-log"><h3>log</h3><div class="usage"><code>(log self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>log(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Natural logarithm, element-wise.</p>
<p>The natural logarithm <code>log</code> is the inverse of the exponential function, so that <code>log(exp(x)) = x</code>. The natural logarithm is logarithm in base <code>e</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Input value. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray  The natural logarithm of <code>x</code>, element-wise.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>log10, log2, log1p, emath.log</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Logarithm is a multivalued function: for each <code>x</code> there is an infinite number of <code>z</code> such that <code>exp(z) = x</code>. The convention is to return the <code>z</code> whose imaginary part lies in <code>[-pi, pi]</code>.</p>
<p>For real-valued input data types, <code>log</code> always returns real output. For each value that cannot be expressed as a real number or infinity, it yields <code>nan</code> and sets the <code>invalid</code> floating point error flag.</p>
<p>For complex-valued input, <code>log</code> is a complex analytical function that has a branch cut <code>[-inf, 0]</code> and is continuous from above on it. <code>log</code> handles the floating-point negative zero as an infinitesimal negative number, conforming to the C99 standard.</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [1] M. Abramowitz and I.A. Stegun, Handbook of Mathematical Functions,  10th printing, 1964, pp. 67. <a href="http://www.math.sfu.ca/~cbm/aands/">http://www.math.sfu.ca/~cbm/aands/</a> .. [2] Wikipedia, Logarithm. <a href="https://en.wikipedia.org/wiki/Logarithm">https://en.wikipedia.org/wiki/Logarithm</a></p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.log([1, np.e, np.e**2, 0]) array([ 0., 1., 2., -Inf])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L12962">view source</a></div></div><div class="public anchor" id="var-log10"><h3>log10</h3><div class="usage"><code>(log10 self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>log10(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Return the base 10 logarithm of the input array, element-wise.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Input values. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray  The logarithm to the base 10 of <code>x</code>, element-wise. NaNs are  returned where x is negative.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>emath.log10</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Logarithm is a multivalued function: for each <code>x</code> there is an infinite number of <code>z</code> such that <code>10**z = x</code>. The convention is to return the <code>z</code> whose imaginary part lies in <code>[-pi, pi]</code>.</p>
<p>For real-valued input data types, <code>log10</code> always returns real output. For each value that cannot be expressed as a real number or infinity, it yields <code>nan</code> and sets the <code>invalid</code> floating point error flag.</p>
<p>For complex-valued input, <code>log10</code> is a complex analytical function that has a branch cut <code>[-inf, 0]</code> and is continuous from above on it. <code>log10</code> handles the floating-point negative zero as an infinitesimal negative number, conforming to the C99 standard.</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [1] M. Abramowitz and I.A. Stegun, Handbook of Mathematical Functions,  10th printing, 1964, pp. 67. <a href="http://www.math.sfu.ca/~cbm/aands/">http://www.math.sfu.ca/~cbm/aands/</a> .. [2] Wikipedia, Logarithm. <a href="https://en.wikipedia.org/wiki/Logarithm">https://en.wikipedia.org/wiki/Logarithm</a></p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.log10([1e-15, -3.]) array([-15., nan])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L17394">view source</a></div></div><div class="public anchor" id="var-log1p"><h3>log1p</h3><div class="usage"><code>(log1p self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>log1p(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Return the natural logarithm of one plus the input array, element-wise.</p>
<p>Calculates <code>log(1 + x)</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Input values. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray  Natural logarithm of <code>1 + x</code>, element-wise.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>expm1 : <code>exp(x) - 1</code>, the inverse of <code>log1p</code>.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>For real-valued input, <code>log1p</code> is accurate also for <code>x</code> so small that <code>1 + x == 1</code> in floating-point accuracy.</p>
<p>Logarithm is a multivalued function: for each <code>x</code> there is an infinite number of <code>z</code> such that <code>exp(z) = 1 + x</code>. The convention is to return the <code>z</code> whose imaginary part lies in <code>[-pi, pi]</code>.</p>
<p>For real-valued input data types, <code>log1p</code> always returns real output. For each value that cannot be expressed as a real number or infinity, it yields <code>nan</code> and sets the <code>invalid</code> floating point error flag.</p>
<p>For complex-valued input, <code>log1p</code> is a complex analytical function that has a branch cut <code>[-inf, -1]</code> and is continuous from above on it. <code>log1p</code> handles the floating-point negative zero as an infinitesimal negative number, conforming to the C99 standard.</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [1] M. Abramowitz and I.A. Stegun, Handbook of Mathematical Functions,  10th printing, 1964, pp. 67. <a href="http://www.math.sfu.ca/~cbm/aands/">http://www.math.sfu.ca/~cbm/aands/</a> .. [2] Wikipedia, Logarithm. <a href="https://en.wikipedia.org/wiki/Logarithm">https://en.wikipedia.org/wiki/Logarithm</a></p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.log1p(1e-99) 1e-99 np.log(1 + 1e-99) 0.0</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L507">view source</a></div></div><div class="public anchor" id="var-log2"><h3>log2</h3><div class="usage"><code>(log2 self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>log2(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Base-2 logarithm of <code>x</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Input values. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray  Base-2 logarithm of <code>x</code>.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>log, log10, log1p, emath.log2</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>.. versionadded:: 1.3.0</p>
<p>Logarithm is a multivalued function: for each <code>x</code> there is an infinite number of <code>z</code> such that <code>2**z = x</code>. The convention is to return the <code>z</code> whose imaginary part lies in <code>[-pi, pi]</code>.</p>
<p>For real-valued input data types, <code>log2</code> always returns real output. For each value that cannot be expressed as a real number or infinity, it yields <code>nan</code> and sets the <code>invalid</code> floating point error flag.</p>
<p>For complex-valued input, <code>log2</code> is a complex analytical function that has a branch cut <code>[-inf, 0]</code> and is continuous from above on it. <code>log2</code> handles the floating-point negative zero as an infinitesimal negative number, conforming to the C99 standard.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.array([0, 1, 2, 2**4]) np.log2(x) array([-Inf, 0., 1., 4.])</p>
      <p>xi = np.array([0+1.j, 1, 2+0.j, 4.j]) np.log2(xi) array([ 0.+2.26618007j, 0.+0.j , 1.+0.j , 2.+2.26618007j])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L27512">view source</a></div></div><div class="public anchor" id="var-logaddexp"><h3>logaddexp</h3><div class="usage"><code>(logaddexp self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>logaddexp(x1, x2, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Logarithm of the sum of exponentiations of the inputs.</p>
<p>Calculates <code>log(exp(x1) + exp(x2))</code>. This function is useful in statistics where the calculated probabilities of events may be so small as to exceed the range of normal floating point numbers. In such cases the logarithm of the calculated probability is stored. This function allows adding probabilities stored in such a fashion.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x1, x2 : array_like  Input values. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output). out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>result : ndarray  Logarithm of <code>exp(x1) + exp(x2)</code>.  This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>logaddexp2: Logarithm of the sum of exponentiations of inputs in base 2.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>.. versionadded:: 1.3.0</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>prob1 = np.log(1e-50) prob2 = np.log(2.5e-50) prob12 = np.logaddexp(prob1, prob2) prob12 -113.87649168120691 np.exp(prob12) 3.5000000000000057e-50</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L5309">view source</a></div></div><div class="public anchor" id="var-logaddexp2"><h3>logaddexp2</h3><div class="usage"><code>(logaddexp2 self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>logaddexp2(x1, x2, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Logarithm of the sum of exponentiations of the inputs in base-2.</p>
<p>Calculates <code>log2(2**x1 + 2**x2)</code>. This function is useful in machine learning when the calculated probabilities of events may be so small as to exceed the range of normal floating point numbers. In such cases the base-2 logarithm of the calculated probability can be used instead. This function allows adding probabilities stored in such a fashion.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x1, x2 : array_like  Input values. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output). out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>result : ndarray  Base-2 logarithm of <code>2**x1 + 2**x2</code>.  This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>logaddexp: Logarithm of the sum of exponentiations of the inputs.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>.. versionadded:: 1.3.0</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>prob1 = np.log2(1e-50) prob2 = np.log2(2.5e-50) prob12 = np.logaddexp2(prob1, prob2) prob1, prob2, prob12 (-166.09640474436813, -164.77447664948076, -164.28904982231052) 2**prob12 3.4999999999999914e-50</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L26370">view source</a></div></div><div class="public anchor" id="var-logical_and"><h3>logical_and</h3><div class="usage"><code>(logical_and self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>logical_and(x1, x2, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Compute the truth value of x1 AND x2 element-wise.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x1, x2 : array_like  Input arrays. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output). out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray or bool  Boolean result of the logical AND operation applied to the elements  of <code>x1</code> and <code>x2</code>; the shape is determined by broadcasting.  This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>logical_or, logical_not, logical_xor bitwise_and</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.logical_and(True, False) False np.logical_and([True, False], [False, False]) array([False, False])</p>
      <p>x = np.arange(5) np.logical_and(x&gt;1, x&lt;4) array([False, False, True, True, False])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L764">view source</a></div></div><div class="public anchor" id="var-logical_not"><h3>logical_not</h3><div class="usage"><code>(logical_not self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>logical_not(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Compute the truth value of NOT x element-wise.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Logical NOT is applied to the elements of <code>x</code>. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : bool or ndarray of bool  Boolean result with the same shape as <code>x</code> of the NOT operation  on elements of <code>x</code>.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>logical_and, logical_or, logical_xor</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.logical_not(3) False np.logical_not([True, False, 0, 1]) array([False, True, True, False])</p>
      <p>x = np.arange(5) np.logical_not(x&lt;3) array([False, False, False, True, True])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L18820">view source</a></div></div><div class="public anchor" id="var-logical_or"><h3>logical_or</h3><div class="usage"><code>(logical_or self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>logical_or(x1, x2, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Compute the truth value of x1 OR x2 element-wise.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x1, x2 : array_like  Logical OR is applied to the elements of <code>x1</code> and <code>x2</code>.  If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output). out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray or bool  Boolean result of the logical OR operation applied to the elements  of <code>x1</code> and <code>x2</code>; the shape is determined by broadcasting.  This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>logical_and, logical_not, logical_xor bitwise_or</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.logical_or(True, False) True np.logical_or([True, False], [False, False]) array([ True, False])</p>
      <p>x = np.arange(5) np.logical_or(x &lt; 1, x &gt; 3) array([ True, False, False, False, True])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L4331">view source</a></div></div><div class="public anchor" id="var-logical_xor"><h3>logical_xor</h3><div class="usage"><code>(logical_xor self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>logical_xor(x1, x2, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Compute the truth value of x1 XOR x2, element-wise.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x1, x2 : array_like  Logical XOR is applied to the elements of <code>x1</code> and <code>x2</code>. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output). out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : bool or ndarray of bool  Boolean result of the logical XOR operation applied to the elements  of <code>x1</code> and <code>x2</code>; the shape is determined by broadcasting.  This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>logical_and, logical_or, logical_not, bitwise_xor</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.logical_xor(True, False) True np.logical_xor([True, True, False, False], [True, False, True, False]) array([False, True, True, False])</p>
      <p>x = np.arange(5) np.logical_xor(x &lt; 1, x &gt; 3) array([ True, False, False, False, True])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Simple example showing support of broadcasting</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.logical_xor(0, np.eye(2)) array(<a href="null"> True, False],
       [False,  True</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L23887">view source</a></div></div><div class="public anchor" id="var-logspace"><h3>logspace</h3><div class="usage"><code>(logspace &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return numbers spaced evenly on a log scale.</p>
<p>In linear space, the sequence starts at <code>base ** start</code> (<code>base</code> to the power of <code>start</code>) and ends with <code>base ** stop</code> (see <code>endpoint</code> below).</p>
<p>.. versionchanged:: 1.16.0  Non-scalar <code>start</code> and <code>stop</code> are now supported.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>start : array_like  <code>base ** start</code> is the starting value of the sequence. stop : array_like  <code>base ** stop</code> is the final value of the sequence, unless <code>endpoint</code>  is False. In that case, <code>num + 1</code> values are spaced over the  interval in log-space, of which all but the last (a sequence of  length <code>num</code>) are returned. num : integer, optional  Number of samples to generate. Default is 50. endpoint : boolean, optional  If true, <code>stop</code> is the last sample. Otherwise, it is not included.  Default is True. base : float, optional  The base of the log space. The step size between the elements in  <code>ln(samples) / ln(base)</code> (or <code>log_base(samples)</code>) is uniform.  Default is 10.0. dtype : dtype  The type of the output array. If <code>dtype</code> is not given, infer the data  type from the other input arguments. axis : int, optional  The axis in the result to store the samples. Relevant only if start  or stop are array-like. By default (0), the samples will be along a  new axis inserted at the beginning. Use -1 to get an axis at the end.</p>
<pre><code>.. versionadded:: 1.16.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>samples : ndarray  <code>num</code> samples, equally spaced on a log scale.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>arange : Similar to linspace, with the step size specified instead of the  number of samples. Note that, when used with a float endpoint, the  endpoint may or may not be included. linspace : Similar to logspace, but with the samples uniformly distributed  in linear space, instead of log space. geomspace : Similar to logspace, but with endpoints specified directly.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Logspace is equivalent to the code</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>y = np.linspace(start, stop, num=num, endpoint=endpoint)  # doctest: +SKIP power(base, y).astype(dtype)  # doctest: +SKIP</p>
    </blockquote>
  </blockquote>
</blockquote>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.logspace(2.0, 3.0, num=4) array([ 100. , 215.443469 , 464.15888336, 1000. ]) np.logspace(2.0, 3.0, num=4, endpoint=False) array([100. , 177.827941 , 316.22776602, 562.34132519]) np.logspace(2.0, 3.0, num=4, base=2.0) array([4. , 5.0396842 , 6.34960421, 8. ])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Graphical illustration:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>import matplotlib.pyplot as plt N = 10 x1 = np.logspace(0.1, 1, N, endpoint=True) x2 = np.logspace(0.1, 1, N, endpoint=False) y = np.zeros(N) plt.plot(x1, y, o) [&lt;matplotlib.lines.Line2D object at 0x&gt;] plt.plot(x2, y + 0.5, o) [&lt;matplotlib.lines.Line2D object at 0x&gt;] plt.ylim([-0.5, 1]) (-0.5, 1) plt.show()</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L18731">view source</a></div></div><div class="public anchor" id="var-long"><h3>long</h3><div class="usage"><code>(long self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>int([x]) -&gt; integer int(x, base=10) -&gt; integer</p>
<p>Convert a number or string to an integer, or return 0 if no arguments are given. If x is a number, return x.__int__(). For floating point numbers, this truncates towards zero.</p>
<p>If x is not a number or if base is given, then x must be a string, bytes, or bytearray instance representing an integer literal in the given base. The literal can be preceded by + or - and be surrounded by whitespace. The base defaults to 10. Valid bases are 0 and 2-36. Base 0 means to interpret the base from the string as an integer literal.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>int(0b100, base=0) 4</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L7708">view source</a></div></div><div class="public anchor" id="var-longcomplex"><h3>longcomplex</h3><div class="usage"><code>(longcomplex self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Complex number type composed of two extended-precision floating-point numbers. Character code: <code>'G'</code>. Canonical name: <code>np.clongdouble</code>. Alias: <code>np.clongfloat</code>. Alias: <code>np.longcomplex</code>. Alias <em>on this platform</em>: <code>np.complex256</code>: Complex number type composed of 2 128-bit extended-precision floating-point numbers.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L7724">view source</a></div></div><div class="public anchor" id="var-longdouble"><h3>longdouble</h3><div class="usage"><code>(longdouble self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Extended-precision floating-point number type, compatible with C <code>long double</code> but not necessarily with IEEE 754 quadruple-precision. Character code: <code>'g'</code>. Canonical name: <code>np.longdouble</code>. Alias: <code>np.longfloat</code>. Alias <em>on this platform</em>: <code>np.float128</code>: 128-bit extended-precision floating-point number type.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L6487">view source</a></div></div><div class="public anchor" id="var-longfloat"><h3>longfloat</h3><div class="usage"><code>(longfloat self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Extended-precision floating-point number type, compatible with C <code>long double</code> but not necessarily with IEEE 754 quadruple-precision. Character code: <code>'g'</code>. Canonical name: <code>np.longdouble</code>. Alias: <code>np.longfloat</code>. Alias <em>on this platform</em>: <code>np.float128</code>: 128-bit extended-precision floating-point number type.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L499">view source</a></div></div><div class="public anchor" id="var-longlong"><h3>longlong</h3><div class="usage"><code>(longlong self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Signed integer type, compatible with C <code>long long</code>. Character code: <code>'q'</code>.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L28966">view source</a></div></div><div class="public anchor" id="var-lookfor"><h3>lookfor</h3><div class="usage"><code>(lookfor what &amp; [{module :module, import_modules :import_modules, regenerate :regenerate, output :output}])</code><code>(lookfor what &amp; [{module :module, import_modules :import_modules, regenerate :regenerate}])</code><code>(lookfor what &amp; [{module :module, import_modules :import_modules}])</code><code>(lookfor what &amp; [{module :module}])</code><code>(lookfor what)</code></div><div class="doc"><div class="markdown"><p>Do a keyword search on docstrings.</p>
<p>A list of objects that matched the search is displayed, sorted by relevance. All given keywords need to be found in the docstring for it to be returned as a result, but the order does not matter.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>what : str  String containing words to look for. module : str or list, optional  Name of module(s) whose docstrings to go through. import_modules : bool, optional  Whether to import sub-modules in packages. Default is True. regenerate : bool, optional  Whether to re-generate the docstring cache. Default is False. output : file-like, optional  File-like object to write the output to. If omitted, use a pager.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>source, info</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Relevance is determined only roughly, by checking if the keywords occur in the function name, at the start of a docstring, etc.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.lookfor(binary representation) # doctest: +SKIP</p>
      <h2><a href="#search-results-for-binary-representation" name="search-results-for-binary-representation"></a>Search results for binary representation</h2>
      <p>numpy.binary_repr  Return the binary representation of the input number as a string. numpy.core.setup_common.long_double_representation  Given a binary dump as given by GNU od -b, look for long double numpy.base_repr  Return a string representation of a number in the given base system. </p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L21667">view source</a></div></div><div class="public anchor" id="var-ma"><h3>ma</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>=============</p>
<h1><a href="#masked-arrays" name="masked-arrays"></a>Masked Arrays</h1>
<p>Arrays sometimes contain invalid or missing data. When doing operations on such arrays, we wish to suppress invalid values, which is the purpose masked arrays fulfill (an example of typical use is given below).</p>
<p>For example, examine the following array:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.array([2, 1, 3, np.nan, 5, 2, 3, np.nan])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>When we try to calculate the mean of the data, the result is undetermined:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.mean(x) nan</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The mean is calculated using roughly <code>np.sum(x)/len(x)</code>, but since any number added to <code>NaN</code> [1]_ produces <code>NaN</code>, this doesnt work. Enter masked arrays:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>m = np.ma.masked_array(x, np.isnan(x)) m masked_array(data = [2.0 1.0 3.0  5.0 2.0 3.0 ],  mask = [False False False True False False False True],  fill_value=1e+20)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Here, we construct a masked array that suppress all <code>NaN</code> values. We may now proceed to calculate the mean of the other values:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.mean(m) 2.6666666666666665</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>.. [1] Not-a-Number, a floating point value that is the result of an  invalid operation.</p>
<p>.. moduleauthor:: Pierre Gerard-Marchant .. moduleauthor:: Jarrod Millman</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L15056">view source</a></div></div><div class="public anchor" id="var-MachAr"><h3>MachAr</h3><div class="usage"><code>(MachAr self &amp; [{float_conv :float_conv, int_conv :int_conv, float_to_float :float_to_float, float_to_str :float_to_str, title :title}])</code><code>(MachAr self &amp; [{float_conv :float_conv, int_conv :int_conv, float_to_float :float_to_float, float_to_str :float_to_str}])</code><code>(MachAr self &amp; [{float_conv :float_conv, int_conv :int_conv, float_to_float :float_to_float}])</code><code>(MachAr self &amp; [{float_conv :float_conv, int_conv :int_conv}])</code><code>(MachAr self &amp; [{float_conv :float_conv}])</code><code>(MachAr self)</code></div><div class="doc"><div class="markdown"><p>Diagnosing machine parameters.</p>
<h2><a href="#attributes" name="attributes"></a>Attributes</h2>
<p>ibeta : int  Radix in which numbers are represented. it : int  Number of base-<code>ibeta</code> digits in the floating point mantissa M. machep : int  Exponent of the smallest (most negative) power of <code>ibeta</code> that,  added to 1.0, gives something different from 1.0 eps : float  Floating-point number <code>beta**machep</code> (floating point precision) negep : int  Exponent of the smallest power of <code>ibeta</code> that, subtracted  from 1.0, gives something different from 1.0. epsneg : float  Floating-point number <code>beta**negep</code>. iexp : int  Number of bits in the exponent (including its sign and bias). minexp : int  Smallest (most negative) power of <code>ibeta</code> consistent with there  being no leading zeros in the mantissa. xmin : float  Floating point number <code>beta**minexp</code> (the smallest [in  magnitude] usable floating value). maxexp : int  Smallest (positive) power of <code>ibeta</code> that causes overflow. xmax : float  <code>(1-epsneg) * beta**maxexp</code> (the largest [in magnitude]  usable floating value). irnd : int  In <code>range(6)</code>, information on what kind of rounding is done  in addition, and on how underflow is handled. ngrd : int  Number of guard digits used when truncating the product  of two mantissas to fit the representation. epsilon : float  Same as <code>eps</code>. tiny : float  Same as <code>xmin</code>. huge : float  Same as <code>xmax</code>. precision : float  <code>- int(-log10(eps))</code> resolution : float  <code>- 10**(-precision)</code></p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>float_conv : function, optional  Function that converts an integer or integer array to a float  or float array. Default is <code>float</code>. int_conv : function, optional  Function that converts a float or float array to an integer or  integer array. Default is <code>int</code>. float_to_float : function, optional  Function that converts a float array to float. Default is <code>float</code>.  Note that this does not seem to do anything useful in the current  implementation. float_to_str : function, optional  Function that converts a single float to a string. Default is  <code>lambda v:'%24.16e' %v</code>. title : str, optional  Title that is printed in the string representation of <code>MachAr</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>finfo : Machine limits for floating point types. iinfo : Machine limits for integer types.</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [1] Press, Teukolsky, Vetterling and Flannery,  Numerical Recipes in C++, 2nd ed,  Cambridge University Press, 2002, p. 31.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L203">view source</a></div></div><div class="public anchor" id="var-mafromtxt"><h3>mafromtxt</h3><div class="usage"><code>(mafromtxt fname &amp; [{:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Load ASCII data stored in a text file and return a masked array.</p>
<p>.. deprecated:: 1.17  np.mafromtxt is a deprecated alias of <code>genfromtxt</code> which  overwrites the <code>usemask</code> argument with <code>True</code> even when  explicitly called as <code>mafromtxt(..., usemask=False)</code>.  Use <code>genfromtxt</code> instead.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>fname, kwargs : For a description of input parameters, see <code>genfromtxt</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>numpy.genfromtxt : generic function to load ASCII data.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L22869">view source</a></div></div><div class="public anchor" id="var-mask_indices"><h3>mask_indices</h3><div class="usage"><code>(mask_indices n mask_func &amp; [{k :k}])</code><code>(mask_indices n mask_func)</code></div><div class="doc"><div class="markdown"><p>Return the indices to access (n, n) arrays, given a masking function.</p>
<p>Assume <code>mask_func</code> is a function that, for a square array a of size <code>(n, n)</code> with a possible offset argument <code>k</code>, when called as <code>mask_func(a, k)</code> returns a new array with zeros in certain locations (functions like <code>triu</code> or <code>tril</code> do precisely this). Then this function returns the indices where the non-zero values would be located.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>n : int  The returned indices will be valid to access arrays of shape (n, n). mask_func : callable  A function whose call signature is similar to that of <code>triu</code>, <code>tril</code>.  That is, <code>mask_func(x, k)</code> returns a boolean array, shaped like <code>x</code>.  <code>k</code> is an optional argument to the function. k : scalar  An optional argument which is passed through to <code>mask_func</code>. Functions  like <code>triu</code>, <code>tril</code> take a second argument that is interpreted as an  offset.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>indices : tuple of arrays.  The <code>n</code> arrays of indices corresponding to the locations where  <code>mask_func(np.ones((n, n)), k)</code> is True.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>triu, tril, triu_indices, tril_indices</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>.. versionadded:: 1.4.0</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>These are the indices that would allow you to access the upper triangular part of any 3x3 array:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>iu = np.mask_indices(3, np.triu)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>For example, if <code>a</code> is a 3x3 array:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.arange(9).reshape(3, 3) a array(<a href="null">0, 1, 2],
       [3, 4, 5],
       [6, 7, 8</a>) a[iu] array([0, 1, 2, 4, 5, 8])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>An offset can be passed also to the masking function. This gets us the indices starting on the first diagonal right of the main one:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>iu1 = np.mask_indices(3, np.triu, 1)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>with which we now extract only three elements:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a[iu1] array([1, 2, 5])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L17456">view source</a></div></div><div class="public anchor" id="var-mat"><h3>mat</h3><div class="usage"><code>(mat data &amp; [{dtype :dtype}])</code><code>(mat data)</code></div><div class="doc"><div class="markdown"><p>Interpret the input as a matrix.</p>
<p>Unlike <code>matrix</code>, <code>asmatrix</code> does not make a copy if the input is already a matrix or an ndarray. Equivalent to <code>matrix(data, copy=False)</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>data : array_like  Input data. dtype : data-type  Data-type of the output matrix.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>mat : matrix  <code>data</code> interpreted as a matrix.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.array(<a href="null">1, 2], [3, 4</a>)</p>
      <p>m = np.asmatrix(x)</p>
      <p>x[0,0] = 5</p>
      <p>m matrix(<a href="null">5, 2],
        [3, 4</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L9421">view source</a></div></div><div class="public anchor" id="var-math"><h3>math</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>This module provides access to the mathematical functions defined by the C standard.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L15053">view source</a></div></div><div class="public anchor" id="var-matmul"><h3>matmul</h3><div class="usage"><code>(matmul self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>matmul(x1, x2, /, out=None, *, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Matrix product of two arrays.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x1, x2 : array_like  Input arrays, scalars not allowed. out : ndarray, optional  A location into which the result is stored. If provided, it must have  a shape that matches the signature <code>(n,k),(k,m)-&gt;(n,m)</code>. If not  provided or None, a freshly-allocated array is returned. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<pre><code>.. versionadded:: 1.16
   Now handles ufunc kwargs
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray  The matrix product of the inputs.  This is a scalar only when both x1, x2 are 1-d vectors.</p>
<h2><a href="#raises" name="raises"></a>Raises</h2>
<p>ValueError  If the last dimension of <code>a</code> is not the same size as  the second-to-last dimension of <code>b</code>.</p>
<pre><code>If a scalar value is passed in.
</code></pre>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>vdot : Complex-conjugating dot product. tensordot : Sum products over arbitrary axes. einsum : Einstein summation convention. dot : alternative matrix product with different broadcasting rules.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The behavior depends on the arguments in the following way.</p>
<ul>
  <li>If both arguments are 2-D they are multiplied like conventional  matrices.</li>
  <li>If either argument is N-D, N &gt; 2, it is treated as a stack of  matrices residing in the last two indexes and broadcast accordingly.</li>
  <li>If the first argument is 1-D, it is promoted to a matrix by  prepending a 1 to its dimensions. After matrix multiplication  the prepended 1 is removed.</li>
  <li>If the second argument is 1-D, it is promoted to a matrix by  appending a 1 to its dimensions. After matrix multiplication  the appended 1 is removed.</li>
</ul>
<p><code>matmul</code> differs from <code>dot</code> in two important ways:</p>
<ul>
  <li>Multiplication by scalars is not allowed, use <code>*</code> instead.</li>
  <li>Stacks of matrices are broadcast together as if the matrices  were elements, respecting the signature <code>(n,k),(k,m)-&gt;(n,m)</code>:</li>
</ul>
<p>&gt;&gt;&gt; a = np.ones([9, 5, 7, 4])  &gt;&gt;&gt; c = np.ones([9, 5, 4, 3])  &gt;&gt;&gt; np.dot(a, c).shape  (9, 5, 7, 9, 5, 3)  &gt;&gt;&gt; np.matmul(a, c).shape  (9, 5, 7, 3)  &gt;&gt;&gt; # n is 7, k is 4, m is 3</p>
<p>The matmul function implements the semantics of the <code>@</code> operator introduced in Python 3.5 following PEP465.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>For 2-D arrays it is the matrix product:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array(<a href="null">1, 0],
...               [0, 1</a>) b = np.array(<a href="null">4, 1],
...               [2, 2</a>) np.matmul(a, b) array(<a href="null">4, 1],
       [2, 2</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>For 2-D mixed with 1-D, the result is the usual.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array(<a href="null">1, 0],
...               [0, 1</a>) b = np.array([1, 2]) np.matmul(a, b) array([1, 2]) np.matmul(b, a) array([1, 2])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Broadcasting is conventional for stacks of arrays</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.arange(2 * 2 * 4).reshape((2, 2, 4)) b = np.arange(2 * 2 * 4).reshape((2, 4, 2)) np.matmul(a,b).shape (2, 2, 2) np.matmul(a, b)[0, 1, 1] 98 sum(a[0, 1, :] * b[0 , :, 1]) 98</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Vector, vector returns the scalar inner product, but neither argument is complex-conjugated:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.matmul([2j, 3j], [2j, 3j]) (-13+0j)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Scalar multiplication raises an error.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.matmul([1,2], 3) Traceback (most recent call last):  ValueError: matmul: Input operand 1 does not have enough dimensions </p>
    </blockquote>
  </blockquote>
</blockquote>
<p>.. versionadded:: 1.10.0</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L6668">view source</a></div></div><div class="public anchor" id="var-matrix"><h3>matrix</h3><div class="usage"><code>(matrix self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>matrix(data, dtype=None, copy=True)</p>
<p>.. note:: It is no longer recommended to use this class, even for linear  algebra. Instead use regular arrays. The class may be removed  in the future.</p>
<p>Returns a matrix from an array-like object, or from a string of data. A matrix is a specialized 2-D array that retains its 2-D nature through operations. It has certain special operators, such as <code>*</code> (matrix multiplication) and <code>**</code> (matrix power).</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>data : array_like or string  If <code>data</code> is a string, it is interpreted as a matrix with commas  or spaces separating columns, and semicolons separating rows. dtype : data-type  Data-type of the output matrix. copy : bool  If <code>data</code> is already an <code>ndarray</code>, then this flag determines  whether the data is copied (the default), or whether a view is  constructed.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>array</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.matrix(1 2; 3 4) a matrix(<a href="null">1, 2],
        [3, 4</a>)</p>
      <p>np.matrix(<a href="null">1, 2], [3, 4</a>) matrix(<a href="null">1, 2],
        [3, 4</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L8364">view source</a></div></div><div class="public anchor" id="var-matrixlib"><h3>matrixlib</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Sub-package containing the matrix class and related functions.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L5618">view source</a></div></div><div class="public anchor" id="var-max"><h3>max</h3><div class="usage"><code>(max &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return the maximum of an array or maximum along an axis.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input data. axis : None or int or tuple of ints, optional  Axis or axes along which to operate. By default, flattened input is  used.</p>
<pre><code>.. versionadded:: 1.7.0

If this is a tuple of ints, the maximum is selected over multiple axes,
instead of a single axis or all the axes as before.
</code></pre>
<p>out : ndarray, optional  Alternative output array in which to place the result. Must  be of the same shape and buffer length as the expected output.  See <code>ufuncs-output-type</code> for more details.</p>
<p>keepdims : bool, optional  If this is set to True, the axes which are reduced are left  in the result as dimensions with size one. With this option,  the result will broadcast correctly against the input array.</p>
<pre><code>If the default value is passed, then `keepdims` will not be
passed through to the `amax` method of sub-classes of
`ndarray`, however any non-default value will be.  If the
sub-class' method does not implement `keepdims` any
exceptions will be raised.
</code></pre>
<p>initial : scalar, optional  The minimum value of an output element. Must be present to allow  computation on empty slice. See <code>~numpy.ufunc.reduce</code> for details.</p>
<pre><code>.. versionadded:: 1.15.0
</code></pre>
<p>where : array_like of bool, optional  Elements to compare for the maximum. See <code>~numpy.ufunc.reduce</code>  for details.</p>
<pre><code>.. versionadded:: 1.17.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>amax : ndarray or scalar  Maximum of <code>a</code>. If <code>axis</code> is None, the result is a scalar value.  If <code>axis</code> is given, the result is an array of dimension  <code>a.ndim - 1</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>amin :  The minimum value of an array along a given axis, propagating any NaNs. nanmax :  The maximum value of an array along a given axis, ignoring any NaNs. maximum :  Element-wise maximum of two arrays, propagating any NaNs. fmax :  Element-wise maximum of two arrays, ignoring any NaNs. argmax :  Return the indices of the maximum values.</p>
<p>nanmin, minimum, fmin</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>NaN values are propagated, that is if at least one item is NaN, the corresponding max value will be NaN as well. To ignore NaN values (MATLAB behavior), please use nanmax.</p>
<p>Dont use <code>amax</code> for element-wise comparison of 2 arrays; when <code>a.shape[0]</code> is 2, <code>maximum(a[0], a[1])</code> is faster than <code>amax(a, axis=0)</code>.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.arange(4).reshape((2,2)) a array(<a href="null">0, 1],
       [2, 3</a>) np.amax(a) # Maximum of the flattened array 3 np.amax(a, axis=0) # Maxima along the first axis array([2, 3]) np.amax(a, axis=1) # Maxima along the second axis array([1, 3]) np.amax(a, where=[False, True], initial=-1, axis=0) array([-1, 3]) b = np.arange(5, dtype=float) b[2] = np.NaN np.amax(b) nan np.amax(b, where=~np.isnan(b), initial=-1) 4.0 np.nanmax(b) 4.0</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>You can use an initial value to compute the maximum of an empty slice, or to initialize it to a different value:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.max(<a href="null">-50], [10</a>, axis=-1, initial=0) array([ 0, 10])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Notice that the initial value is used as one of the elements for which the maximum is determined, unlike for the default argument Pythons max function, which is only used for empty iterables.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.max([5], initial=6) 6 max([5], default=6) 5</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L9047">view source</a></div></div><div class="public anchor" id="var-MAXDIMS"><h3>MAXDIMS</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L26989">view source</a></div></div><div class="public anchor" id="var-maximum"><h3>maximum</h3><div class="usage"><code>(maximum self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>maximum(x1, x2, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Element-wise maximum of array elements.</p>
<p>Compare two arrays and returns a new array containing the element-wise maxima. If one of the elements being compared is a NaN, then that element is returned. If both elements are NaNs then the first is returned. The latter distinction is important for complex NaNs, which are defined as at least one of the real or imaginary parts being a NaN. The net effect is that NaNs are propagated.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x1, x2 : array_like  The arrays holding the elements to be compared. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output). out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray or scalar  The maximum of <code>x1</code> and <code>x2</code>, element-wise.  This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>minimum :  Element-wise minimum of two arrays, propagates NaNs. fmax :  Element-wise maximum of two arrays, ignores NaNs. amax :  The maximum value of an array along a given axis, propagates NaNs. nanmax :  The maximum value of an array along a given axis, ignores NaNs.</p>
<p>fmin, amin, nanmin</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The maximum is equivalent to <code>np.where(x1 &gt;= x2, x1, x2)</code> when neither x1 nor x2 are nans, but it is faster and does proper broadcasting.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.maximum([2, 3, 4], [1, 5, 2]) array([2, 5, 4])</p>
      <p>np.maximum(np.eye(2), [0.5, 2]) # broadcasting array(<a href="null"> 1. ,  2. ],
       [ 0.5,  2. </a>)</p>
      <p>np.maximum([np.nan, 0, np.nan], [0, np.nan, np.nan]) array([nan, nan, nan]) np.maximum(np.Inf, 1) inf</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L9683">view source</a></div></div><div class="public anchor" id="var-maximum_sctype"><h3>maximum_sctype</h3><div class="usage"><code>(maximum_sctype t)</code></div><div class="doc"><div class="markdown"><p>Return the scalar type of highest precision of the same kind as the input.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>t : dtype or dtype specifier  The input data type. This can be a <code>dtype</code> object or an object that  is convertible to a <code>dtype</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : dtype  The highest precision data type of the same kind (<code>dtype.kind</code>) as <code>t</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>obj2sctype, mintypecode, sctype2char dtype</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.maximum_sctype(int) &lt;class numpy.int64&gt; np.maximum_sctype(np.uint8) &lt;class numpy.uint64&gt; np.maximum_sctype(complex) &lt;class numpy.complex256&gt; # may vary</p>
      <p>np.maximum_sctype(str) &lt;class numpy.str_&gt;</p>
      <p>np.maximum_sctype(i2) &lt;class numpy.int64&gt; np.maximum_sctype(f4) &lt;class numpy.float128&gt; # may vary</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L4165">view source</a></div></div><div class="public anchor" id="var-MAY_SHARE_BOUNDS"><h3>MAY_SHARE_BOUNDS</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L1393">view source</a></div></div><div class="public anchor" id="var-MAY_SHARE_EXACT"><h3>MAY_SHARE_EXACT</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L14131">view source</a></div></div><div class="public anchor" id="var-may_share_memory"><h3>may_share_memory</h3><div class="usage"><code>(may_share_memory &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>may_share_memory(a, b, max_work=None)</p>
<p>Determine if two arrays might share memory</p>
<p>A return of True does not necessarily mean that the two arrays share any element. It just means that they <em>might</em>.</p>
<p>Only the memory bounds of a and b are checked by default.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a, b : ndarray  Input arrays max_work : int, optional  Effort to spend on solving the overlap problem. See  <code>shares_memory</code> for details. Default for <code>may_share_memory</code>  is to do a bounds check.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : bool</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>shares_memory</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.may_share_memory(np.array([1,2]), np.array([5,8,9])) False x = np.zeros([3, 4]) np.may_share_memory(x[:,0], x[:,1]) True</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L20304">view source</a></div></div><div class="public anchor" id="var-mean"><h3>mean</h3><div class="usage"><code>(mean &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Compute the arithmetic mean along the specified axis.</p>
<p>Returns the average of the array elements. The average is taken over the flattened array by default, otherwise over the specified axis. <code>float64</code> intermediate and return values are used for integer inputs.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Array containing numbers whose mean is desired. If <code>a</code> is not an  array, a conversion is attempted. axis : None or int or tuple of ints, optional  Axis or axes along which the means are computed. The default is to  compute the mean of the flattened array.</p>
<pre><code>.. versionadded:: 1.7.0

If this is a tuple of ints, a mean is performed over multiple axes,
instead of a single axis or all the axes as before.
</code></pre>
<p>dtype : data-type, optional  Type to use in computing the mean. For integer inputs, the default  is <code>float64</code>; for floating point inputs, it is the same as the  input dtype. out : ndarray, optional  Alternate output array in which to place the result. The default  is <code>None</code>; if provided, it must have the same shape as the  expected output, but the type will be cast if necessary.  See <code>ufuncs-output-type</code> for more details.</p>
<p>keepdims : bool, optional  If this is set to True, the axes which are reduced are left  in the result as dimensions with size one. With this option,  the result will broadcast correctly against the input array.</p>
<pre><code>If the default value is passed, then `keepdims` will not be
passed through to the `mean` method of sub-classes of
`ndarray`, however any non-default value will be.  If the
sub-class' method does not implement `keepdims` any
exceptions will be raised.
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>m : ndarray, see dtype parameter above  If <code>out=None</code>, returns a new array containing the mean values,  otherwise a reference to the output array is returned.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>average : Weighted average std, var, nanmean, nanstd, nanvar</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The arithmetic mean is the sum of the elements along the axis divided by the number of elements.</p>
<p>Note that for floating-point input, the mean is computed using the same precision the input has. Depending on the input data, this can cause the results to be inaccurate, especially for <code>float32</code> (see example below). Specifying a higher-precision accumulator using the <code>dtype</code> keyword can alleviate this issue.</p>
<p>By default, <code>float16</code> results are computed using <code>float32</code> intermediates for extra precision.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array(<a href="null">1, 2], [3, 4</a>) np.mean(a) 2.5 np.mean(a, axis=0) array([2., 3.]) np.mean(a, axis=1) array([1.5, 3.5])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>In single precision, <code>mean</code> can be inaccurate:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.zeros((2, 512*512), dtype=np.float32) a[0, :] = 1.0 a[1, :] = 0.1 np.mean(a) 0.54999924</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Computing the mean in float64 is more accurate:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.mean(a, dtype=np.float64) 0.55000000074505806 # may vary</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L6809">view source</a></div></div><div class="public anchor" id="var-median"><h3>median</h3><div class="usage"><code>(median &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Compute the median along the specified axis.</p>
<p>Returns the median of the array elements.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input array or object that can be converted to an array. axis : {int, sequence of int, None}, optional  Axis or axes along which the medians are computed. The default  is to compute the median along a flattened version of the array.  A sequence of axes is supported since version 1.9.0. out : ndarray, optional  Alternative output array in which to place the result. It must  have the same shape and buffer length as the expected output,  but the type (of the output) will be cast if necessary. overwrite_input : bool, optional  If True, then allow use of memory of input array <code>a</code> for  calculations. The input array will be modified by the call to  <code>median</code>. This will save memory when you do not need to preserve  the contents of the input array. Treat the input as undefined,  but it will probably be fully or partially sorted. Default is  False. If <code>overwrite_input</code> is <code>True</code> and <code>a</code> is not already an  <code>ndarray</code>, an error will be raised. keepdims : bool, optional  If this is set to True, the axes which are reduced are left  in the result as dimensions with size one. With this option,  the result will broadcast correctly against the original <code>arr</code>.</p>
<pre><code>.. versionadded:: 1.9.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>median : ndarray  A new array holding the result. If the input contains integers  or floats smaller than <code>float64</code>, then the output data-type is  <code>np.float64</code>. Otherwise, the data-type of the output is the  same as that of the input. If <code>out</code> is specified, that array is  returned instead.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>mean, percentile</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Given a vector <code>V</code> of length <code>N</code>, the median of <code>V</code> is the middle value of a sorted copy of <code>V</code>, <code>V_sorted</code> - i e., <code>V_sorted[(N-1)/2]</code>, when <code>N</code> is odd, and the average of the two middle values of <code>V_sorted</code> when <code>N</code> is even.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array(<a href="null">10, 7, 4], [3, 2, 1</a>) a array(<a href="null">10,  7,  4],
       [ 3,  2,  1</a>) np.median(a) 3.5 np.median(a, axis=0) array([6.5, 4.5, 2.5]) np.median(a, axis=1) array([7., 2.]) m = np.median(a, axis=0) out = np.zeros_like(m) np.median(a, axis=0, out=m) array([6.5, 4.5, 2.5]) m array([6.5, 4.5, 2.5]) b = a.copy() np.median(b, axis=1, overwrite_input=True) array([7., 2.]) assert not np.all(a==b) b = a.copy() np.median(b, axis=None, overwrite_input=True) 3.5 assert not np.all(a==b)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L28989">view source</a></div></div><div class="public anchor" id="var-memmap"><h3>memmap</h3><div class="usage"><code>(memmap self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Create a memory-map to an array stored in a <em>binary</em> file on disk.</p>
<p>Memory-mapped files are used for accessing small segments of large files on disk, without reading the entire file into memory. NumPys memmaps are array-like objects. This differs from Pythons <code>mmap</code> module, which uses file-like objects.</p>
<p>This subclass of ndarray has some unpleasant interactions with some operations, because it doesnt quite fit properly as a subclass. An alternative to using this subclass is to create the <code>mmap</code> object yourself, then create an ndarray with ndarray.__new__ directly, passing the object created in its buffer= parameter.</p>
<p>This class may at some point be turned into a factory function which returns a view into an mmap buffer.</p>
<p>Delete the memmap instance to close the memmap file.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>filename : str, file-like object, or pathlib.Path instance  The file name or file object to be used as the array data buffer. dtype : data-type, optional  The data-type used to interpret the file contents.  Default is <code>uint8</code>. mode : {r+, r, w+, c}, optional  The file is opened in this mode:</p>
<pre><code>+------+-------------------------------------------------------------+
| 'r'  | Open existing file for reading only.                        |
+------+-------------------------------------------------------------+
| 'r+' | Open existing file for reading and writing.                 |
+------+-------------------------------------------------------------+
| 'w+' | Create or overwrite existing file for reading and writing.  |
+------+-------------------------------------------------------------+
| 'c'  | Copy-on-write: assignments affect data in memory, but       |
|      | changes are not saved to disk.  The file on disk is         |
|      | read-only.                                                  |
+------+-------------------------------------------------------------+

Default is 'r+'.
</code></pre>
<p>offset : int, optional  In the file, array data starts at this offset. Since <code>offset</code> is  measured in bytes, it should normally be a multiple of the byte-size  of <code>dtype</code>. When <code>mode != 'r'</code>, even positive offsets beyond end of  file are valid; The file will be extended to accommodate the  additional data. By default, <code>memmap</code> will start at the beginning of  the file, even if <code>filename</code> is a file pointer <code>fp</code> and  <code>fp.tell() != 0</code>. shape : tuple, optional  The desired shape of the array. If <code>mode == 'r'</code> and the number  of remaining bytes after <code>offset</code> is not a multiple of the byte-size  of <code>dtype</code>, you must specify <code>shape</code>. By default, the returned array  will be 1-D with the number of elements determined by file size  and data-type. order : {C, F}, optional  Specify the order of the ndarray memory layout:  :term:<code>row-major</code>, C-style or :term:<code>column-major</code>,  Fortran-style. This only has an effect if the shape is  greater than 1-D. The default order is C.</p>
<h2><a href="#attributes" name="attributes"></a>Attributes</h2>
<p>filename : str or pathlib.Path instance  Path to the mapped file. offset : int  Offset position in the file. mode : str  File mode.</p>
<h2><a href="#methods" name="methods"></a>Methods</h2>
<p>flush  Flush any changes in memory to file on disk.  When you delete a memmap object, flush is called first to write  changes to disk before removing the object.</p>
<h2><a href="#see-also" name="see-also"></a>See also</h2>
<p>lib.format.open_memmap : Create or load a memory-mapped <code>.npy</code> file.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The memmap object can be used anywhere an ndarray is accepted. Given a memmap <code>fp</code>, <code>isinstance(fp, numpy.ndarray)</code> returns <code>True</code>.</p>
<p>Memory-mapped files cannot be larger than 2GB on 32-bit systems.</p>
<p>When a memmap causes a file to be created or extended beyond its current size in the filesystem, the contents of the new part are unspecified. On systems with POSIX filesystem semantics, the extended part will be filled with zero bytes.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>data = np.arange(12, dtype=float32) data.resize((3,4))</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>This example uses a temporary file so that doctest doesnt write files to your directory. You would use a normal filename.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>from tempfile import mkdtemp import os.path as path filename = path.join(mkdtemp(), newfile.dat)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Create a memmap with dtype and shape that matches our data:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>fp = np.memmap(filename, dtype=float32, mode=w+, shape=(3,4)) fp memmap(<a href="null">0., 0., 0., 0.],
        [0., 0., 0., 0.],
        [0., 0., 0., 0.</a>, dtype=float32)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Write data to memmap array:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>fp[:] = data[:] fp memmap(<a href="null">  0.,   1.,   2.,   3.],
        [  4.,   5.,   6.,   7.],
        [  8.,   9.,  10.,  11.</a>, dtype=float32)</p>
      <p>fp.filename == path.abspath(filename) True</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Deletion flushes memory changes to disk before removing the object:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>del fp</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Load the memmap and verify data was stored:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>newfp = np.memmap(filename, dtype=float32, mode=r, shape=(3,4)) newfp memmap(<a href="null">  0.,   1.,   2.,   3.],
        [  4.,   5.,   6.,   7.],
        [  8.,   9.,  10.,  11.</a>, dtype=float32)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Read-only memmap:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>fpr = np.memmap(filename, dtype=float32, mode=r, shape=(3,4)) fpr.flags.writeable False</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Copy-on-write memmap:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>fpc = np.memmap(filename, dtype=float32, mode=c, shape=(3,4)) fpc.flags.writeable True</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Its possible to assign to copy-on-write array, but values are only written into the memory copy of the array, and not written to disk:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>fpc memmap(<a href="null">  0.,   1.,   2.,   3.],
        [  4.,   5.,   6.,   7.],
        [  8.,   9.,  10.,  11.</a>, dtype=float32) fpc[0,:] = 0 fpc memmap(<a href="null">  0.,   0.,   0.,   0.],
        [  4.,   5.,   6.,   7.],
        [  8.,   9.,  10.,  11.</a>, dtype=float32)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>File on disk is unchanged:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>fpr memmap(<a href="null">  0.,   1.,   2.,   3.],
        [  4.,   5.,   6.,   7.],
        [  8.,   9.,  10.,  11.</a>, dtype=float32)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Offset into a memmap:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>fpo = np.memmap(filename, dtype=float32, mode=r, offset=16) fpo memmap([ 4., 5., 6., 7., 8., 9., 10., 11.], dtype=float32)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L8592">view source</a></div></div><div class="public anchor" id="var-meshgrid"><h3>meshgrid</h3><div class="usage"><code>(meshgrid &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return coordinate matrices from coordinate vectors.</p>
<p>Make N-D coordinate arrays for vectorized evaluations of N-D scalar/vector fields over N-D grids, given one-dimensional coordinate arrays x1, x2,, xn.</p>
<p>.. versionchanged:: 1.9  1-D and 0-D cases are allowed.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x1, x2,, xn : array_like  1-D arrays representing the coordinates of a grid. indexing : {xy, ij}, optional  Cartesian (xy, default) or matrix (ij) indexing of output.  See Notes for more details.</p>
<pre><code>.. versionadded:: 1.7.0
</code></pre>
<p>sparse : bool, optional  If True a sparse grid is returned in order to conserve memory.  Default is False.</p>
<pre><code>.. versionadded:: 1.7.0
</code></pre>
<p>copy : bool, optional  If False, a view into the original arrays are returned in order to  conserve memory. Default is True. Please note that  <code>sparse=False, copy=False</code> will likely return non-contiguous  arrays. Furthermore, more than one element of a broadcast array  may refer to a single memory location. If you need to write to the  arrays, make copies first.</p>
<pre><code>.. versionadded:: 1.7.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>X1, X2,, XN : ndarray  For vectors <code>x1</code>, <code>x2</code>,, xn with lengths <code>Ni=len(xi)</code> ,  return <code>(N1, N2, N3,...Nn)</code> shaped arrays if indexing=ij  or <code>(N2, N1, N3,...Nn)</code> shaped arrays if indexing=xy  with the elements of <code>xi</code> repeated to fill the matrix along  the first dimension for <code>x1</code>, the second for <code>x2</code> and so on.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>This function supports both indexing conventions through the indexing keyword argument. Giving the string ij returns a meshgrid with matrix indexing, while xy returns a meshgrid with Cartesian indexing. In the 2-D case with inputs of length M and N, the outputs are of shape (N, M) for xy indexing and (M, N) for ij indexing. In the 3-D case with inputs of length M, N and P, outputs are of shape (N, M, P) for xy indexing and (M, N, P) for ij indexing. The difference is illustrated by the following code snippet::</p>
<pre><code>xv, yv = np.meshgrid(x, y, sparse=False, indexing='ij')
for i in range(nx):
    for j in range(ny):
        # treat xv[i,j], yv[i,j]

xv, yv = np.meshgrid(x, y, sparse=False, indexing='xy')
for i in range(nx):
    for j in range(ny):
        # treat xv[j,i], yv[j,i]
</code></pre>
<p>In the 1-D and 0-D case, the indexing and sparse keywords have no effect.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>index_tricks.mgrid : Construct a multi-dimensional meshgrid  using indexing notation. index_tricks.ogrid : Construct an open multi-dimensional meshgrid  using indexing notation.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>nx, ny = (3, 2) x = np.linspace(0, 1, nx) y = np.linspace(0, 1, ny) xv, yv = np.meshgrid(x, y) xv array(<a href="null">0. , 0.5, 1. ],
       [0. , 0.5, 1. </a>) yv array(<a href="null">0.,  0.,  0.],
       [1.,  1.,  1.</a>) xv, yv = np.meshgrid(x, y, sparse=True) # make sparse output arrays xv array(<a href="null">0. ,  0.5,  1. </a>) yv array(<a href="null">0.],
       [1.</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p><code>meshgrid</code> is very useful to evaluate functions on a grid.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>import matplotlib.pyplot as plt x = np.arange(-5, 5, 0.1) y = np.arange(-5, 5, 0.1) xx, yy = np.meshgrid(x, y, sparse=True) z = np.sin(xx**2 + yy**2) / (xx**2 + yy**2) h = plt.contourf(x,y,z) plt.show()</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L28614">view source</a></div></div><div class="public anchor" id="var-mgrid"><h3>mgrid</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>nd_grid</code> instance which returns a dense multi-dimensional meshgrid.</p>
<p>An instance of <code>numpy.lib.index_tricks.nd_grid</code> which returns an dense (or fleshed out) mesh-grid when indexed, so that each returned argument has the same shape. The dimensions and number of the output arrays are equal to the number of indexing dimensions. If the step length is not a complex number, then the stop is not inclusive.</p>
<p>However, if the step length is a <strong>complex number</strong> (e.g. 5j), then the integer part of its magnitude is interpreted as specifying the number of points to create between the start and stop values, where the stop value <strong>is inclusive</strong>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>mesh-grid <code>ndarrays</code> all of the same dimensions</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>numpy.lib.index_tricks.nd_grid : class of <code>ogrid</code> and <code>mgrid</code> objects ogrid : like mgrid but returns open (not fleshed out) mesh grids r_ : array concatenator</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.mgrid[0:5,0:5] array(<a href="null">[0, 0, 0, 0, 0],
        [1, 1, 1, 1, 1],
        [2, 2, 2, 2, 2],
        [3, 3, 3, 3, 3],
        [4, 4, 4, 4, 4</a>,  <a href="null">0, 1, 2, 3, 4],
        [0, 1, 2, 3, 4],
        [0, 1, 2, 3, 4],
        [0, 1, 2, 3, 4],
        [0, 1, 2, 3, 4</a>]) np.mgrid[-1:1:5j] array([-1. , -0.5, 0. , 0.5, 1. ])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L4997">view source</a></div></div><div class="public anchor" id="var-min"><h3>min</h3><div class="usage"><code>(min &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return the minimum of an array or minimum along an axis.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input data. axis : None or int or tuple of ints, optional  Axis or axes along which to operate. By default, flattened input is  used.</p>
<pre><code>.. versionadded:: 1.7.0

If this is a tuple of ints, the minimum is selected over multiple axes,
instead of a single axis or all the axes as before.
</code></pre>
<p>out : ndarray, optional  Alternative output array in which to place the result. Must  be of the same shape and buffer length as the expected output.  See <code>ufuncs-output-type</code> for more details.</p>
<p>keepdims : bool, optional  If this is set to True, the axes which are reduced are left  in the result as dimensions with size one. With this option,  the result will broadcast correctly against the input array.</p>
<pre><code>If the default value is passed, then `keepdims` will not be
passed through to the `amin` method of sub-classes of
`ndarray`, however any non-default value will be.  If the
sub-class' method does not implement `keepdims` any
exceptions will be raised.
</code></pre>
<p>initial : scalar, optional  The maximum value of an output element. Must be present to allow  computation on empty slice. See <code>~numpy.ufunc.reduce</code> for details.</p>
<pre><code>.. versionadded:: 1.15.0
</code></pre>
<p>where : array_like of bool, optional  Elements to compare for the minimum. See <code>~numpy.ufunc.reduce</code>  for details.</p>
<pre><code>.. versionadded:: 1.17.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>amin : ndarray or scalar  Minimum of <code>a</code>. If <code>axis</code> is None, the result is a scalar value.  If <code>axis</code> is given, the result is an array of dimension  <code>a.ndim - 1</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>amax :  The maximum value of an array along a given axis, propagating any NaNs. nanmin :  The minimum value of an array along a given axis, ignoring any NaNs. minimum :  Element-wise minimum of two arrays, propagating any NaNs. fmin :  Element-wise minimum of two arrays, ignoring any NaNs. argmin :  Return the indices of the minimum values.</p>
<p>nanmax, maximum, fmax</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>NaN values are propagated, that is if at least one item is NaN, the corresponding min value will be NaN as well. To ignore NaN values (MATLAB behavior), please use nanmin.</p>
<p>Dont use <code>amin</code> for element-wise comparison of 2 arrays; when <code>a.shape[0]</code> is 2, <code>minimum(a[0], a[1])</code> is faster than <code>amin(a, axis=0)</code>.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.arange(4).reshape((2,2)) a array(<a href="null">0, 1],
       [2, 3</a>) np.amin(a) # Minimum of the flattened array 0 np.amin(a, axis=0) # Minima along the first axis array([0, 1]) np.amin(a, axis=1) # Minima along the second axis array([0, 2]) np.amin(a, where=[False, True], initial=10, axis=0) array([10, 1])</p>
      <p>b = np.arange(5, dtype=float) b[2] = np.NaN np.amin(b) nan np.amin(b, where=~np.isnan(b), initial=10) 0.0 np.nanmin(b) 0.0</p>
      <p>np.min(<a href="null">-50], [10</a>, axis=-1, initial=0) array([-50, 0])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Notice that the initial value is used as one of the elements for which the minimum is determined, unlike for the default argument Pythons max function, which is only used for empty iterables.</p>
<p>Notice that this isnt the same as Pythons <code>default</code> argument.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.min([6], initial=5) 5 min([6], default=5) 6</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L1801">view source</a></div></div><div class="public anchor" id="var-min_scalar_type"><h3>min_scalar_type</h3><div class="usage"><code>(min_scalar_type &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>min_scalar_type(a)</p>
<p>For scalar <code>a</code>, returns the data type with the smallest size and smallest scalar kind which can hold its value. For non-scalar array <code>a</code>, returns the vectors dtype unmodified.</p>
<p>Floating point values are not demoted to integers, and complex values are not demoted to floats.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : scalar or array_like  The value whose minimal data type is to be found.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : dtype  The minimal data type.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>.. versionadded:: 1.6.0</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>result_type, promote_types, dtype, can_cast</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.min_scalar_type(10) dtype(uint8)</p>
      <p>np.min_scalar_type(-260) dtype(int16)</p>
      <p>np.min_scalar_type(3.1) dtype(float16)</p>
      <p>np.min_scalar_type(1e50) dtype(float64)</p>
      <p>np.min_scalar_type(np.arange(4,dtype=f8)) dtype(float64)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L8045">view source</a></div></div><div class="public anchor" id="var-minimum"><h3>minimum</h3><div class="usage"><code>(minimum self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>minimum(x1, x2, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Element-wise minimum of array elements.</p>
<p>Compare two arrays and returns a new array containing the element-wise minima. If one of the elements being compared is a NaN, then that element is returned. If both elements are NaNs then the first is returned. The latter distinction is important for complex NaNs, which are defined as at least one of the real or imaginary parts being a NaN. The net effect is that NaNs are propagated.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x1, x2 : array_like  The arrays holding the elements to be compared. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output). out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray or scalar  The minimum of <code>x1</code> and <code>x2</code>, element-wise.  This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>maximum :  Element-wise maximum of two arrays, propagates NaNs. fmin :  Element-wise minimum of two arrays, ignores NaNs. amin :  The minimum value of an array along a given axis, propagates NaNs. nanmin :  The minimum value of an array along a given axis, ignores NaNs.</p>
<p>fmax, amax, nanmax</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The minimum is equivalent to <code>np.where(x1 &lt;= x2, x1, x2)</code> when neither x1 nor x2 are NaNs, but it is faster and does proper broadcasting.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.minimum([2, 3, 4], [1, 5, 2]) array([1, 3, 2])</p>
      <p>np.minimum(np.eye(2), [0.5, 2]) # broadcasting array(<a href="null"> 0.5,  0. ],
       [ 0. ,  1. </a>)</p>
      <p>np.minimum([np.nan, 0, np.nan],[0, np.nan, np.nan]) array([nan, nan, nan]) np.minimum(-np.Inf, 1) -inf</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L10511">view source</a></div></div><div class="public anchor" id="var-mintypecode"><h3>mintypecode</h3><div class="usage"><code>(mintypecode typechars &amp; [{typeset :typeset, default :default}])</code><code>(mintypecode typechars &amp; [{typeset :typeset}])</code><code>(mintypecode typechars)</code></div><div class="doc"><div class="markdown"><p>Return the character for the minimum-size type to which given types can be safely cast.</p>
<p>The returned type character must represent the smallest size dtype such that an array of the returned type can handle the data from an array of all types in <code>typechars</code> (or if <code>typechars</code> is an array, then its dtype.char).</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>typechars : list of str or array_like  If a list of strings, each string should represent a dtype.  If array_like, the character representation of the array dtype is used. typeset : str or list of str, optional  The set of characters that the returned character is chosen from.  The default set is GDFgdf. default : str, optional  The default character, this is returned if none of the characters in  <code>typechars</code> matches a character in <code>typeset</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>typechar : str  The character representing the minimum-size type that was found.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>dtype, sctype2char, maximum_sctype</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.mintypecode([d, f, S]) d x = np.array([1.1, 2-3.j]) np.mintypecode(x) D</p>
      <p>np.mintypecode(abceh, default=G) G</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L8217">view source</a></div></div><div class="public anchor" id="var-mirr"><h3>mirr</h3><div class="usage"><code>(mirr &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Modified internal rate of return.</p>
<p>.. deprecated:: 1.18</p>
<p><code>mirr</code> is deprecated; for details, see NEP 32 [1]_.  Use the corresponding function in the numpy-financial library,  <a href="https://pypi.org/project/numpy-financial">https://pypi.org/project/numpy-financial</a>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>values : array_like  Cash flows (must contain at least one positive and one negative  value) or nan is returned. The first value is considered a sunk  cost at time zero. finance_rate : scalar  Interest rate paid on the cash flows reinvest_rate : scalar  Interest rate received on the cash flows upon reinvestment</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : float  Modified internal rate of return</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [1] NumPy Enhancement Proposal (NEP) 32,  <a href="https://numpy.org/neps/nep-0032-remove-financial-functions.html">https://numpy.org/neps/nep-0032-remove-financial-functions.html</a></p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L19962">view source</a></div></div><div class="public anchor" id="var-mod"><h3>mod</h3><div class="usage"><code>(mod self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>remainder(x1, x2, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Return element-wise remainder of division.</p>
<p>Computes the remainder complementary to the <code>floor_divide</code> function. It is equivalent to the Python modulus operator<code>x1 % x2</code> and has the same sign as the divisor <code>x2</code>. The MATLAB function equivalent to <code>np.remainder</code> is <code>mod</code>.</p>
<p>.. warning::</p>
<pre><code>This should not be confused with:

* Python 3.7's `math.remainder` and C's ``remainder``, which
  computes the IEEE remainder, which are the complement to
  ``round(x1 / x2)``.
* The MATLAB ``rem`` function and or the C ``%`` operator which is the
  complement to ``int(x1 / x2)``.
</code></pre>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x1 : array_like  Dividend array. x2 : array_like  Divisor array. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output). out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray  The element-wise remainder of the quotient <code>floor_divide(x1, x2)</code>.  This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>floor_divide : Equivalent of Python <code>//</code> operator. divmod : Simultaneous floor division and remainder. fmod : Equivalent of the MATLAB <code>rem</code> function. divide, floor</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Returns 0 when <code>x2</code> is 0 and both <code>x1</code> and <code>x2</code> are (arrays of) integers. <code>mod</code> is an alias of <code>remainder</code>.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.remainder([4, 7], [2, 3]) array([0, 1]) np.remainder(np.arange(7), 5) array([0, 1, 2, 3, 4, 0, 1])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L19894">view source</a></div></div><div class="public anchor" id="var-modf"><h3>modf</h3><div class="usage"><code>(modf self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>modf(x[, out1, out2], / [, out=(None, None)], *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Return the fractional and integral parts of an array, element-wise.</p>
<p>The fractional and integral parts are negative if the given number is negative.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Input array. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y1 : ndarray  Fractional part of <code>x</code>.  This is a scalar if <code>x</code> is a scalar. y2 : ndarray  Integral part of <code>x</code>.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>For integer input the return values are floats.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>divmod : <code>divmod(x, 1)</code> is equivalent to <code>modf</code> with the return values  switched, except it always has a positive remainder.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.modf([0, 3.5]) (array([ 0. , 0.5]), array([ 0., 3.])) np.modf(-0.5) (-0.5, -0)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L28802">view source</a></div></div><div class="public anchor" id="var-ModuleDeprecationWarning"><h3>ModuleDeprecationWarning</h3><div class="usage"><code>(ModuleDeprecationWarning self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Module deprecation warning.</p>
<p>The nose tester turns ordinary Deprecation warnings into test failures. That makes it hard to deprecate whole modules, because they get imported by default. So this is a special Deprecation warning that the nose tester will let pass without making tests fail.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L20294">view source</a></div></div><div class="public anchor" id="var-moveaxis"><h3>moveaxis</h3><div class="usage"><code>(moveaxis &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Move axes of an array to new positions.</p>
<p>Other axes remain in their original order.</p>
<p>.. versionadded:: 1.11.0</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : np.ndarray  The array whose axes should be reordered. source : int or sequence of int  Original positions of the axes to move. These must be unique. destination : int or sequence of int  Destination positions for each of the original axes. These must also be  unique.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>result : np.ndarray  Array with moved axes. This array is a view of the input array.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>transpose: Permute the dimensions of an array. swapaxes: Interchange two axes of an array.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.zeros((3, 4, 5)) np.moveaxis(x, 0, -1).shape (4, 5, 3) np.moveaxis(x, -1, 0).shape (5, 3, 4)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>These all achieve the same result:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.transpose(x).shape (5, 4, 3) np.swapaxes(x, 0, -1).shape (5, 4, 3) np.moveaxis(x, [0, 1], [-1, -2]).shape (5, 4, 3) np.moveaxis(x, [0, 1, 2], [-1, -2, -3]).shape (5, 4, 3)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L28193">view source</a></div></div><div class="public anchor" id="var-msort"><h3>msort</h3><div class="usage"><code>(msort &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return a copy of an array sorted along the first axis.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Array to be sorted.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>sorted_array : ndarray  Array of the same type and shape as <code>a</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>sort</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p><code>np.msort(a)</code> is equivalent to <code>np.sort(a, axis=0)</code>.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L6165">view source</a></div></div><div class="public anchor" id="var-multiply"><h3>multiply</h3><div class="usage"><code>(multiply self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>multiply(x1, x2, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Multiply arguments element-wise.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x1, x2 : array_like  Input arrays to be multiplied. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output). out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray  The product of <code>x1</code> and <code>x2</code>, element-wise.  This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Equivalent to <code>x1</code> * <code>x2</code> in terms of array broadcasting.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.multiply(2.0, 4.0) 8.0</p>
      <p>x1 = np.arange(9.0).reshape((3, 3)) x2 = np.arange(3.0) np.multiply(x1, x2) array(<a href="null">  0.,   1.,   4.],
       [  0.,   4.,  10.],
       [  0.,   7.,  16.</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L5364">view source</a></div></div><div class="public anchor" id="var-NAN"><h3>NAN</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L14127">view source</a></div></div><div class="public anchor" id="var-NaN"><h3>NaN</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L201">view source</a></div></div><div class="public anchor" id="var-nan"><h3>nan</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L12502">view source</a></div></div><div class="public anchor" id="var-nan_to_num"><h3>nan_to_num</h3><div class="usage"><code>(nan_to_num &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Replace NaN with zero and infinity with large finite numbers (default behaviour) or with the numbers defined by the user using the <code>nan</code>, <code>posinf</code> and/or <code>neginf</code> keywords.</p>
<p>If <code>x</code> is inexact, NaN is replaced by zero or by the user defined value in <code>nan</code> keyword, infinity is replaced by the largest finite floating point values representable by <code>x.dtype</code> or by the user defined value in <code>posinf</code> keyword and -infinity is replaced by the most negative finite floating point values representable by <code>x.dtype</code> or by the user defined value in <code>neginf</code> keyword.</p>
<p>For complex dtypes, the above is applied to each of the real and imaginary components of <code>x</code> separately.</p>
<p>If <code>x</code> is not inexact, then no replacements are made.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : scalar or array_like  Input data. copy : bool, optional  Whether to create a copy of <code>x</code> (True) or to replace values  in-place (False). The in-place operation only occurs if  casting to an array does not require a copy.  Default is True.</p>
<pre><code>.. versionadded:: 1.13
</code></pre>
<p>nan : int, float, optional  Value to be used to fill NaN values. If no value is passed  then NaN values will be replaced with 0.0.</p>
<pre><code>.. versionadded:: 1.17
</code></pre>
<p>posinf : int, float, optional  Value to be used to fill positive infinity values. If no value is  passed then positive infinity values will be replaced with a very  large number.</p>
<pre><code>.. versionadded:: 1.17
</code></pre>
<p>neginf : int, float, optional  Value to be used to fill negative infinity values. If no value is  passed then negative infinity values will be replaced with a very  small (or negative) number.</p>
<pre><code>.. versionadded:: 1.17
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  <code>x</code>, with the non-finite values replaced. If <code>copy</code> is False, this may  be <code>x</code> itself.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>isinf : Shows which elements are positive or negative infinity. isneginf : Shows which elements are negative infinity. isposinf : Shows which elements are positive infinity. isnan : Shows which elements are Not a Number (NaN). isfinite : Shows which elements are finite (not NaN, not infinity)</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754). This means that Not a Number is not equivalent to infinity.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.nan_to_num(np.inf) 1.7976931348623157e+308 np.nan_to_num(-np.inf) -1.7976931348623157e+308 np.nan_to_num(np.nan) 0.0 x = np.array([np.inf, -np.inf, np.nan, -128, 128]) np.nan_to_num(x) array([ 1.79769313e+308, -1.79769313e+308, 0.00000000e+000, # may vary  -1.28000000e+002, 1.28000000e+002]) np.nan_to_num(x, nan=-9999, posinf=33333333, neginf=33333333) array([ 3.3333333e+07, 3.3333333e+07, -9.9990000e+03,  -1.2800000e+02, 1.2800000e+02]) y = np.array([complex(np.inf, np.nan), np.nan, complex(np.nan, np.inf)]) array([ 1.79769313e+308, -1.79769313e+308, 0.00000000e+000, # may vary  -1.28000000e+002, 1.28000000e+002]) np.nan_to_num(y) array([ 1.79769313e+308 +0.00000000e+000j, # may vary  0.00000000e+000 +0.00000000e+000j,  0.00000000e+000 +1.79769313e+308j]) np.nan_to_num(y, nan=111111, posinf=222222) array([222222.+111111.j, 111111. +0.j, 111111.+222222.j])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L24186">view source</a></div></div><div class="public anchor" id="var-nanargmax"><h3>nanargmax</h3><div class="usage"><code>(nanargmax &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return the indices of the maximum values in the specified axis ignoring NaNs. For all-NaN slices <code>ValueError</code> is raised. Warning: the results cannot be trusted if a slice contains only NaNs and -Infs.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input data. axis : int, optional  Axis along which to operate. By default flattened input is used.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>index_array : ndarray  An array of indices or a single index value.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>argmax, nanargmin</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array(<a href="null">np.nan, 4], [2, 3</a>) np.argmax(a) 0 np.nanargmax(a) 1 np.nanargmax(a, axis=0) array([1, 0]) np.nanargmax(a, axis=1) array([1, 1])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L17528">view source</a></div></div><div class="public anchor" id="var-nanargmin"><h3>nanargmin</h3><div class="usage"><code>(nanargmin &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return the indices of the minimum values in the specified axis ignoring NaNs. For all-NaN slices <code>ValueError</code> is raised. Warning: the results cannot be trusted if a slice contains only NaNs and Infs.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input data. axis : int, optional  Axis along which to operate. By default flattened input is used.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>index_array : ndarray  An array of indices or a single index value.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>argmin, nanargmax</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array(<a href="null">np.nan, 4], [2, 3</a>) np.argmin(a) 0 np.nanargmin(a) 2 np.nanargmin(a, axis=0) array([1, 1]) np.nanargmin(a, axis=1) array([1, 0])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L7968">view source</a></div></div><div class="public anchor" id="var-nancumprod"><h3>nancumprod</h3><div class="usage"><code>(nancumprod &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return the cumulative product of array elements over a given axis treating Not a Numbers (NaNs) as one. The cumulative product does not change when NaNs are encountered and leading NaNs are replaced by ones.</p>
<p>Ones are returned for slices that are all-NaN or empty.</p>
<p>.. versionadded:: 1.12.0</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input array. axis : int, optional  Axis along which the cumulative product is computed. By default  the input is flattened. dtype : dtype, optional  Type of the returned array, as well as of the accumulator in which  the elements are multiplied. If <em>dtype</em> is not specified, it  defaults to the dtype of <code>a</code>, unless <code>a</code> has an integer dtype with  a precision less than that of the default platform integer. In  that case, the default platform integer is used instead. out : ndarray, optional  Alternative output array in which to place the result. It must  have the same shape and buffer length as the expected output  but the type of the resulting values will be cast if necessary.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>nancumprod : ndarray  A new array holding the result is returned unless <code>out</code> is  specified, in which case it is returned.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>numpy.cumprod : Cumulative product across array propagating NaNs. isnan : Show which elements are NaN.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.nancumprod(1) array([1]) np.nancumprod([1]) array([1]) np.nancumprod([1, np.nan]) array([1., 1.]) a = np.array(<a href="null">1, 2], [3, np.nan</a>) np.nancumprod(a) array([1., 2., 6., 6.]) np.nancumprod(a, axis=0) array(<a href="null">1.,  2.],
       [3.,  2.</a>) np.nancumprod(a, axis=1) array(<a href="null">1.,  2.],
       [3.,  3.</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L13088">view source</a></div></div><div class="public anchor" id="var-nancumsum"><h3>nancumsum</h3><div class="usage"><code>(nancumsum &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return the cumulative sum of array elements over a given axis treating Not a Numbers (NaNs) as zero. The cumulative sum does not change when NaNs are encountered and leading NaNs are replaced by zeros.</p>
<p>Zeros are returned for slices that are all-NaN or empty.</p>
<p>.. versionadded:: 1.12.0</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input array. axis : int, optional  Axis along which the cumulative sum is computed. The default  (None) is to compute the cumsum over the flattened array. dtype : dtype, optional  Type of the returned array and of the accumulator in which the  elements are summed. If <code>dtype</code> is not specified, it defaults  to the dtype of <code>a</code>, unless <code>a</code> has an integer dtype with a  precision less than that of the default platform integer. In  that case, the default platform integer is used. out : ndarray, optional  Alternative output array in which to place the result. It must  have the same shape and buffer length as the expected output  but the type will be cast if necessary. See <code>ufuncs-output-type</code> for  more details.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>nancumsum : ndarray.  A new array holding the result is returned unless <code>out</code> is  specified, in which it is returned. The result has the same  size as <code>a</code>, and the same shape as <code>a</code> if <code>axis</code> is not None  or <code>a</code> is a 1-d array.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>numpy.cumsum : Cumulative sum across array propagating NaNs. isnan : Show which elements are NaN.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.nancumsum(1) array([1]) np.nancumsum([1]) array([1]) np.nancumsum([1, np.nan]) array([1., 1.]) a = np.array(<a href="null">1, 2], [3, np.nan</a>) np.nancumsum(a) array([1., 3., 6., 6.]) np.nancumsum(a, axis=0) array(<a href="null">1.,  2.],
       [4.,  2.</a>) np.nancumsum(a, axis=1) array(<a href="null">1.,  3.],
       [3.,  3.</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L10188">view source</a></div></div><div class="public anchor" id="var-nanmax"><h3>nanmax</h3><div class="usage"><code>(nanmax &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return the maximum of an array or maximum along an axis, ignoring any NaNs. When all-NaN slices are encountered a <code>RuntimeWarning</code> is raised and NaN is returned for that slice.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Array containing numbers whose maximum is desired. If <code>a</code> is not an  array, a conversion is attempted. axis : {int, tuple of int, None}, optional  Axis or axes along which the maximum is computed. The default is to compute  the maximum of the flattened array. out : ndarray, optional  Alternate output array in which to place the result. The default  is <code>None</code>; if provided, it must have the same shape as the  expected output, but the type will be cast if necessary. See  <code>ufuncs-output-type</code> for more details.</p>
<pre><code>.. versionadded:: 1.8.0
</code></pre>
<p>keepdims : bool, optional  If this is set to True, the axes which are reduced are left  in the result as dimensions with size one. With this option,  the result will broadcast correctly against the original <code>a</code>.</p>
<pre><code>If the value is anything but the default, then
`keepdims` will be passed through to the `max` method
of sub-classes of `ndarray`.  If the sub-classes methods
does not implement `keepdims` any exceptions will be raised.

.. versionadded:: 1.8.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>nanmax : ndarray  An array with the same shape as <code>a</code>, with the specified axis removed.  If <code>a</code> is a 0-d array, or if axis is None, an ndarray scalar is  returned. The same dtype as <code>a</code> is returned.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>nanmin :  The minimum value of an array along a given axis, ignoring any NaNs. amax :  The maximum value of an array along a given axis, propagating any NaNs. fmax :  Element-wise maximum of two arrays, ignoring any NaNs. maximum :  Element-wise maximum of two arrays, propagating any NaNs. isnan :  Shows which elements are Not a Number (NaN). isfinite:  Shows which elements are neither NaN nor infinity.</p>
<p>amin, fmin, minimum</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754). This means that Not a Number is not equivalent to infinity. Positive infinity is treated as a very large number and negative infinity is treated as a very small (i.e. negative) number.</p>
<p>If the input has a integer type the function is equivalent to np.max.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array(<a href="null">1, 2], [3, np.nan</a>) np.nanmax(a) 3.0 np.nanmax(a, axis=0) array([3., 2.]) np.nanmax(a, axis=1) array([2., 3.])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>When positive infinity and negative infinity are present:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.nanmax([1, 2, np.nan, np.NINF]) 2.0 np.nanmax([1, 2, np.nan, np.inf]) inf</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L1034">view source</a></div></div><div class="public anchor" id="var-nanmean"><h3>nanmean</h3><div class="usage"><code>(nanmean &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Compute the arithmetic mean along the specified axis, ignoring NaNs.</p>
<p>Returns the average of the array elements. The average is taken over the flattened array by default, otherwise over the specified axis. <code>float64</code> intermediate and return values are used for integer inputs.</p>
<p>For all-NaN slices, NaN is returned and a <code>RuntimeWarning</code> is raised.</p>
<p>.. versionadded:: 1.8.0</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Array containing numbers whose mean is desired. If <code>a</code> is not an  array, a conversion is attempted. axis : {int, tuple of int, None}, optional  Axis or axes along which the means are computed. The default is to compute  the mean of the flattened array. dtype : data-type, optional  Type to use in computing the mean. For integer inputs, the default  is <code>float64</code>; for inexact inputs, it is the same as the input  dtype. out : ndarray, optional  Alternate output array in which to place the result. The default  is <code>None</code>; if provided, it must have the same shape as the  expected output, but the type will be cast if necessary. See  <code>ufuncs-output-type</code> for more details. keepdims : bool, optional  If this is set to True, the axes which are reduced are left  in the result as dimensions with size one. With this option,  the result will broadcast correctly against the original <code>a</code>.</p>
<pre><code>If the value is anything but the default, then
`keepdims` will be passed through to the `mean` or `sum` methods
of sub-classes of `ndarray`.  If the sub-classes methods
does not implement `keepdims` any exceptions will be raised.
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>m : ndarray, see dtype parameter above  If <code>out=None</code>, returns a new array containing the mean values,  otherwise a reference to the output array is returned. Nan is  returned for slices that contain only NaNs.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>average : Weighted average mean : Arithmetic mean taken while not ignoring NaNs var, nanvar</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The arithmetic mean is the sum of the non-NaN elements along the axis divided by the number of non-NaN elements.</p>
<p>Note that for floating-point input, the mean is computed using the same precision the input has. Depending on the input data, this can cause the results to be inaccurate, especially for <code>float32</code>. Specifying a higher-precision accumulator using the <code>dtype</code> keyword can alleviate this issue.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array(<a href="null">1, np.nan], [3, 4</a>) np.nanmean(a) 2.6666666666666665 np.nanmean(a, axis=0) array([2., 4.]) np.nanmean(a, axis=1) array([1., 3.5]) # may vary</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L25342">view source</a></div></div><div class="public anchor" id="var-nanmedian"><h3>nanmedian</h3><div class="usage"><code>(nanmedian &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Compute the median along the specified axis, while ignoring NaNs.</p>
<p>Returns the median of the array elements.</p>
<p>.. versionadded:: 1.9.0</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input array or object that can be converted to an array. axis : {int, sequence of int, None}, optional  Axis or axes along which the medians are computed. The default  is to compute the median along a flattened version of the array.  A sequence of axes is supported since version 1.9.0. out : ndarray, optional  Alternative output array in which to place the result. It must  have the same shape and buffer length as the expected output,  but the type (of the output) will be cast if necessary. overwrite_input : bool, optional  If True, then allow use of memory of input array <code>a</code> for  calculations. The input array will be modified by the call to  <code>median</code>. This will save memory when you do not need to preserve  the contents of the input array. Treat the input as undefined,  but it will probably be fully or partially sorted. Default is  False. If <code>overwrite_input</code> is <code>True</code> and <code>a</code> is not already an  <code>ndarray</code>, an error will be raised. keepdims : bool, optional  If this is set to True, the axes which are reduced are left  in the result as dimensions with size one. With this option,  the result will broadcast correctly against the original <code>a</code>.</p>
<pre><code>If this is anything but the default value it will be passed
through (in the special case of an empty array) to the
`mean` function of the underlying array.  If the array is
a sub-class and `mean` does not have the kwarg `keepdims` this
will raise a RuntimeError.
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>median : ndarray  A new array holding the result. If the input contains integers  or floats smaller than <code>float64</code>, then the output data-type is  <code>np.float64</code>. Otherwise, the data-type of the output is the  same as that of the input. If <code>out</code> is specified, that array is  returned instead.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>mean, median, percentile</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Given a vector <code>V</code> of length <code>N</code>, the median of <code>V</code> is the middle value of a sorted copy of <code>V</code>, <code>V_sorted</code> - i.e., <code>V_sorted[(N-1)/2]</code>, when <code>N</code> is odd and the average of the two middle values of <code>V_sorted</code> when <code>N</code> is even.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array(<a href="null">10.0, 7, 4], [3, 2, 1</a>) a[0, 1] = np.nan a array(<a href="null">10., nan,  4.],
       [ 3.,  2.,  1.</a>) np.median(a) nan np.nanmedian(a) 3.0 np.nanmedian(a, axis=0) array([6.5, 2. , 2.5]) np.median(a, axis=1) array([nan, 2.]) b = a.copy() np.nanmedian(b, axis=1, overwrite_input=True) array([7., 2.]) assert not np.all(a==b) b = a.copy() np.nanmedian(b, axis=None, overwrite_input=True) 3.0 assert not np.all(a==b)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L25832">view source</a></div></div><div class="public anchor" id="var-nanmin"><h3>nanmin</h3><div class="usage"><code>(nanmin &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return minimum of an array or minimum along an axis, ignoring any NaNs. When all-NaN slices are encountered a <code>RuntimeWarning</code> is raised and Nan is returned for that slice.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Array containing numbers whose minimum is desired. If <code>a</code> is not an  array, a conversion is attempted. axis : {int, tuple of int, None}, optional  Axis or axes along which the minimum is computed. The default is to compute  the minimum of the flattened array. out : ndarray, optional  Alternate output array in which to place the result. The default  is <code>None</code>; if provided, it must have the same shape as the  expected output, but the type will be cast if necessary. See  <code>ufuncs-output-type</code> for more details.</p>
<pre><code>.. versionadded:: 1.8.0
</code></pre>
<p>keepdims : bool, optional  If this is set to True, the axes which are reduced are left  in the result as dimensions with size one. With this option,  the result will broadcast correctly against the original <code>a</code>.</p>
<pre><code>If the value is anything but the default, then
`keepdims` will be passed through to the `min` method
of sub-classes of `ndarray`.  If the sub-classes methods
does not implement `keepdims` any exceptions will be raised.

.. versionadded:: 1.8.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>nanmin : ndarray  An array with the same shape as <code>a</code>, with the specified axis  removed. If <code>a</code> is a 0-d array, or if axis is None, an ndarray  scalar is returned. The same dtype as <code>a</code> is returned.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>nanmax :  The maximum value of an array along a given axis, ignoring any NaNs. amin :  The minimum value of an array along a given axis, propagating any NaNs. fmin :  Element-wise minimum of two arrays, ignoring any NaNs. minimum :  Element-wise minimum of two arrays, propagating any NaNs. isnan :  Shows which elements are Not a Number (NaN). isfinite:  Shows which elements are neither NaN nor infinity.</p>
<p>amax, fmax, maximum</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754). This means that Not a Number is not equivalent to infinity. Positive infinity is treated as a very large number and negative infinity is treated as a very small (i.e. negative) number.</p>
<p>If the input has a integer type the function is equivalent to np.min.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array(<a href="null">1, 2], [3, np.nan</a>) np.nanmin(a) 1.0 np.nanmin(a, axis=0) array([1., 2.]) np.nanmin(a, axis=1) array([1., 3.])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>When positive infinity and negative infinity are present:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.nanmin([1, 2, np.nan, np.inf]) 1.0 np.nanmin([1, 2, np.nan, np.NINF]) -inf</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L17870">view source</a></div></div><div class="public anchor" id="var-nanpercentile"><h3>nanpercentile</h3><div class="usage"><code>(nanpercentile &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Compute the qth percentile of the data along the specified axis, while ignoring nan values.</p>
<p>Returns the qth percentile(s) of the array elements.</p>
<p>.. versionadded:: 1.9.0</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input array or object that can be converted to an array, containing  nan values to be ignored. q : array_like of float  Percentile or sequence of percentiles to compute, which must be between  0 and 100 inclusive. axis : {int, tuple of int, None}, optional  Axis or axes along which the percentiles are computed. The  default is to compute the percentile(s) along a flattened  version of the array. out : ndarray, optional  Alternative output array in which to place the result. It must  have the same shape and buffer length as the expected output,  but the type (of the output) will be cast if necessary. overwrite_input : bool, optional  If True, then allow the input array <code>a</code> to be modified by intermediate  calculations, to save memory. In this case, the contents of the input  <code>a</code> after this function completes is undefined. interpolation : {linear, lower, higher, midpoint, nearest}  This optional parameter specifies the interpolation method to  use when the desired percentile lies between two data points  <code>i &lt; j</code>:</p>
<pre><code>* 'linear': ``i + (j - i) * fraction``, where ``fraction``
  is the fractional part of the index surrounded by ``i``
  and ``j``.
* 'lower': ``i``.
* 'higher': ``j``.
* 'nearest': ``i`` or ``j``, whichever is nearest.
* 'midpoint': ``(i + j) / 2``.
</code></pre>
<p>keepdims : bool, optional  If this is set to True, the axes which are reduced are left in  the result as dimensions with size one. With this option, the  result will broadcast correctly against the original array <code>a</code>.</p>
<pre><code>If this is anything but the default value it will be passed
through (in the special case of an empty array) to the
`mean` function of the underlying array.  If the array is
a sub-class and `mean` does not have the kwarg `keepdims` this
will raise a RuntimeError.
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>percentile : scalar or ndarray  If <code>q</code> is a single percentile and <code>axis=None</code>, then the result  is a scalar. If multiple percentiles are given, first axis of  the result corresponds to the percentiles. The other axes are  the axes that remain after the reduction of <code>a</code>. If the input  contains integers or floats smaller than <code>float64</code>, the output  data-type is <code>float64</code>. Otherwise, the output data-type is the  same as that of the input. If <code>out</code> is specified, that array is  returned instead.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>nanmean nanmedian : equivalent to <code>nanpercentile(..., 50)</code> percentile, median, mean nanquantile : equivalent to nanpercentile, but with q in the range [0, 1].</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Given a vector <code>V</code> of length <code>N</code>, the <code>q</code>-th percentile of <code>V</code> is the value <code>q/100</code> of the way from the minimum to the maximum in a sorted copy of <code>V</code>. The values and distances of the two nearest neighbors as well as the <code>interpolation</code> parameter will determine the percentile if the normalized ranking does not match the location of <code>q</code> exactly. This function is the same as the median if <code>q=50</code>, the same as the minimum if <code>q=0</code> and the same as the maximum if <code>q=100</code>.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array(<a href="null">10., 7., 4.], [3., 2., 1.</a>) a[0][1] = np.nan a array(<a href="null">10.,  nan,   4.],
      [ 3.,   2.,   1.</a>) np.percentile(a, 50) nan np.nanpercentile(a, 50) 3.0 np.nanpercentile(a, 50, axis=0) array([6.5, 2. , 2.5]) np.nanpercentile(a, 50, axis=1, keepdims=True) array(<a href="null">7.],
       [2.</a>) m = np.nanpercentile(a, 50, axis=0) out = np.zeros_like(m) np.nanpercentile(a, 50, axis=0, out=out) array([6.5, 2. , 2.5]) m array([6.5, 2. , 2.5])</p>
      <p>b = a.copy() np.nanpercentile(b, 50, axis=1, overwrite_input=True) array([7., 2.]) assert not np.all(a==b)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L5418">view source</a></div></div><div class="public anchor" id="var-nanprod"><h3>nanprod</h3><div class="usage"><code>(nanprod &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return the product of array elements over a given axis treating Not a Numbers (NaNs) as ones.</p>
<p>One is returned for slices that are all-NaN or empty.</p>
<p>.. versionadded:: 1.10.0</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Array containing numbers whose product is desired. If <code>a</code> is not an  array, a conversion is attempted. axis : {int, tuple of int, None}, optional  Axis or axes along which the product is computed. The default is to compute  the product of the flattened array. dtype : data-type, optional  The type of the returned array and of the accumulator in which the  elements are summed. By default, the dtype of <code>a</code> is used. An  exception is when <code>a</code> has an integer type with less precision than  the platform (u)intp. In that case, the default will be either  (u)int32 or (u)int64 depending on whether the platform is 32 or 64  bits. For inexact inputs, dtype must be inexact. out : ndarray, optional  Alternate output array in which to place the result. The default  is <code>None</code>. If provided, it must have the same shape as the  expected output, but the type will be cast if necessary. See  <code>ufuncs-output-type</code> for more details. The casting of NaN to integer  can yield unexpected results. keepdims : bool, optional  If True, the axes which are reduced are left in the result as  dimensions with size one. With this option, the result will  broadcast correctly against the original <code>arr</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>nanprod : ndarray  A new array holding the result is returned unless <code>out</code> is  specified, in which case it is returned.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>numpy.prod : Product across array propagating NaNs. isnan : Show which elements are NaN.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.nanprod(1) 1 np.nanprod([1]) 1 np.nanprod([1, np.nan]) 1.0 a = np.array(<a href="null">1, 2], [3, np.nan</a>) np.nanprod(a) 6.0 np.nanprod(a, axis=0) array([3., 2.])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L4761">view source</a></div></div><div class="public anchor" id="var-nanquantile"><h3>nanquantile</h3><div class="usage"><code>(nanquantile &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Compute the qth quantile of the data along the specified axis, while ignoring nan values. Returns the qth quantile(s) of the array elements.</p>
<p>.. versionadded:: 1.15.0</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input array or object that can be converted to an array, containing  nan values to be ignored q : array_like of float  Quantile or sequence of quantiles to compute, which must be between  0 and 1 inclusive. axis : {int, tuple of int, None}, optional  Axis or axes along which the quantiles are computed. The  default is to compute the quantile(s) along a flattened  version of the array. out : ndarray, optional  Alternative output array in which to place the result. It must  have the same shape and buffer length as the expected output,  but the type (of the output) will be cast if necessary. overwrite_input : bool, optional  If True, then allow the input array <code>a</code> to be modified by intermediate  calculations, to save memory. In this case, the contents of the input  <code>a</code> after this function completes is undefined. interpolation : {linear, lower, higher, midpoint, nearest}  This optional parameter specifies the interpolation method to  use when the desired quantile lies between two data points  <code>i &lt; j</code>:</p>
<pre><code>* linear: ``i + (j - i) * fraction``, where ``fraction``
  is the fractional part of the index surrounded by ``i``
  and ``j``.
* lower: ``i``.
* higher: ``j``.
* nearest: ``i`` or ``j``, whichever is nearest.
* midpoint: ``(i + j) / 2``.
</code></pre>
<p>keepdims : bool, optional  If this is set to True, the axes which are reduced are left in  the result as dimensions with size one. With this option, the  result will broadcast correctly against the original array <code>a</code>.</p>
<pre><code>If this is anything but the default value it will be passed
through (in the special case of an empty array) to the
`mean` function of the underlying array.  If the array is
a sub-class and `mean` does not have the kwarg `keepdims` this
will raise a RuntimeError.
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>quantile : scalar or ndarray  If <code>q</code> is a single percentile and <code>axis=None</code>, then the result  is a scalar. If multiple quantiles are given, first axis of  the result corresponds to the quantiles. The other axes are  the axes that remain after the reduction of <code>a</code>. If the input  contains integers or floats smaller than <code>float64</code>, the output  data-type is <code>float64</code>. Otherwise, the output data-type is the  same as that of the input. If <code>out</code> is specified, that array is  returned instead.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>quantile nanmean, nanmedian nanmedian : equivalent to <code>nanquantile(..., 0.5)</code> nanpercentile : same as nanquantile, but with q in the range [0, 100].</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array(<a href="null">10., 7., 4.], [3., 2., 1.</a>) a[0][1] = np.nan a array(<a href="null">10.,  nan,   4.],
      [ 3.,   2.,   1.</a>) np.quantile(a, 0.5) nan np.nanquantile(a, 0.5) 3.0 np.nanquantile(a, 0.5, axis=0) array([6.5, 2. , 2.5]) np.nanquantile(a, 0.5, axis=1, keepdims=True) array(<a href="null">7.],
       [2.</a>) m = np.nanquantile(a, 0.5, axis=0) out = np.zeros_like(m) np.nanquantile(a, 0.5, axis=0, out=out) array([6.5, 2. , 2.5]) m array([6.5, 2. , 2.5]) b = a.copy() np.nanquantile(b, 0.5, axis=1, overwrite_input=True) array([7., 2.]) assert not np.all(a==b)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L14507">view source</a></div></div><div class="public anchor" id="var-nanstd"><h3>nanstd</h3><div class="usage"><code>(nanstd &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Compute the standard deviation along the specified axis, while ignoring NaNs.</p>
<p>Returns the standard deviation, a measure of the spread of a distribution, of the non-NaN array elements. The standard deviation is computed for the flattened array by default, otherwise over the specified axis.</p>
<p>For all-NaN slices or slices with zero degrees of freedom, NaN is returned and a <code>RuntimeWarning</code> is raised.</p>
<p>.. versionadded:: 1.8.0</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Calculate the standard deviation of the non-NaN values. axis : {int, tuple of int, None}, optional  Axis or axes along which the standard deviation is computed. The default is  to compute the standard deviation of the flattened array. dtype : dtype, optional  Type to use in computing the standard deviation. For arrays of  integer type the default is float64, for arrays of float types it  is the same as the array type. out : ndarray, optional  Alternative output array in which to place the result. It must have  the same shape as the expected output but the type (of the  calculated values) will be cast if necessary. ddof : int, optional  Means Delta Degrees of Freedom. The divisor used in calculations  is <code>N - ddof</code>, where <code>N</code> represents the number of non-NaN  elements. By default <code>ddof</code> is zero.</p>
<p>keepdims : bool, optional  If this is set to True, the axes which are reduced are left  in the result as dimensions with size one. With this option,  the result will broadcast correctly against the original <code>a</code>.</p>
<pre><code>If this value is anything but the default it is passed through
as-is to the relevant functions of the sub-classes.  If these
functions do not have a `keepdims` kwarg, a RuntimeError will
be raised.
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>standard_deviation : ndarray, see dtype parameter above.  If <code>out</code> is None, return a new array containing the standard  deviation, otherwise return a reference to the output array. If  ddof is &gt;= the number of non-NaN elements in a slice or the slice  contains only NaNs, then the result for that slice is NaN.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>var, mean, std nanvar, nanmean ufuncs-output-type</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The standard deviation is the square root of the average of the squared deviations from the mean: <code>std = sqrt(mean(abs(x - x.mean())**2))</code>.</p>
<p>The average squared deviation is normally calculated as <code>x.sum() / N</code>, where <code>N = len(x)</code>. If, however, <code>ddof</code> is specified, the divisor <code>N - ddof</code> is used instead. In standard statistical practice, <code>ddof=1</code> provides an unbiased estimator of the variance of the infinite population. <code>ddof=0</code> provides a maximum likelihood estimate of the variance for normally distributed variables. The standard deviation computed in this function is the square root of the estimated variance, so even with <code>ddof=1</code>, it will not be an unbiased estimate of the standard deviation per se.</p>
<p>Note that, for complex numbers, <code>std</code> takes the absolute value before squaring, so that the result is always real and nonnegative.</p>
<p>For floating-point input, the <em>std</em> is computed using the same precision the input has. Depending on the input data, this can cause the results to be inaccurate, especially for float32 (see example below). Specifying a higher-accuracy accumulator using the <code>dtype</code> keyword can alleviate this issue.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array(<a href="null">1, np.nan], [3, 4</a>) np.nanstd(a) 1.247219128924647 np.nanstd(a, axis=0) array([1., 0.]) np.nanstd(a, axis=1) array([0., 0.5]) # may vary</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L22889">view source</a></div></div><div class="public anchor" id="var-nansum"><h3>nansum</h3><div class="usage"><code>(nansum &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return the sum of array elements over a given axis treating Not a Numbers (NaNs) as zero.</p>
<p>In NumPy versions &lt;= 1.9.0 Nan is returned for slices that are all-NaN or empty. In later versions zero is returned.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Array containing numbers whose sum is desired. If <code>a</code> is not an  array, a conversion is attempted. axis : {int, tuple of int, None}, optional  Axis or axes along which the sum is computed. The default is to compute the  sum of the flattened array. dtype : data-type, optional  The type of the returned array and of the accumulator in which the  elements are summed. By default, the dtype of <code>a</code> is used. An  exception is when <code>a</code> has an integer type with less precision than  the platform (u)intp. In that case, the default will be either  (u)int32 or (u)int64 depending on whether the platform is 32 or 64  bits. For inexact inputs, dtype must be inexact.</p>
<pre><code>.. versionadded:: 1.8.0
</code></pre>
<p>out : ndarray, optional  Alternate output array in which to place the result. The default  is <code>None</code>. If provided, it must have the same shape as the  expected output, but the type will be cast if necessary. See  <code>ufuncs-output-type</code> for more details. The casting of NaN to integer  can yield unexpected results.</p>
<pre><code>.. versionadded:: 1.8.0
</code></pre>
<p>keepdims : bool, optional  If this is set to True, the axes which are reduced are left  in the result as dimensions with size one. With this option,  the result will broadcast correctly against the original <code>a</code>.</p>
<pre><code>If the value is anything but the default, then
`keepdims` will be passed through to the `mean` or `sum` methods
of sub-classes of `ndarray`.  If the sub-classes methods
does not implement `keepdims` any exceptions will be raised.

.. versionadded:: 1.8.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>nansum : ndarray.  A new array holding the result is returned unless <code>out</code> is  specified, in which it is returned. The result has the same  size as <code>a</code>, and the same shape as <code>a</code> if <code>axis</code> is not None  or <code>a</code> is a 1-d array.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>numpy.sum : Sum across array propagating NaNs. isnan : Show which elements are NaN. isfinite: Show which elements are not NaN or +/-inf.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>If both positive and negative infinity are present, the sum will be Not A Number (NaN).</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.nansum(1) 1 np.nansum([1]) 1 np.nansum([1, np.nan]) 1.0 a = np.array(<a href="null">1, 1], [1, np.nan</a>) np.nansum(a) 3.0 np.nansum(a, axis=0) array([2., 1.]) np.nansum([1, np.nan, np.inf]) inf np.nansum([1, np.nan, np.NINF]) -inf from numpy.testing import suppress_warnings with suppress_warnings() as sup:  sup.filter(RuntimeWarning)  np.nansum([1, np.nan, np.inf, -np.inf]) # both +/- infinity present nan</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L4671">view source</a></div></div><div class="public anchor" id="var-nanvar"><h3>nanvar</h3><div class="usage"><code>(nanvar &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Compute the variance along the specified axis, while ignoring NaNs.</p>
<p>Returns the variance of the array elements, a measure of the spread of a distribution. The variance is computed for the flattened array by default, otherwise over the specified axis.</p>
<p>For all-NaN slices or slices with zero degrees of freedom, NaN is returned and a <code>RuntimeWarning</code> is raised.</p>
<p>.. versionadded:: 1.8.0</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Array containing numbers whose variance is desired. If <code>a</code> is not an  array, a conversion is attempted. axis : {int, tuple of int, None}, optional  Axis or axes along which the variance is computed. The default is to compute  the variance of the flattened array. dtype : data-type, optional  Type to use in computing the variance. For arrays of integer type  the default is <code>float64</code>; for arrays of float types it is the same as  the array type. out : ndarray, optional  Alternate output array in which to place the result. It must have  the same shape as the expected output, but the type is cast if  necessary. ddof : int, optional  Delta Degrees of Freedom: the divisor used in the calculation is  <code>N - ddof</code>, where <code>N</code> represents the number of non-NaN  elements. By default <code>ddof</code> is zero. keepdims : bool, optional  If this is set to True, the axes which are reduced are left  in the result as dimensions with size one. With this option,  the result will broadcast correctly against the original <code>a</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>variance : ndarray, see dtype parameter above  If <code>out</code> is None, return a new array containing the variance,  otherwise return a reference to the output array. If ddof is &gt;= the  number of non-NaN elements in a slice or the slice contains only  NaNs, then the result for that slice is NaN.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>std : Standard deviation mean : Average var : Variance while not ignoring NaNs nanstd, nanmean ufuncs-output-type</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The variance is the average of the squared deviations from the mean, i.e., <code>var = mean(abs(x - x.mean())**2)</code>.</p>
<p>The mean is normally calculated as <code>x.sum() / N</code>, where <code>N = len(x)</code>. If, however, <code>ddof</code> is specified, the divisor <code>N - ddof</code> is used instead. In standard statistical practice, <code>ddof=1</code> provides an unbiased estimator of the variance of a hypothetical infinite population. <code>ddof=0</code> provides a maximum likelihood estimate of the variance for normally distributed variables.</p>
<p>Note that for complex numbers, the absolute value is taken before squaring, so that the result is always real and nonnegative.</p>
<p>For floating-point input, the variance is computed using the same precision the input has. Depending on the input data, this can cause the results to be inaccurate, especially for <code>float32</code> (see example below). Specifying a higher-accuracy accumulator using the <code>dtype</code> keyword can alleviate this issue.</p>
<p>For this function to work on sub-classes of ndarray, they must define <code>sum</code> with the kwarg <code>keepdims</code></p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array(<a href="null">1, np.nan], [3, 4</a>) np.nanvar(a) 1.5555555555555554 np.nanvar(a, axis=0) array([1., 0.]) np.nanvar(a, axis=1) array([0., 0.25]) # may vary</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L28033">view source</a></div></div><div class="public anchor" id="var-nbytes"><h3>nbytes</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Base object for a dictionary for look-up with any alias for an array dtype.</p>
<p>Instances of <code>_typedict</code> can not be used as dictionaries directly, first they have to be populated.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L25824">view source</a></div></div><div class="public anchor" id="var-ndarray"><h3>ndarray</h3><div class="usage"><code>(ndarray self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>ndarray(shape, dtype=float, buffer=None, offset=0,  strides=None, order=None)</p>
<p>An array object represents a multidimensional, homogeneous array of fixed-size items. An associated data-type object describes the format of each element in the array (its byte-order, how many bytes it occupies in memory, whether it is an integer, a floating point number, or something else, etc.)</p>
<p>Arrays should be constructed using <code>array</code>, <code>zeros</code> or <code>empty</code> (refer to the See Also section below). The parameters given here refer to a low-level method (<code>ndarray(...)</code>) for instantiating an array.</p>
<p>For more information, refer to the <code>numpy</code> module and examine the methods and attributes of an array.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>(for the <strong>new</strong> method; see Notes below)</p>
<p>shape : tuple of ints  Shape of created array. dtype : data-type, optional  Any object that can be interpreted as a numpy data type. buffer : object exposing buffer interface, optional  Used to fill the array with data. offset : int, optional  Offset of array data in buffer. strides : tuple of ints, optional  Strides of data in memory. order : {C, F}, optional  Row-major (C-style) or column-major (Fortran-style) order.</p>
<h2><a href="#attributes" name="attributes"></a>Attributes</h2>
<p>T : ndarray  Transpose of the array. data : buffer  The arrays elements, in memory. dtype : dtype object  Describes the format of the elements in the array. flags : dict  Dictionary containing information related to memory use, e.g.,  C_CONTIGUOUS, OWNDATA, WRITEABLE, etc. flat : numpy.flatiter object  Flattened version of the array as an iterator. The iterator  allows assignments, e.g., <code>x.flat = 3</code> (See <code>ndarray.flat</code> for  assignment examples; TODO). imag : ndarray  Imaginary part of the array. real : ndarray  Real part of the array. size : int  Number of elements in the array. itemsize : int  The memory use of each array element in bytes. nbytes : int  The total number of bytes required to store the array data,  i.e., <code>itemsize * size</code>. ndim : int  The arrays number of dimensions. shape : tuple of ints  Shape of the array. strides : tuple of ints  The step-size required to move from one element to the next in  memory. For example, a contiguous <code>(3, 4)</code> array of type  <code>int16</code> in C-order has strides <code>(8, 2)</code>. This implies that  to move from element to element in memory requires jumps of 2 bytes.  To move from row-to-row, one needs to jump 8 bytes at a time  (<code>2 * 4</code>). ctypes : ctypes object  Class containing properties of the array needed for interaction  with ctypes. base : ndarray  If the array is a view into another array, that array is its <code>base</code>  (unless that array is also a view). The <code>base</code> array is where the  array data is actually stored.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>array : Construct an array. zeros : Create an array, each element of which is zero. empty : Create an array, but leave its allocated memory unchanged (i.e.,  it contains garbage). dtype : Create a data-type.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>There are two modes of creating an array using <code>__new__</code>:</p>
<ol>
  <li>If <code>buffer</code> is None, then only <code>shape</code>, <code>dtype</code>, and <code>order</code>  are used.</li>
  <li>If <code>buffer</code> is an object exposing the buffer interface, then  all keywords are interpreted.</li>
</ol>
<p>No <code>__init__</code> method is needed because the array is fully initialized after the <code>__new__</code> method.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>These examples illustrate the low-level <code>ndarray</code> constructor. Refer to the <code>See Also</code> section above for easier ways of constructing an ndarray.</p>
<p>First mode, <code>buffer</code> is None:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.ndarray(shape=(2,2), dtype=float, order=F) array(<a href="null">0.0e+000, 0.0e+000], # random
       [     nan, 2.5e-323</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Second mode:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.ndarray((2,), buffer=np.array([1,2,3]),  offset=np.int_().itemsize,  dtype=int) # offset = 1*itemsize, i.e. skip first element array([2, 3])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L13399">view source</a></div></div><div class="public anchor" id="var-ndenumerate"><h3>ndenumerate</h3><div class="usage"><code>(ndenumerate self arr)</code></div><div class="doc"><div class="markdown"><p>Multidimensional index iterator.</p>
<p>Return an iterator yielding pairs of array coordinates and values.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>arr : ndarray  Input array.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>ndindex, flatiter</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array(<a href="null">1, 2], [3, 4</a>) for index, x in np.ndenumerate(a):  print(index, x) (0, 0) 1 (0, 1) 2 (1, 0) 3 (1, 1) 4</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L14008">view source</a></div></div><div class="public anchor" id="var-ndfromtxt"><h3>ndfromtxt</h3><div class="usage"><code>(ndfromtxt fname &amp; [{:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Load ASCII data stored in a file and return it as a single array.</p>
<p>.. deprecated:: 1.17  ndfromtxt<code>is a deprecated alias of</code>genfromtxt<code>which
    overwrites the ``usemask`` argument with</code>False<code>even when
    explicitly called as ``ndfromtxt(..., usemask=True)``.
    Use</code>genfromtxt` instead.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>fname, kwargs : For a description of input parameters, see <code>genfromtxt</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>numpy.genfromtxt : generic function.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L15151">view source</a></div></div><div class="public anchor" id="var-ndim"><h3>ndim</h3><div class="usage"><code>(ndim &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return the number of dimensions of an array.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input array. If it is not already an ndarray, a conversion is  attempted.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>number_of_dimensions : int  The number of dimensions in <code>a</code>. Scalars are zero-dimensional.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>ndarray.ndim : equivalent method shape : dimensions of array ndarray.shape : dimensions of array</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.ndim(<a href="null">1,2,3],[4,5,6</a>) 2 np.ndim(np.array(<a href="null">1,2,3],[4,5,6</a>)) 2 np.ndim(1) 0</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L18344">view source</a></div></div><div class="public anchor" id="var-ndindex"><h3>ndindex</h3><div class="usage"><code>(ndindex self &amp; [shape])</code></div><div class="doc"><div class="markdown"><p>An N-dimensional iterator object to index arrays.</p>
<p>Given the shape of an array, an <code>ndindex</code> instance iterates over the N-dimensional index of the array. At each iteration a tuple of indices is returned, the last dimension is iterated over first.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p><code>*args</code> : ints  The size of each dimension of the array.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>ndenumerate, flatiter</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>for index in np.ndindex(3, 2, 1):  print(index) (0, 0, 0) (0, 1, 0) (1, 0, 0) (1, 1, 0) (2, 0, 0) (2, 1, 0)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L2709">view source</a></div></div><div class="public anchor" id="var-nditer"><h3>nditer</h3><div class="usage"><code>(nditer self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Efficient multi-dimensional iterator object to iterate over arrays. To get started using this object, see the :ref:<code>introductory guide to array iteration &lt;arrays.nditer&gt;</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>op : ndarray or sequence of array_like  The array(s) to iterate over.</p>
<p>flags : sequence of str, optional  Flags to control the behavior of the iterator.</p>
<pre><code>  * ``buffered`` enables buffering when required.
  * ``c_index`` causes a C-order index to be tracked.
  * ``f_index`` causes a Fortran-order index to be tracked.
  * ``multi_index`` causes a multi-index, or a tuple of indices
    with one per iteration dimension, to be tracked.
  * ``common_dtype`` causes all the operands to be converted to
    a common data type, with copying or buffering as necessary.
  * ``copy_if_overlap`` causes the iterator to determine if read
    operands have overlap with write operands, and make temporary
    copies as necessary to avoid overlap. False positives (needless
    copying) are possible in some cases.
  * ``delay_bufalloc`` delays allocation of the buffers until
    a reset() call is made. Allows ``allocate`` operands to
    be initialized before their values are copied into the buffers.
  * ``external_loop`` causes the ``values`` given to be
    one-dimensional arrays with multiple values instead of
    zero-dimensional arrays.
  * ``grow_inner`` allows the ``value`` array sizes to be made
    larger than the buffer size when both ``buffered`` and
    ``external_loop`` is used.
  * ``ranged`` allows the iterator to be restricted to a sub-range
    of the iterindex values.
  * ``refs_ok`` enables iteration of reference types, such as
    object arrays.
  * ``reduce_ok`` enables iteration of ``readwrite`` operands
    which are broadcasted, also known as reduction operands.
  * ``zerosize_ok`` allows `itersize` to be zero.
</code></pre>
<p>op_flags : list of list of str, optional  This is a list of flags for each operand. At minimum, one of  <code>readonly</code>, <code>readwrite</code>, or <code>writeonly</code> must be specified.</p>
<pre><code>  * ``readonly`` indicates the operand will only be read from.
  * ``readwrite`` indicates the operand will be read from and written to.
  * ``writeonly`` indicates the operand will only be written to.
  * ``no_broadcast`` prevents the operand from being broadcasted.
  * ``contig`` forces the operand data to be contiguous.
  * ``aligned`` forces the operand data to be aligned.
  * ``nbo`` forces the operand data to be in native byte order.
  * ``copy`` allows a temporary read-only copy if required.
  * ``updateifcopy`` allows a temporary read-write copy if required.
  * ``allocate`` causes the array to be allocated if it is None
    in the ``op`` parameter.
  * ``no_subtype`` prevents an ``allocate`` operand from using a subtype.
  * ``arraymask`` indicates that this operand is the mask to use
    for selecting elements when writing to operands with the
    'writemasked' flag set. The iterator does not enforce this,
    but when writing from a buffer back to the array, it only
    copies those elements indicated by this mask.
  * ``writemasked`` indicates that only elements where the chosen
    ``arraymask`` operand is True will be written to.
  * ``overlap_assume_elementwise`` can be used to mark operands that are
    accessed only in the iterator order, to allow less conservative
    copying when ``copy_if_overlap`` is present.
</code></pre>
<p>op_dtypes : dtype or tuple of dtype(s), optional  The required data type(s) of the operands. If copying or buffering  is enabled, the data will be converted to/from their original types. order : {C, F, A, K}, optional  Controls the iteration order. C means C order, F means  Fortran order, A means F order if all the arrays are Fortran  contiguous, C order otherwise, and K means as close to the  order the array elements appear in memory as possible. This also  affects the element memory order of <code>allocate</code> operands, as they  are allocated to be compatible with iteration order.  Default is K. casting : {no, equiv, safe, same_kind, unsafe}, optional  Controls what kind of data casting may occur when making a copy  or buffering. Setting this to unsafe is not recommended,  as it can adversely affect accumulations.</p>
<pre><code>* 'no' means the data types should not be cast at all.
* 'equiv' means only byte-order changes are allowed.
* 'safe' means only casts which can preserve values are allowed.
* 'same_kind' means only safe casts or casts within a kind,
  like float64 to float32, are allowed.
* 'unsafe' means any data conversions may be done.
</code></pre>
<p>op_axes : list of list of ints, optional  If provided, is a list of ints or None for each operands.  The list of axes for an operand is a mapping from the dimensions  of the iterator to the dimensions of the operand. A value of  -1 can be placed for entries, causing that dimension to be  treated as <code>newaxis</code>. itershape : tuple of ints, optional  The desired shape of the iterator. This allows <code>allocate</code> operands  with a dimension mapped by op_axes not corresponding to a dimension  of a different operand to get a value not equal to 1 for that  dimension. buffersize : int, optional  When buffering is enabled, controls the size of the temporary  buffers. Set to 0 for the default value.</p>
<h2><a href="#attributes" name="attributes"></a>Attributes</h2>
<p>dtypes : tuple of dtype(s)  The data types of the values provided in <code>value</code>. This may be  different from the operand data types if buffering is enabled.  Valid only before the iterator is closed. finished : bool  Whether the iteration over the operands is finished or not. has_delayed_bufalloc : bool  If True, the iterator was created with the <code>delay_bufalloc</code> flag,  and no reset() function was called on it yet. has_index : bool  If True, the iterator was created with either the <code>c_index</code> or  the <code>f_index</code> flag, and the property <code>index</code> can be used to  retrieve it. has_multi_index : bool  If True, the iterator was created with the <code>multi_index</code> flag,  and the property <code>multi_index</code> can be used to retrieve it. index  When the <code>c_index</code> or <code>f_index</code> flag was used, this property  provides access to the index. Raises a ValueError if accessed  and <code>has_index</code> is False. iterationneedsapi : bool  Whether iteration requires access to the Python API, for example  if one of the operands is an object array. iterindex : int  An index which matches the order of iteration. itersize : int  Size of the iterator. itviews  Structured view(s) of <code>operands</code> in memory, matching the reordered  and optimized iterator access pattern. Valid only before the iterator  is closed. multi_index  When the <code>multi_index</code> flag was used, this property  provides access to the index. Raises a ValueError if accessed  accessed and <code>has_multi_index</code> is False. ndim : int  The dimensions of the iterator. nop : int  The number of iterator operands. operands : tuple of operand(s)  The array(s) to be iterated over. Valid only before the iterator is  closed. shape : tuple of ints  Shape tuple, the shape of the iterator. value  Value of <code>operands</code> at current iteration. Normally, this is a  tuple of array scalars, but if the flag <code>external_loop</code> is used,  it is a tuple of one dimensional arrays.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p><code>nditer</code> supersedes <code>flatiter</code>. The iterator implementation behind <code>nditer</code> is also exposed by the NumPy C API.</p>
<p>The Python exposure supplies two iteration interfaces, one which follows the Python iterator protocol, and another which mirrors the C-style do-while pattern. The native Python approach is better in most cases, but if you need the coordinates or index of an iterator, use the C-style pattern.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>Here is how we might write an <code>iter_add</code> function, using the Python iterator protocol:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>def iter_add_py(x, y, out=None):  addop = np.add  it = np.nditer([x, y, out], [],  <a href="null">'readonly'], ['readonly'], ['writeonly','allocate'</a>)  with it:  for (a, b, c) in it:  addop(a, b, out=c)  return it.operands[2]</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Here is the same function, but following the C-style pattern:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>def iter_add(x, y, out=None):  addop = np.add  it = np.nditer([x, y, out], [],  <a href="null">'readonly'], ['readonly'], ['writeonly','allocate'</a>)  with it:  while not it.finished:  addop(it[0], it[1], out=it[2])  it.iternext()  return it.operands[2]</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Here is an example outer product function:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>def outer_it(x, y, out=None):  mulop = np.multiply  it = np.nditer([x, y, out], [external_loop],  <a href="null">'readonly'], ['readonly'], ['writeonly', 'allocate'</a>,  op_axes=[list(range(x.ndim)) + [-1] * y.ndim,  [-1] * x.ndim + list(range(y.ndim)),  None])  with it:  for (a, b, c) in it:  mulop(a, b, out=c)  return it.operands[2]</p>
      <p>a = np.arange(2)+1 b = np.arange(3)+1 outer_it(a,b) array(<a href="null">1, 2, 3],
       [2, 4, 6</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Here is an example function which operates like a lambda ufunc:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>def luf(lamdaexpr, *args, **kwargs):  luf(lambdaexpr, op1, , opn, out=None, order=K, casting=safe, buffersize=0)  nargs = len(args)  op = (kwargs.get(out,None),) + args  it = np.nditer(op, [buffered,external_loop],  <a href="null">'writeonly','allocate','no_broadcast'</a> +  <a href="null">'readonly','nbo','aligned'</a>*nargs,  order=kwargs.get(order,K),  casting=kwargs.get(casting,safe),  buffersize=kwargs.get(buffersize,0))  while not it.finished:  it[0] = lamdaexpr(*it[1:])  it.iternext()  return it.operands[0]</p>
      <p>a = np.arange(5) b = np.ones(5) luf(lambda i,j:i*i + j/2, a, b) array([ 0.5, 1.5, 4.5, 9.5, 16.5])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>If operand flags <code>"writeonly"</code> or <code>"readwrite"</code> are used the operands may be views into the original data with the <code>WRITEBACKIFCOPY</code> flag. In this case <code>nditer</code> must be used as a context manager or the <code>nditer.close</code> method must be called before using the result. The temporary data will be written back to the original data when the <code>__exit__</code> function is called but not before:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.arange(6, dtype=i4)[::-2] with np.nditer(a, [],  <a href="null">'writeonly', 'updateifcopy'</a>,  casting=unsafe,  op_dtypes=[np.dtype(f4)]) as i:  x = i.operands[0]  x[:] = [-1, -2, -3]  # a still unchanged here a, x (array([-1, -2, -3], dtype=int32), array([-1., -2., -3.], dtype=float32))</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>It is important to note that once the iterator is exited, dangling references (like <code>x</code> in the example) may or may not share data with the original data <code>a</code>. If writeback semantics were active, i.e. if <code>x.base.flags.writebackifcopy</code> is <code>True</code>, then exiting the iterator will sever the connection between <code>x</code> and <code>a</code>, writing to <code>x</code> will no longer write to <code>a</code>. If writeback semantics are not active, then <code>x.data</code> will still point at some part of <code>a.data</code>, and writing to one will affect the other.</p>
<p>Context management and the <code>close</code> method appeared in version 1.15.0.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L4410">view source</a></div></div><div class="public anchor" id="var-negative"><h3>negative</h3><div class="usage"><code>(negative self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>negative(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Numerical negative, element-wise.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like or scalar  Input array. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray or scalar  Returned array or scalar: <code>y = -x</code>.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.negative([1.,-1.]) array([-1., 1.])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L9754">view source</a></div></div><div class="public anchor" id="var-nested_iters"><h3>nested_iters</h3><div class="usage"><code>(nested_iters self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Create nditers for use in nested loops</p>
<p>Create a tuple of <code>nditer</code> objects which iterate in nested loops over different axes of the op argument. The first iterator is used in the outermost loop, the last in the innermost loop. Advancing one will change the subsequent iterators to point at its new element.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>op : ndarray or sequence of array_like  The array(s) to iterate over.</p>
<p>axes : list of list of int  Each item is used as an op_axes argument to an nditer</p>
<p>flags, op_flags, op_dtypes, order, casting, buffersize (optional)  See <code>nditer</code> parameters of the same name</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>iters : tuple of nditer  An nditer for each item in <code>axes</code>, outermost first</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>nditer</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>Basic usage. Note how y is the flattened version of [a[:, 0, :], a[:, 1, 0], a[:, 2, :]] since we specified the first iters axes as [1]</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.arange(12).reshape(2, 3, 2) i, j = np.nested_iters(a, <a href="null">1], [0, 2</a>, flags=[multi_index]) for x in i:  print(i.multi_index)  for y in j:  print(, j.multi_index, y) (0,)  (0, 0) 0  (0, 1) 1  (1, 0) 6  (1, 1) 7 (1,)  (0, 0) 2  (0, 1) 3  (1, 0) 8  (1, 1) 9 (2,)  (0, 0) 4  (0, 1) 5  (1, 0) 10  (1, 1) 11</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L14996">view source</a></div></div><div class="public anchor" id="var-nextafter"><h3>nextafter</h3><div class="usage"><code>(nextafter self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>nextafter(x1, x2, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Return the next floating-point value after x1 towards x2, element-wise.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x1 : array_like  Values to find the next representable value of. x2 : array_like  The direction where to look for the next representable value of <code>x1</code>.  If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output). out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray or scalar  The next representable values of <code>x1</code> in the direction of <code>x2</code>.  This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>eps = np.finfo(np.float64).eps np.nextafter(1, 2) == eps + 1 True np.nextafter([1, 2], [2, 1]) == [eps + 1, 2 - eps] array([ True, True])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L25129">view source</a></div></div><div class="public anchor" id="var-NINF"><h3>NINF</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L1591">view source</a></div></div><div class="public anchor" id="var-nonzero"><h3>nonzero</h3><div class="usage"><code>(nonzero &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return the indices of the elements that are non-zero.</p>
<p>Returns a tuple of arrays, one for each dimension of <code>a</code>, containing the indices of the non-zero elements in that dimension. The values in <code>a</code> are always tested and returned in row-major, C-style order.</p>
<p>To group the indices by element, rather than dimension, use <code>argwhere</code>, which returns a row for each non-zero element.</p>
<p>.. note::</p>
<p>When called on a zero-d array or scalar, <code>nonzero(a)</code> is treated  as <code>nonzero(atleast1d(a))</code>.</p>
<p>.. deprecated:: 1.17.0</p>
<pre><code>  Use `atleast1d` explicitly if this behavior is deliberate.
</code></pre>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input array.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>tuple_of_arrays : tuple  Indices of elements that are non-zero.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>flatnonzero :  Return indices that are non-zero in the flattened version of the input  array. ndarray.nonzero :  Equivalent ndarray method. count_nonzero :  Counts the number of non-zero elements in the input array.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>While the nonzero values can be obtained with <code>a[nonzero(a)]</code>, it is recommended to use <code>x[x.astype(bool)]</code> or <code>x[x != 0]</code> instead, which will correctly handle 0-d arrays.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.array(<a href="null">3, 0, 0], [0, 4, 0], [5, 6, 0</a>) x array(<a href="null">3, 0, 0],
       [0, 4, 0],
       [5, 6, 0</a>) np.nonzero(x) (array([0, 1, 2, 2]), array([0, 1, 0, 1]))</p>
      <p>x[np.nonzero(x)] array([3, 4, 5, 6]) np.transpose(np.nonzero(x)) array(<a href="null">0, 0],
       [1, 1],
       [2, 0],
       [2, 1</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>A common use for <code>nonzero</code> is to find the indices of an array, where a condition is True. Given an array <code>a</code>, the condition <code>a</code> &gt; 3 is a boolean array and since False is interpreted as 0, np.nonzero(a &gt; 3) yields the indices of the <code>a</code> where the condition is true.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array(<a href="null">1, 2, 3], [4, 5, 6], [7, 8, 9</a>) a &gt; 3 array(<a href="null">False, False, False],
       [ True,  True,  True],
       [ True,  True,  True</a>) np.nonzero(a &gt; 3) (array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Using this result to index <code>a</code> is equivalent to using the mask directly:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a[np.nonzero(a &gt; 3)] array([4, 5, 6, 7, 8, 9]) a[a &gt; 3] # prefer this spelling array([4, 5, 6, 7, 8, 9])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p><code>nonzero</code> can also be called as a method of the array.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>(a &gt; 3).nonzero() (array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L8774">view source</a></div></div><div class="public anchor" id="var-not_equal"><h3>not_equal</h3><div class="usage"><code>(not_equal self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>not_equal(x1, x2, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Return (x1 != x2) element-wise.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x1, x2 : array_like  Input arrays. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output). out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray or scalar  Output array, element-wise comparison of <code>x1</code> and <code>x2</code>.  Typically of type bool, unless <code>dtype=object</code> is passed.  This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>equal, greater, greater_equal, less, less_equal</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.not_equal([1.,2.], [1., 3.]) array([False, True]) np.not_equal([1, 2], <a href="null">1, 3],[1, 4</a>) array(<a href="null">False,  True],
       [False,  True</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L6062">view source</a></div></div><div class="public anchor" id="var-nper"><h3>nper</h3><div class="usage"><code>(nper &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Compute the number of periodic payments.</p>
<p>.. deprecated:: 1.18</p>
<p><code>nper</code> is deprecated; for details, see NEP 32 [1]_.  Use the corresponding function in the numpy-financial library,  <a href="https://pypi.org/project/numpy-financial">https://pypi.org/project/numpy-financial</a>.</p>
<p>:class:<code>decimal.Decimal</code> type is not supported.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>rate : array_like  Rate of interest (per period) pmt : array_like  Payment pv : array_like  Present value fv : array_like, optional  Future value when : {{begin, 1}, {end, 0}}, {string, int}, optional  When payments are due (begin (1) or end (0))</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The number of periods <code>nper</code> is computed by solving the equation::</p>
<p>fv + pv*(1+rate)**nper + pmt*(1+rate*when)/rate*((1+rate)**nper-1) = 0</p>
<p>but if <code>rate = 0</code> then::</p>
<p>fv + pv + pmt*nper = 0</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [1] NumPy Enhancement Proposal (NEP) 32,  <a href="https://numpy.org/neps/nep-0032-remove-financial-functions.html">https://numpy.org/neps/nep-0032-remove-financial-functions.html</a></p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>If you only had $150/month to pay towards the loan, how long would it take to pay-off a loan of $8,000 at 7% annual interest?</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>print(np.round(np.nper(0.07/12, -150, 8000), 5)) 64.07335</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>So, over 64 months would be required to pay off the loan.</p>
<p>The same analysis could be done with several different interest rates and/or payments and/or total amounts to produce an entire table.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.nper(*(np.ogrid[0.07/12: 0.08/12: 0.01/12,  -150 : -99 : 50 ,  8000 : 9001 : 1000])) array(<a href="null">[ 64.07334877,  74.06368256],
        [108.07548412, 127.99022654</a>,  <a href="null"> 66.12443902,  76.87897353],
        [114.70165583, 137.90124779</a>])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L7611">view source</a></div></div><div class="public anchor" id="var-npv"><h3>npv</h3><div class="usage"><code>(npv &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Returns the NPV (Net Present Value) of a cash flow series.</p>
<p>.. deprecated:: 1.18</p>
<p><code>npv</code> is deprecated; for details, see NEP 32 [1]_.  Use the corresponding function in the numpy-financial library,  <a href="https://pypi.org/project/numpy-financial">https://pypi.org/project/numpy-financial</a>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>rate : scalar  The discount rate. values : array_like, shape(M, )  The values of the time series of cash flows. The (fixed) time  interval between cash flow events must be the same as that for  which <code>rate</code> is given (i.e., if <code>rate</code> is per year, then precisely  a year is understood to elapse between each cash flow event). By  convention, investments or deposits are negative, income or  withdrawals are positive; <code>values</code> must begin with the initial  investment, thus <code>values[0]</code> will typically be negative.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : float  The NPV of the input cash flow series <code>values</code> at the discount  <code>rate</code>.</p>
<h2><a href="#warnings" name="warnings"></a>Warnings</h2>
<p><code>npv</code> considers a series of cashflows starting in the present (t = 0). NPV can also be defined with a series of future cashflows, paid at the end, rather than the start, of each period. If future cashflows are used, the first cashflow <code>values[0]</code> must be zeroed and added to the net present value of the future cashflows. This is demonstrated in the examples.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Returns the result of: [2]_</p>
<p>.. math :: \sum_{t=0}^{M-1}{\frac{values_t}{(1+rate)^{t}}}</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [1] NumPy Enhancement Proposal (NEP) 32,  <a href="https://numpy.org/neps/nep-0032-remove-financial-functions.html">https://numpy.org/neps/nep-0032-remove-financial-functions.html</a> .. [2] L. J. Gitman, Principles of Managerial Finance, Brief, 3rd ed.,  Addison-Wesley, 2003, pg. 346.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>Consider a potential project with an initial investment of $40 000 and projected cashflows of $5 000, $8 000, $12 000 and $30 000 at the end of each period discounted at a rate of 8% per period. To find the projects net present value:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>rate, cashflows = 0.08, [-40_000, 5_000, 8_000, 12_000, 30_000] np.npv(rate, cashflows).round(5) 3065.22267</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>It may be preferable to split the projected cashflow into an initial investment and expected future cashflows. In this case, the value of the initial cashflow is zero and the initial investment is later added to the future cashflows net present value:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>initial_cashflow = cashflows[0] cashflows[0] = 0 np.round(np.npv(rate, cashflows) + initial_cashflow, 5) 3065.22267</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L16324">view source</a></div></div><div class="public anchor" id="var-numarray"><h3>numarray</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L25019">view source</a></div></div><div class="public anchor" id="var-number"><h3>number</h3><div class="usage"><code>(number self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Abstract base class of all numeric scalar types.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L17525">view source</a></div></div><div class="public anchor" id="var-NZERO"><h3>NZERO</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L23617">view source</a></div></div><div class="public anchor" id="var-obj2sctype"><h3>obj2sctype</h3><div class="usage"><code>(obj2sctype rep &amp; [{default :default}])</code><code>(obj2sctype rep)</code></div><div class="doc"><div class="markdown"><p>Return the scalar dtype or NumPy equivalent of Python type of an object.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>rep : any  The object of which the type is returned. default : any, optional  If given, this is returned for objects whose types can not be  determined. If not given, None is returned for those objects.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>dtype : dtype or Python type  The data type of <code>rep</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>sctype2char, issctype, issubsctype, issubdtype, maximum_sctype</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.obj2sctype(np.int32) &lt;class numpy.int32&gt; np.obj2sctype(np.array([1., 2.])) &lt;class numpy.float64&gt; np.obj2sctype(np.array([1.j])) &lt;class numpy.complex128&gt;</p>
      <p>np.obj2sctype(dict) &lt;class numpy.object_&gt; np.obj2sctype(string)</p>
      <p>np.obj2sctype(1, default=list) &lt;class list&gt;</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L3971">view source</a></div></div><div class="public anchor" id="var-object"><h3>object</h3><div class="usage"><code>(object self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>The base class of the class hierarchy.</p>
<p>When called, it accepts no arguments and returns a new featureless instance that has no instance attributes and cannot be given any.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L812">view source</a></div></div><div class="public anchor" id="var-object0"><h3>object0</h3><div class="usage"><code>(object0 self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Any Python object. Character code: <code>'O'</code>.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L18340">view source</a></div></div><div class="public anchor" id="var-object_"><h3>object_</h3><div class="usage"><code>(object_ self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Any Python object. Character code: <code>'O'</code>.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L25690">view source</a></div></div><div class="public anchor" id="var-ogrid"><h3>ogrid</h3><div class="usage"></div><div class="doc"><div class="markdown"><p><code>nd_grid</code> instance which returns an open multi-dimensional meshgrid.</p>
<p>An instance of <code>numpy.lib.index_tricks.nd_grid</code> which returns an open (i.e. not fleshed out) mesh-grid when indexed, so that only one dimension of each returned array is greater than 1. The dimension and number of the output arrays are equal to the number of indexing dimensions. If the step length is not a complex number, then the stop is not inclusive.</p>
<p>However, if the step length is a <strong>complex number</strong> (e.g. 5j), then the integer part of its magnitude is interpreted as specifying the number of points to create between the start and stop values, where the stop value <strong>is inclusive</strong>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>mesh-grid  <code>ndarrays</code> with only one dimension not equal to 1</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>np.lib.index_tricks.nd_grid : class of <code>ogrid</code> and <code>mgrid</code> objects mgrid : like <code>ogrid</code> but returns dense (or fleshed out) mesh grids r_ : array concatenator</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>from numpy import ogrid ogrid[-1:1:5j] array([-1. , -0.5, 0. , 0.5, 1. ]) ogrid[0:5,0:5]
[array([[0],  [1],  [2],  [3],  [4]]), array([[0, 1, 2, 3, 4]])]</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L22069">view source</a></div></div><div class="public anchor" id="var-oldnumeric"><h3>oldnumeric</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L22357">view source</a></div></div><div class="public anchor" id="var-ones"><h3>ones</h3><div class="usage"><code>(ones shape &amp; [{dtype :dtype, order :order}])</code><code>(ones shape &amp; [{dtype :dtype}])</code><code>(ones shape)</code></div><div class="doc"><div class="markdown"><p>Return a new array of given shape and type, filled with ones.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>shape : int or sequence of ints  Shape of the new array, e.g., <code>(2, 3)</code> or <code>2</code>. dtype : data-type, optional  The desired data-type for the array, e.g., <code>numpy.int8</code>. Default is  <code>numpy.float64</code>. order : {C, F}, optional, default: C  Whether to store multi-dimensional data in row-major  (C-style) or column-major (Fortran-style) order in  memory.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  Array of ones with the given shape, dtype, and order.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>ones_like : Return an array of ones with shape and type of input. empty : Return a new uninitialized array. zeros : Return a new array setting values to zero. full : Return a new array of given shape filled with value.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.ones(5) array([1., 1., 1., 1., 1.])</p>
      <p>np.ones((5,), dtype=int) array([1, 1, 1, 1, 1])</p>
      <p>np.ones((2, 1)) array(<a href="null">1.],
       [1.</a>)</p>
      <p>s = (2,2) np.ones(s) array(<a href="null">1.,  1.],
       [1.,  1.</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L3580">view source</a></div></div><div class="public anchor" id="var-ones_like"><h3>ones_like</h3><div class="usage"><code>(ones_like &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return an array of ones with the same shape and type as a given array.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  The shape and data-type of <code>a</code> define these same attributes of  the returned array. dtype : data-type, optional  Overrides the data type of the result.</p>
<pre><code>.. versionadded:: 1.6.0
</code></pre>
<p>order : {C, F, A, or K}, optional  Overrides the memory layout of the result. C means C-order,  F means F-order, A means F if <code>a</code> is Fortran contiguous,  C otherwise. K means match the layout of <code>a</code> as closely  as possible.</p>
<pre><code>.. versionadded:: 1.6.0
</code></pre>
<p>subok : bool, optional.  If True, then the newly created array will use the sub-class  type of a, otherwise it will be a base-class array. Defaults  to True. shape : int or sequence of ints, optional.  Overrides the shape of the result. If order=K and the number of  dimensions is unchanged, will try to keep order, otherwise,  order=C is implied.</p>
<pre><code>.. versionadded:: 1.17.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  Array of ones with the same shape and type as <code>a</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>empty_like : Return an empty array with shape and type of input. zeros_like : Return an array of zeros with shape and type of input. full_like : Return a new array with shape of input filled with value. ones : Return a new array setting values to one.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.arange(6) x = x.reshape((2, 3)) x array(<a href="null">0, 1, 2],
       [3, 4, 5</a>) np.ones_like(x) array(<a href="null">1, 1, 1],
       [1, 1, 1</a>)</p>
      <p>y = np.arange(3, dtype=float) y array([0., 1., 2.]) np.ones_like(y) array([1., 1., 1.])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L21454">view source</a></div></div><div class="public anchor" id="var-outer"><h3>outer</h3><div class="usage"><code>(outer &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Compute the outer product of two vectors.</p>
<p>Given two vectors, <code>a = [a0, a1, ..., aM]</code> and <code>b = [b0, b1, ..., bN]</code>, the outer product [1]_ is::</p>
<p><a href="null">a0*b0  a0*b1 ... a0*bN ]
   [a1*b0    .
   [ ...          .
   [aM*b0            aM*bN </a></p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : (M,) array_like  First input vector. Input is flattened if  not already 1-dimensional. b : (N,) array_like  Second input vector. Input is flattened if  not already 1-dimensional. out : (M, N) ndarray, optional  A location where the result is stored</p>
<pre><code>.. versionadded:: 1.9.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : (M, N) ndarray  <code>out[i, j] = a[i] * b[j]</code></p>
<h2><a href="#see-also" name="see-also"></a>See also</h2>
<p>inner einsum : <code>einsum('i,j-&gt;ij', a.ravel(), b.ravel())</code> is the equivalent. ufunc.outer : A generalization to N dimensions and other operations.  <code>np.multiply.outer(a.ravel(), b.ravel())</code> is the equivalent.</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [1] : G. H. Golub and C. F. Van Loan, <em>Matrix Computations</em>, 3rd  ed., Baltimore, MD, Johns Hopkins University Press, 1996,  pg. 8.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>Make a (*very* coarse) grid for computing a Mandelbrot set:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5)) rl array(<a href="null">-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.],
       [-2., -1.,  0.,  1.,  2.</a>) im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,))) im array(<a href="null">0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j],
       [0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j],
       [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
       [0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j],
       [0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j</a>) grid = rl + im grid array(<a href="null">-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],
       [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],
       [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],
       [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],
       [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>An example using a vector of letters:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.array([a, b, c], dtype=object) np.outer(x, [1, 2, 3]) array(<a href="null">'a', 'aa', 'aaa'],
       ['b', 'bb', 'bbb'],
       ['c', 'cc', 'ccc'</a>, dtype=object)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L16546">view source</a></div></div><div class="public anchor" id="var-packbits"><h3>packbits</h3><div class="usage"><code>(packbits &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>packbits(a, axis=None, bitorder=big)</p>
<p>Packs the elements of a binary-valued array into bits in a uint8 array.</p>
<p>The result is padded to full bytes by inserting zero bits at the end.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  An array of integers or booleans whose elements should be packed to  bits. axis : int, optional  The dimension over which bit-packing is done.  <code>None</code> implies packing the flattened array. bitorder : {big, little}, optional  The order of the input bits. big will mimic bin(val),  <code>[0, 0, 0, 0, 0, 0, 1, 1] =&gt; 3 = 0b00000011 =&gt;</code>, little will  reverse the order so <code>[1, 1, 0, 0, 0, 0, 0, 0] =&gt; 3</code>.  Defaults to big.</p>
<pre><code>.. versionadded:: 1.17.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>packed : ndarray  Array of type uint8 whose elements represent bits corresponding to the  logical (0 or nonzero) value of the input elements. The shape of  <code>packed</code> has the same number of dimensions as the input (unless <code>axis</code>  is None, in which case the output is 1-D).</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>unpackbits: Unpacks elements of a uint8 array into a binary-valued output  array.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array(<a href="null">[1,0,1],
...                [0,1,0</a>,  <a href="null">1,1,0],
...                [0,0,1</a>]) b = np.packbits(a, axis=-1) b array(<a href="null">[160],
        [ 64</a>,  <a href="null">192],
        [ 32</a>], dtype=uint8)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Note that in binary 160 = 1010 0000, 64 = 0100 0000, 192 = 1100 0000, and 32 = 0010 0000.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L14312">view source</a></div></div><div class="public anchor" id="var-pad"><h3>pad</h3><div class="usage"><code>(pad &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Pad an array.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>array : array_like of rank N  The array to pad. pad_width : {sequence, array_like, int}  Number of values padded to the edges of each axis.  ((before_1, after_1),  (before_N, after_N)) unique pad widths  for each axis.  ((before, after),) yields same before and after pad for each axis.  (pad,) or int is a shortcut for before = after = pad width for all  axes. mode : str or function, optional  One of the following string values or a user supplied function.</p>
<pre><code>'constant' (default)
    Pads with a constant value.
'edge'
    Pads with the edge values of array.
'linear_ramp'
    Pads with the linear ramp between end_value and the
    array edge value.
'maximum'
    Pads with the maximum value of all or part of the
    vector along each axis.
'mean'
    Pads with the mean value of all or part of the
    vector along each axis.
'median'
    Pads with the median value of all or part of the
    vector along each axis.
'minimum'
    Pads with the minimum value of all or part of the
    vector along each axis.
'reflect'
    Pads with the reflection of the vector mirrored on
    the first and last values of the vector along each
    axis.
'symmetric'
    Pads with the reflection of the vector mirrored
    along the edge of the array.
'wrap'
    Pads with the wrap of the vector along the axis.
    The first values are used to pad the end and the
    end values are used to pad the beginning.
'empty'
    Pads with undefined values.

    .. versionadded:: 1.17

&lt;function&gt;
    Padding function, see Notes.
</code></pre>
<p>stat_length : sequence or int, optional  Used in maximum, mean, median, and minimum. Number of  values at edge of each axis used to calculate the statistic value.</p>
<pre><code>((before_1, after_1), ... (before_N, after_N)) unique statistic
lengths for each axis.

((before, after),) yields same before and after statistic lengths
for each axis.

(stat_length,) or int is a shortcut for before = after = statistic
length for all axes.

Default is ``None``, to use the entire axis.
</code></pre>
<p>constant_values : sequence or scalar, optional  Used in constant. The values to set the padded values for each  axis.</p>
<pre><code>``((before_1, after_1), ... (before_N, after_N))`` unique pad constants
for each axis.

``((before, after),)`` yields same before and after constants for each
axis.

``(constant,)`` or ``constant`` is a shortcut for ``before = after = constant`` for
all axes.

Default is 0.
</code></pre>
<p>end_values : sequence or scalar, optional  Used in linear_ramp. The values used for the ending value of the  linear_ramp and that will form the edge of the padded array.</p>
<pre><code>``((before_1, after_1), ... (before_N, after_N))`` unique end values
for each axis.

``((before, after),)`` yields same before and after end values for each
axis.

``(constant,)`` or ``constant`` is a shortcut for ``before = after = constant`` for
all axes.

Default is 0.
</code></pre>
<p>reflect_type : {even, odd}, optional  Used in reflect, and symmetric. The even style is the  default with an unaltered reflection around the edge value. For  the odd style, the extended part of the array is created by  subtracting the reflected values from two times the edge value.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>pad : ndarray  Padded array of rank equal to <code>array</code> with shape increased  according to <code>pad_width</code>.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>.. versionadded:: 1.7.0</p>
<p>For an array with rank greater than 1, some of the padding of later axes is calculated from padding of previous axes. This is easiest to think about with a rank 2 array where the corners of the padded array are calculated by using padded values from the first axis.</p>
<p>The padding function, if used, should modify a rank 1 array in-place. It has the following signature::</p>
<pre><code>padding_func(vector, iaxis_pad_width, iaxis, kwargs)
</code></pre>
<p>where</p>
<pre><code>vector : ndarray
    A rank 1 array already padded with zeros.  Padded values are
    vector[:iaxis_pad_width[0]] and vector[-iaxis_pad_width[1]:].
iaxis_pad_width : tuple
    A 2-tuple of ints, iaxis_pad_width[0] represents the number of
    values padded at the beginning of vector where
    iaxis_pad_width[1] represents the number of values padded at
    the end of vector.
iaxis : int
    The axis currently being calculated.
kwargs : dict
    Any keyword arguments the function requires.
</code></pre>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = [1, 2, 3, 4, 5] np.pad(a, (2, 3), constant, constant_values=(4, 6)) array([4, 4, 1, , 6, 6, 6])</p>
      <p>np.pad(a, (2, 3), edge) array([1, 1, 1, , 5, 5, 5])</p>
      <p>np.pad(a, (2, 3), linear_ramp, end_values=(5, -4)) array([ 5, 3, 1, 2, 3, 4, 5, 2, -1, -4])</p>
      <p>np.pad(a, (2,), maximum) array([5, 5, 1, 2, 3, 4, 5, 5, 5])</p>
      <p>np.pad(a, (2,), mean) array([3, 3, 1, 2, 3, 4, 5, 3, 3])</p>
      <p>np.pad(a, (2,), median) array([3, 3, 1, 2, 3, 4, 5, 3, 3])</p>
      <p>a = <a href="null">1, 2], [3, 4</a> np.pad(a, ((3, 2), (2, 3)), minimum) array(<a href="null">1, 1, 1, 2, 1, 1, 1],
       [1, 1, 1, 2, 1, 1, 1],
       [1, 1, 1, 2, 1, 1, 1],
       [1, 1, 1, 2, 1, 1, 1],
       [3, 3, 3, 4, 3, 3, 3],
       [1, 1, 1, 2, 1, 1, 1],
       [1, 1, 1, 2, 1, 1, 1</a>)</p>
      <p>a = [1, 2, 3, 4, 5] np.pad(a, (2, 3), reflect) array([3, 2, 1, 2, 3, 4, 5, 4, 3, 2])</p>
      <p>np.pad(a, (2, 3), reflect, reflect_type=odd) array([-1, 0, 1, 2, 3, 4, 5, 6, 7, 8])</p>
      <p>np.pad(a, (2, 3), symmetric) array([2, 1, 1, 2, 3, 4, 5, 5, 4, 3])</p>
      <p>np.pad(a, (2, 3), symmetric, reflect_type=odd) array([0, 1, 1, 2, 3, 4, 5, 5, 6, 7])</p>
      <p>np.pad(a, (2, 3), wrap) array([4, 5, 1, 2, 3, 4, 5, 1, 2, 3])</p>
      <p>def pad_with(vector, pad_width, iaxis, kwargs):  pad_value = kwargs.get(padder, 10)  vector[:pad_width[0]] = pad_value  vector[-pad_width[1]:] = pad_value a = np.arange(6) a = a.reshape((2, 3)) np.pad(a, 2, pad_with) array(<a href="null">10, 10, 10, 10, 10, 10, 10],
       [10, 10, 10, 10, 10, 10, 10],
       [10, 10,  0,  1,  2, 10, 10],
       [10, 10,  3,  4,  5, 10, 10],
       [10, 10, 10, 10, 10, 10, 10],
       [10, 10, 10, 10, 10, 10, 10</a>) np.pad(a, 2, pad_with, padder=100) array(<a href="null">100, 100, 100, 100, 100, 100, 100],
       [100, 100, 100, 100, 100, 100, 100],
       [100, 100,   0,   1,   2, 100, 100],
       [100, 100,   3,   4,   5, 100, 100],
       [100, 100, 100, 100, 100, 100, 100],
       [100, 100, 100, 100, 100, 100, 100</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L2932">view source</a></div></div><div class="public anchor" id="var-partition"><h3>partition</h3><div class="usage"><code>(partition &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return a partitioned copy of an array.</p>
<p>Creates a copy of the array with its elements rearranged in such a way that the value of the element in k-th position is in the position it would be in a sorted array. All elements smaller than the k-th element are moved before this element and all equal or greater are moved behind it. The ordering of the elements in the two partitions is undefined.</p>
<p>.. versionadded:: 1.8.0</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Array to be sorted. kth : int or sequence of ints  Element index to partition by. The k-th value of the element  will be in its final sorted position and all smaller elements  will be moved before it and all equal or greater elements behind  it. The order of all elements in the partitions is undefined. If  provided with a sequence of k-th it will partition all elements  indexed by k-th of them into their sorted position at once. axis : int or None, optional  Axis along which to sort. If None, the array is flattened before  sorting. The default is -1, which sorts along the last axis. kind : {introselect}, optional  Selection algorithm. Default is introselect. order : str or list of str, optional  When <code>a</code> is an array with fields defined, this argument  specifies which fields to compare first, second, etc. A single  field can be specified as a string. Not all fields need be  specified, but unspecified fields will still be used, in the  order in which they come up in the dtype, to break ties.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>partitioned_array : ndarray  Array of the same type and shape as <code>a</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>ndarray.partition : Method to sort an array in-place. argpartition : Indirect partition. sort : Full sorting</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The various selection algorithms are characterized by their average speed, worst case performance, work space size, and whether they are stable. A stable sort keeps items with the same key in the same relative order. The available algorithms have the following properties:</p>
<p>================= ======= ============= ============ =======  kind speed worst case work space stable ================= ======= ============= ============ ======= introselect 1 O(n) 0 no ================= ======= ============= ============ =======</p>
<p>All the partition algorithms make temporary copies of the data when partitioning along any but the last axis. Consequently, partitioning along the last axis is faster and uses less space than partitioning along any other axis.</p>
<p>The sort order for complex numbers is lexicographic. If both the real and imaginary parts are non-nan then the order is determined by the real parts except when they are equal, in which case the order is determined by the imaginary parts.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array([3, 4, 2, 1]) np.partition(a, 3) array([2, 1, 3, 4])</p>
      <p>np.partition(a, (1, 3)) array([1, 2, 3, 4])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L10357">view source</a></div></div><div class="public anchor" id="var-percentile"><h3>percentile</h3><div class="usage"><code>(percentile &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Compute the q-th percentile of the data along the specified axis.</p>
<p>Returns the q-th percentile(s) of the array elements.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input array or object that can be converted to an array. q : array_like of float  Percentile or sequence of percentiles to compute, which must be between  0 and 100 inclusive. axis : {int, tuple of int, None}, optional  Axis or axes along which the percentiles are computed. The  default is to compute the percentile(s) along a flattened  version of the array.</p>
<pre><code>.. versionchanged:: 1.9.0
    A tuple of axes is supported
</code></pre>
<p>out : ndarray, optional  Alternative output array in which to place the result. It must  have the same shape and buffer length as the expected output,  but the type (of the output) will be cast if necessary. overwrite_input : bool, optional  If True, then allow the input array <code>a</code> to be modified by intermediate  calculations, to save memory. In this case, the contents of the input  <code>a</code> after this function completes is undefined.</p>
<p>interpolation : {linear, lower, higher, midpoint, nearest}  This optional parameter specifies the interpolation method to  use when the desired percentile lies between two data points  <code>i &lt; j</code>:</p>
<pre><code>* 'linear': ``i + (j - i) * fraction``, where ``fraction``
  is the fractional part of the index surrounded by ``i``
  and ``j``.
* 'lower': ``i``.
* 'higher': ``j``.
* 'nearest': ``i`` or ``j``, whichever is nearest.
* 'midpoint': ``(i + j) / 2``.

.. versionadded:: 1.9.0
</code></pre>
<p>keepdims : bool, optional  If this is set to True, the axes which are reduced are left in  the result as dimensions with size one. With this option, the  result will broadcast correctly against the original array <code>a</code>.</p>
<pre><code>.. versionadded:: 1.9.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>percentile : scalar or ndarray  If <code>q</code> is a single percentile and <code>axis=None</code>, then the result  is a scalar. If multiple percentiles are given, first axis of  the result corresponds to the percentiles. The other axes are  the axes that remain after the reduction of <code>a</code>. If the input  contains integers or floats smaller than <code>float64</code>, the output  data-type is <code>float64</code>. Otherwise, the output data-type is the  same as that of the input. If <code>out</code> is specified, that array is  returned instead.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>mean median : equivalent to <code>percentile(..., 50)</code> nanpercentile quantile : equivalent to percentile, except with q in the range [0, 1].</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Given a vector <code>V</code> of length <code>N</code>, the q-th percentile of <code>V</code> is the value <code>q/100</code> of the way from the minimum to the maximum in a sorted copy of <code>V</code>. The values and distances of the two nearest neighbors as well as the <code>interpolation</code> parameter will determine the percentile if the normalized ranking does not match the location of <code>q</code> exactly. This function is the same as the median if <code>q=50</code>, the same as the minimum if <code>q=0</code> and the same as the maximum if <code>q=100</code>.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array(<a href="null">10, 7, 4], [3, 2, 1</a>) a array(<a href="null">10,  7,  4],
       [ 3,  2,  1</a>) np.percentile(a, 50) 3.5 np.percentile(a, 50, axis=0) array([6.5, 4.5, 2.5]) np.percentile(a, 50, axis=1) array([7., 2.]) np.percentile(a, 50, axis=1, keepdims=True) array(<a href="null">7.],
       [2.</a>)</p>
      <p>m = np.percentile(a, 50, axis=0) out = np.zeros_like(m) np.percentile(a, 50, axis=0, out=out) array([6.5, 4.5, 2.5]) m array([6.5, 4.5, 2.5])</p>
      <p>b = a.copy() np.percentile(b, 50, axis=1, overwrite_input=True) array([7., 2.]) assert not np.all(a == b)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The different types of interpolation can be visualized graphically:</p>
<p>.. plot::</p>
<pre><code>import matplotlib.pyplot as plt

a = np.arange(4)
p = np.linspace(0, 100, 6001)
ax = plt.gca()
lines = [
    ('linear', None),
    ('higher', '--'),
    ('lower', '--'),
    ('nearest', '-.'),
    ('midpoint', '-.'),
]
for interpolation, style in lines:
    ax.plot(
        p, np.percentile(a, p, interpolation=interpolation),
        label=interpolation, linestyle=style)
ax.set(
    title='Interpolation methods for list: ' + str(a),
    xlabel='Percentile',
    ylabel='List item returned',
    yticks=a)
ax.legend()
plt.show()
</code></pre></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L14369">view source</a></div></div><div class="public anchor" id="var-pi"><h3>pi</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L14835">view source</a></div></div><div class="public anchor" id="var-piecewise"><h3>piecewise</h3><div class="usage"><code>(piecewise &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Evaluate a piecewise-defined function.</p>
<p>Given a set of conditions and corresponding functions, evaluate each function on the input data wherever its condition is true.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : ndarray or scalar  The input domain. condlist : list of bool arrays or bool scalars  Each boolean array corresponds to a function in <code>funclist</code>. Wherever  <code>condlist[i]</code> is True, <code>funclist[i](x)</code> is used as the output value.</p>
<pre><code>Each boolean array in `condlist` selects a piece of `x`,
and should therefore be of the same shape as `x`.

The length of `condlist` must correspond to that of `funclist`.
If one extra function is given, i.e. if
``len(funclist) == len(condlist) + 1``, then that extra function
is the default value, used wherever all conditions are false.
</code></pre>
<p>funclist : list of callables, f(x,*args,**kw), or scalars  Each function is evaluated over <code>x</code> wherever its corresponding  condition is True. It should take a 1d array as input and give an 1d  array or a scalar value as output. If, instead of a callable,  a scalar is provided then a constant function (<code>lambda x: scalar</code>) is  assumed. args : tuple, optional  Any further arguments given to <code>piecewise</code> are passed to the functions  upon execution, i.e., if called <code>piecewise(..., ..., 1, 'a')</code>, then  each function is called as <code>f(x, 1, 'a')</code>. kw : dict, optional  Keyword arguments used in calling <code>piecewise</code> are passed to the  functions upon execution, i.e., if called  <code>piecewise(..., ..., alpha=1)</code>, then each function is called as  <code>f(x, alpha=1)</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  The output is the same shape and type as x and is found by  calling the functions in <code>funclist</code> on the appropriate portions of <code>x</code>,  as defined by the boolean arrays in <code>condlist</code>. Portions not covered  by any condition have a default value of 0.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>choose, select, where</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>This is similar to choose or select, except that functions are evaluated on elements of <code>x</code> that satisfy the corresponding condition from <code>condlist</code>.</p>
<p>The result is::</p>
<pre><code>    |--
    |funclist[0](x[condlist[0]])
</code></pre>
<p>out = |funclist<a href="x[condlist[1]]">1</a>  |  |funclist<a href="x[condlist[n2]]">n2</a>  |</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>Define the sigma function, which is -1 for <code>x &lt; 0</code> and +1 for <code>x &gt;= 0</code>.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.linspace(-2.5, 2.5, 6) np.piecewise(x, [x &lt; 0, x &gt;= 0], [-1, 1]) array([-1., -1., -1., 1., 1., 1.])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Define the absolute value, which is <code>-x</code> for <code>x &lt;0</code> and <code>x</code> for <code>x &gt;= 0</code>.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.piecewise(x, [x &lt; 0, x &gt;= 0], [lambda x: -x, lambda x: x]) array([2.5, 1.5, 0.5, 0.5, 1.5, 2.5])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Apply the same function to a scalar value.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>y = -2 np.piecewise(y, [y &lt; 0, y &gt;= 0], [lambda x: -x, lambda x: x]) array(2)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L20621">view source</a></div></div><div class="public anchor" id="var-PINF"><h3>PINF</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L22010">view source</a></div></div><div class="public anchor" id="var-place"><h3>place</h3><div class="usage"><code>(place &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Change elements of an array based on conditional and input values.</p>
<p>Similar to <code>np.copyto(arr, vals, where=mask)</code>, the difference is that <code>place</code> uses the first N elements of <code>vals</code>, where N is the number of True values in <code>mask</code>, while <code>copyto</code> uses the elements where <code>mask</code> is True.</p>
<p>Note that <code>extract</code> does the exact opposite of <code>place</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>arr : ndarray  Array to put data into. mask : array_like  Boolean mask array. Must have the same size as <code>a</code>. vals : 1-D sequence  Values to put into <code>a</code>. Only the first N elements are used, where  N is the number of True values in <code>mask</code>. If <code>vals</code> is smaller  than N, it will be repeated, and if elements of <code>a</code> are to be masked,  this sequence must be non-empty.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>copyto, put, take, extract</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>arr = np.arange(6).reshape(2, 3) np.place(arr, arr&gt;2, [44, 55]) arr array(<a href="null"> 0,  1,  2],
       [44, 55, 44</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L5542">view source</a></div></div><div class="public anchor" id="var-pmt"><h3>pmt</h3><div class="usage"><code>(pmt &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Compute the payment against loan principal plus interest.</p>
<p>.. deprecated:: 1.18</p>
<p><code>pmt</code> is deprecated; for details, see NEP 32 [1]_.  Use the corresponding function in the numpy-financial library,  <a href="https://pypi.org/project/numpy-financial">https://pypi.org/project/numpy-financial</a>.</p>
<p>Given:  * a present value, <code>pv</code> (e.g., an amount borrowed)  * a future value, <code>fv</code> (e.g., 0)  * an interest <code>rate</code> compounded once per period, of which  there are  * <code>nper</code> total  * and (optional) specification of whether payment is made  at the beginning (<code>when</code> = {begin, 1}) or the end  (<code>when</code> = {end, 0}) of each period</p>
<p>Return:  the (fixed) periodic payment.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>rate : array_like  Rate of interest (per period) nper : array_like  Number of compounding periods pv : array_like  Present value fv : array_like, optional  Future value (default = 0) when : {{begin, 1}, {end, 0}}, {string, int}  When payments are due (begin (1) or end (0))</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  Payment against loan plus interest. If all input is scalar, returns a  scalar float. If any input is array_like, returns payment for each  input element. If multiple inputs are array_like, they all must have  the same shape.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The payment is computed by solving the equation::</p>
<p>fv +  pv*(1 + rate)**nper +  pmt*(1 + rate*when)/rate*((1 + rate)**nper - 1) == 0</p>
<p>or, when <code>rate == 0</code>::</p>
<p>fv + pv + pmt * nper == 0</p>
<p>for <code>pmt</code>.</p>
<p>Note that computing a monthly mortgage payment is only one use for this function. For example, pmt returns the periodic deposit one must make to achieve a specified future balance given an initial deposit, a fixed, periodically compounded interest rate, and the total number of periods.</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [1] NumPy Enhancement Proposal (NEP) 32,  <a href="https://numpy.org/neps/nep-0032-remove-financial-functions.html">https://numpy.org/neps/nep-0032-remove-financial-functions.html</a> .. [2] Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May).  Open Document Format for Office Applications (OpenDocument)v1.2,  Part 2: Recalculated Formula (OpenFormula) Format - Annotated Version,  Pre-Draft 12. Organization for the Advancement of Structured Information  Standards (OASIS). Billerica, MA, USA. [ODT Document].  Available:  <a href="http://www.oasis-open.org/committees/documents.php">http://www.oasis-open.org/committees/documents.php</a>  ?wg_abbrev=office-formulaOpenDocument-formula-20090508.odt</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>What is the monthly payment needed to pay off a $200,000 loan in 15 years at an annual interest rate of 7.5%?</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.pmt(0.075/12, 12*15, 200000) -1854.0247200054619</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>In order to pay-off (i.e., have a future-value of 0) the $200,000 obtained today, a monthly payment of $1,854.02 would be required. Note that this example illustrates usage of <code>fv</code> having a default value of 0.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L27358">view source</a></div></div><div class="public anchor" id="var-poly"><h3>poly</h3><div class="usage"><code>(poly &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Find the coefficients of a polynomial with the given sequence of roots.</p>
<p>Returns the coefficients of the polynomial whose leading coefficient is one for the given sequence of zeros (multiple roots must be included in the sequence as many times as their multiplicity; see Examples). A square matrix (or array, which will be treated as a matrix) can also be given, in which case the coefficients of the characteristic polynomial of the matrix are returned.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>seq_of_zeros : array_like, shape (N,) or (N, N)  A sequence of polynomial roots, or a square array or matrix object.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>c : ndarray  1D array of polynomial coefficients from highest to lowest degree:</p>
<pre><code>``c[0] * x**(N) + c[1] * x**(N-1) + ... + c[N-1] * x + c[N]``
where c[0] always equals 1.
</code></pre>
<h2><a href="#raises" name="raises"></a>Raises</h2>
<p>ValueError  If input is the wrong shape (the input must be a 1-D or square  2-D array).</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>polyval : Compute polynomial values. roots : Return the roots of a polynomial. polyfit : Least squares polynomial fit. poly1d : A one-dimensional polynomial class.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Specifying the roots of a polynomial still leaves one degree of freedom, typically represented by an undetermined leading coefficient. [1]_ In the case of this function, that coefficient - the first one in the returned array - is always taken as one. (If for some reason you have one other point, the only automatic way presently to leverage that information is to use <code>polyfit</code>.)</p>
<p>The characteristic polynomial, :math:<code>p_a(t)</code>, of an <code>n</code>-by-<code>n</code> matrix <strong>A</strong> is given by</p>
<pre><code>:math:`p_a(t) = \mathrm{det}(t\, \mathbf{I} - \mathbf{A})`,
</code></pre>
<p>where <strong>I</strong> is the <code>n</code>-by-<code>n</code> identity matrix. [2]_</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [1] M. Sullivan and M. Sullivan, III, Algebra and Trignometry,  Enhanced With Graphing Utilities, Prentice-Hall, pg. 318, 1996.</p>
<p>.. [2] G. Strang, Linear Algebra and Its Applications, 2nd Edition,  Academic Press, pg. 182, 1980.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>Given a sequence of a polynomials zeros:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.poly((0, 0, 0)) # Multiple root example array([1., 0., 0., 0.])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The line above represents z**3 + 0*z**2 + 0*z + 0.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.poly((-1./2, 0, 1./2)) array([ 1. , 0. , -0.25, 0. ])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The line above represents z**3 - z/4</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.poly((np.random.random(1)[0], 0, np.random.random(1)[0])) array([ 1. , -0.77086955, 0.08618131, 0. ]) # random</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Given a square array object:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>P = np.array(<a href="null">0, 1./3], [-1./2, 0</a>) np.poly(P) array([1. , 0. , 0.16666667])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Note how in all cases the leading coefficient is always 1.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L4077">view source</a></div></div><div class="public anchor" id="var-poly1d"><h3>poly1d</h3><div class="usage"><code>(poly1d self c_or_r &amp; [{r :r, variable :variable}])</code><code>(poly1d self c_or_r &amp; [{r :r}])</code><code>(poly1d self c_or_r)</code></div><div class="doc"><div class="markdown"><p>A one-dimensional polynomial class.</p>
<p>A convenience class, used to encapsulate natural operations on polynomials so that said operations may take on their customary form in code (see Examples).</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>c_or_r : array_like  The polynomials coefficients, in decreasing powers, or if  the value of the second parameter is True, the polynomials  roots (values where the polynomial evaluates to 0). For example,  <code>poly1d([1, 2, 3])</code> returns an object that represents  :math:<code>x^2 + 2x + 3</code>, whereas <code>poly1d([1, 2, 3], True)</code> returns  one that represents :math:<code>(x-1)(x-2)(x-3) = x^3 - 6x^2 + 11x -6</code>. r : bool, optional  If True, <code>c_or_r</code> specifies the polynomials roots; the default  is False. variable : str, optional  Changes the variable used when printing <code>p</code> from <code>x</code> to <code>variable</code>  (see Examples).</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>Construct the polynomial :math:<code>x^2 + 2x + 3</code>:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>p = np.poly1d([1, 2, 3]) print(np.poly1d(p))  2 1 x + 2 x + 3</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Evaluate the polynomial at :math:<code>x = 0.5</code>:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>p(0.5) 4.25</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Find the roots:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>p.r array([-1.+1.41421356j, -1.-1.41421356j]) p(p.r) array([ -4.44089210e-16+0.j, -4.44089210e-16+0.j]) # may vary</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>These numbers in the previous line represent (0, 0) to machine precision</p>
<p>Show the coefficients:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>p.c array([1, 2, 3])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Display the order (the leading zero-coefficients are removed):</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>p.order 2</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Show the coefficient of the k-th power in the polynomial (which is equivalent to <code>p.c[-(i+1)]</code>):</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>p[1] 2</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Polynomials can be added, subtracted, multiplied, and divided (returns quotient and remainder):</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>p * p poly1d([ 1, 4, 10, 12, 9])</p>
      <p>(p**3 + 4) / p (poly1d([ 1., 4., 10., 12., 9.]), poly1d([4.]))</p>
    </blockquote>
  </blockquote>
</blockquote>
<p><code>asarray(p)</code> gives the coefficient array, so polynomials can be used in all functions that accept arrays:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>p**2 # square of polynomial poly1d([ 1, 4, 10, 12, 9])</p>
      <p>np.square(p) # square of individual coefficients array([1, 4, 9])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The variable used in the string representation of <code>p</code> can be modified, using the <code>variable</code> parameter:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>p = np.poly1d([1,2,3], variable=z) print(p)  2 1 z + 2 z + 3</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Construct a polynomial from its roots:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.poly1d([1, 2], True) poly1d([ 1., -3., 2.])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>This is the same polynomial as obtained by:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.poly1d([1, -1]) * np.poly1d([1, -2]) poly1d([ 1, -3, 2])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L12789">view source</a></div></div><div class="public anchor" id="var-polyadd"><h3>polyadd</h3><div class="usage"><code>(polyadd &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Find the sum of two polynomials.</p>
<p>Returns the polynomial resulting from the sum of two input polynomials. Each input must be either a poly1d object or a 1D sequence of polynomial coefficients, from highest to lowest degree.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a1, a2 : array_like or poly1d object  Input polynomials.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray or poly1d object  The sum of the inputs. If either input is a poly1d object, then the  output is also a poly1d object. Otherwise, it is a 1D array of  polynomial coefficients from highest to lowest degree.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>poly1d : A one-dimensional polynomial class. poly, polyadd, polyder, polydiv, polyfit, polyint, polysub, polyval</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.polyadd([1, 2], [9, 5, 4]) array([9, 6, 6])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Using poly1d objects:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>p1 = np.poly1d([1, 2]) p2 = np.poly1d([9, 5, 4]) print(p1) 1 x + 2 print(p2)  2 9 x + 5 x + 4 print(np.polyadd(p1, p2))  2 9 x + 6 x + 6</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L17955">view source</a></div></div><div class="public anchor" id="var-polyder"><h3>polyder</h3><div class="usage"><code>(polyder &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return the derivative of the specified order of a polynomial.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>p : poly1d or sequence  Polynomial to differentiate.  A sequence is interpreted as polynomial coefficients, see <code>poly1d</code>. m : int, optional  Order of differentiation (default: 1)</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>der : poly1d  A new polynomial representing the derivative.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>polyint : Anti-derivative of a polynomial. poly1d : Class for one-dimensional polynomials.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>The derivative of the polynomial :math:<code>x^3 + x^2 + x^1 + 1</code> is:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>p = np.poly1d([1,1,1,1]) p2 = np.polyder(p) p2 poly1d([3, 2, 1])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>which evaluates to:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>p2(2.) 17.0</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>We can verify this, approximating the derivative with <code>(f(x + h) - f(x))/h</code>:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>(p(2. + 0.001) - p(2.)) / 0.001 17.007000999997857</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The fourth-order derivative of a 3rd-order polynomial is zero:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.polyder(p, 2) poly1d([6, 2]) np.polyder(p, 3) poly1d([6]) np.polyder(p, 4) poly1d([0.])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L28140">view source</a></div></div><div class="public anchor" id="var-polydiv"><h3>polydiv</h3><div class="usage"><code>(polydiv &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Returns the quotient and remainder of polynomial division.</p>
<p>The input arrays are the coefficients (including any coefficients equal to zero) of the numerator (dividend) and denominator (divisor) polynomials, respectively.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>u : array_like or poly1d  Dividend polynomials coefficients.</p>
<p>v : array_like or poly1d  Divisor polynomials coefficients.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>q : ndarray  Coefficients, including those equal to zero, of the quotient. r : ndarray  Coefficients, including those equal to zero, of the remainder.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>poly, polyadd, polyder, polydiv, polyfit, polyint, polymul, polysub polyval</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Both <code>u</code> and <code>v</code> must be 0-d or 1-d (ndim = 0 or 1), but <code>u.ndim</code> need not equal <code>v.ndim</code>. In other words, all four possible combinations - <code>u.ndim = v.ndim = 0</code>, <code>u.ndim = v.ndim = 1</code>, <code>u.ndim = 1, v.ndim = 0</code>, and <code>u.ndim = 0, v.ndim = 1</code> - work.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>.. math:: \frac{3x^2 + 5x + 2}{2x + 1} = 1.5x + 1.75, remainder 0.25</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.array([3.0, 5.0, 2.0]) y = np.array([2.0, 1.0]) np.polydiv(x, y) (array([1.5 , 1.75]), array([0.25]))</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L28754">view source</a></div></div><div class="public anchor" id="var-polyfit"><h3>polyfit</h3><div class="usage"><code>(polyfit &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Least squares polynomial fit.</p>
<p>Fit a polynomial <code>p(x) = p[0] * x**deg + ... + p[deg]</code> of degree <code>deg</code> to points <code>(x, y)</code>. Returns a vector of coefficients <code>p</code> that minimises the squared error in the order <code>deg</code>, <code>deg-1</code>,  <code>0</code>.</p>
<p>The <code>Polynomial.fit &lt;numpy.polynomial.polynomial.Polynomial.fit&gt;</code> class method is recommended for new code as it is more stable numerically. See the documentation of the method for more information.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like, shape (M,)  x-coordinates of the M sample points <code>(x[i], y[i])</code>. y : array_like, shape (M,) or (M, K)  y-coordinates of the sample points. Several data sets of sample  points sharing the same x-coordinates can be fitted at once by  passing in a 2D-array that contains one dataset per column. deg : int  Degree of the fitting polynomial rcond : float, optional  Relative condition number of the fit. Singular values smaller than  this relative to the largest singular value will be ignored. The  default value is len(x)*eps, where eps is the relative precision of  the float type, about 2e-16 in most cases. full : bool, optional  Switch determining nature of return value. When it is False (the  default) just the coefficients are returned, when True diagnostic  information from the singular value decomposition is also returned. w : array_like, shape (M,), optional  Weights to apply to the y-coordinates of the sample points. For  gaussian uncertainties, use 1/sigma (not 1/sigma**2). cov : bool or str, optional  If given and not <code>False</code>, return not just the estimate but also its  covariance matrix. By default, the covariance are scaled by  chi2/sqrt(N-dof), i.e., the weights are presumed to be unreliable  except in a relative sense and everything is scaled such that the  reduced chi2 is unity. This scaling is omitted if <code>cov='unscaled'</code>,  as is relevant for the case that the weights are 1/sigma**2, with  sigma known to be a reliable estimate of the uncertainty.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>p : ndarray, shape (deg + 1,) or (deg + 1, K)  Polynomial coefficients, highest power first. If <code>y</code> was 2-D, the  coefficients for <code>k</code>-th data set are in <code>p[:,k]</code>.</p>
<p>residuals, rank, singular_values, rcond  Present only if <code>full</code> = True. Residuals is sum of squared residuals  of the least-squares fit, the effective rank of the scaled Vandermonde  coefficient matrix, its singular values, and the specified value of  <code>rcond</code>. For more details, see <code>linalg.lstsq</code>.</p>
<p>V : ndarray, shape (M,M) or (M,M,K)  Present only if <code>full</code> = False and <code>cov</code>=True. The covariance  matrix of the polynomial coefficient estimates. The diagonal of  this matrix are the variance estimates for each coefficient. If y  is a 2-D array, then the covariance matrix for the <code>k</code>-th data set  are in <code>V[:,:,k]</code></p>
<h2><a href="#warns" name="warns"></a>Warns</h2>
<p>RankWarning  The rank of the coefficient matrix in the least-squares fit is  deficient. The warning is only raised if <code>full</code> = False.</p>
<pre><code>The warnings can be turned off by

&gt;&gt;&gt; import warnings
&gt;&gt;&gt; warnings.simplefilter('ignore', np.RankWarning)
</code></pre>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>polyval : Compute polynomial values. linalg.lstsq : Computes a least-squares fit. scipy.interpolate.UnivariateSpline : Computes spline fits.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The solution minimizes the squared error</p>
<p>.. math ::  E = \sum_{j=0}^k |p(x_j) - y_j|^2</p>
<p>in the equations::</p>
<pre><code>x[0]**n * p[0] + ... + x[0] * p[n-1] + p[n] = y[0]
x[1]**n * p[0] + ... + x[1] * p[n-1] + p[n] = y[1]
...
x[k]**n * p[0] + ... + x[k] * p[n-1] + p[n] = y[k]
</code></pre>
<p>The coefficient matrix of the coefficients <code>p</code> is a Vandermonde matrix.</p>
<p><code>polyfit</code> issues a <code>RankWarning</code> when the least-squares fit is badly conditioned. This implies that the best fit is not well-defined due to numerical error. The results may be improved by lowering the polynomial degree or by replacing <code>x</code> by <code>x</code> - <code>x</code>.mean(). The <code>rcond</code> parameter can also be set to a value smaller than its default, but the resulting fit may be spurious: including contributions from the small singular values can add numerical noise to the result.</p>
<p>Note that fitting polynomial coefficients is inherently badly conditioned when the degree of the polynomial is large or the interval of sample points is badly centered. The quality of the fit should always be checked in these cases. When polynomial fits are not satisfactory, splines may be a good alternative.</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [1] Wikipedia, Curve fitting,  <a href="https://en.wikipedia.org/wiki/Curve_fitting">https://en.wikipedia.org/wiki/Curve_fitting</a> .. [2] Wikipedia, Polynomial interpolation,  <a href="https://en.wikipedia.org/wiki/Polynomial_interpolation">https://en.wikipedia.org/wiki/Polynomial_interpolation</a></p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>import warnings x = np.array([0.0, 1.0, 2.0, 3.0, 4.0, 5.0]) y = np.array([0.0, 0.8, 0.9, 0.1, -0.8, -1.0]) z = np.polyfit(x, y, 3) z array([ 0.08703704, -0.81349206, 1.69312169, -0.03968254]) # may vary</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>It is convenient to use <code>poly1d</code> objects for dealing with polynomials:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>p = np.poly1d(z) p(0.5) 0.6143849206349179 # may vary p(3.5) -0.34732142857143039 # may vary p(10) 22.579365079365115 # may vary</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>High-order polynomials may oscillate wildly:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>with warnings.catch_warnings():  warnings.simplefilter(ignore, np.RankWarning)  p30 = np.poly1d(np.polyfit(x, y, 30))  p30(4) -0.80000000000000204 # may vary p30(5) -0.99999999999999445 # may vary p30(4.5) -0.10547061179440398 # may vary</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Illustration:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>import matplotlib.pyplot as plt xp = np.linspace(-2, 6, 100) _ = plt.plot(x, y, ., xp, p(xp), -, xp, p30(xp), ) plt.ylim(-2,2) (-2, 2) plt.show()</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L18376">view source</a></div></div><div class="public anchor" id="var-polyint"><h3>polyint</h3><div class="usage"><code>(polyint &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return an antiderivative (indefinite integral) of a polynomial.</p>
<p>The returned order <code>m</code> antiderivative <code>P</code> of polynomial <code>p</code> satisfies :math:<code>\frac{d^m}{dx^m}P(x) = p(x)</code> and is defined up to <code>m - 1</code> integration constants <code>k</code>. The constants determine the low-order polynomial part</p>
<p>.. math:: \frac{k_{m-1}}{0!} x^0 + \ldots + \frac{k_0}{(m-1)!}x^{m-1}</p>
<p>of <code>P</code> so that :math:<code>P^{(j)}(0) = k_{m-j-1}</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>p : array_like or poly1d  Polynomial to integrate.  A sequence is interpreted as polynomial coefficients, see <code>poly1d</code>. m : int, optional  Order of the antiderivative. (Default: 1) k : list of <code>m</code> scalars or scalar, optional  Integration constants. They are given in the order of integration:  those corresponding to highest-order terms come first.</p>
<pre><code>If ``None`` (default), all constants are assumed to be zero.
If `m = 1`, a single scalar can be given instead of a list.
</code></pre>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>polyder : derivative of a polynomial poly1d.integ : equivalent method</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>The defining property of the antiderivative:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>p = np.poly1d([1,1,1]) P = np.polyint(p) P  poly1d([ 0.33333333, 0.5 , 1. , 0. ]) # may vary np.polyder(P) == p True</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The integration constants default to zero, but can be specified:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>P = np.polyint(p, 3) P(0) 0.0 np.polyder(P)(0) 0.0 np.polyder(P, 2)(0) 0.0 P = np.polyint(p, 3, k=[6,5,3]) P poly1d([ 0.01666667, 0.04166667, 0.16666667, 3. , 5. , 3. ]) # may vary</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Note that 3 = 6 / 2!, and that the constants are given in the order of integrations. Constant of the highest-order polynomial term comes first:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.polyder(P, 2)(0) 6.0 np.polyder(P, 1)(0) 5.0 P(0) 3.0</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L9615">view source</a></div></div><div class="public anchor" id="var-polymul"><h3>polymul</h3><div class="usage"><code>(polymul &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Find the product of two polynomials.</p>
<p>Finds the polynomial resulting from the multiplication of the two input polynomials. Each input must be either a poly1d object or a 1D sequence of polynomial coefficients, from highest to lowest degree.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a1, a2 : array_like or poly1d object  Input polynomials.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray or poly1d object  The polynomial resulting from the multiplication of the inputs. If  either inputs is a poly1d object, then the output is also a poly1d  object. Otherwise, it is a 1D array of polynomial coefficients from  highest to lowest degree.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>poly1d : A one-dimensional polynomial class. poly, polyadd, polyder, polydiv, polyfit, polyint, polysub, polyval convolve : Array convolution. Same output as polymul, but has parameter  for overlap mode.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.polymul([1, 2, 3], [9, 5, 1]) array([ 9, 23, 38, 17, 3])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Using poly1d objects:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>p1 = np.poly1d([1, 2, 3]) p2 = np.poly1d([9, 5, 1]) print(p1)  2 1 x + 2 x + 3 print(p2)  2 9 x + 5 x + 1 print(np.polymul(p1, p2))  4 3 2 9 x + 23 x + 38 x + 17 x + 3</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L18243">view source</a></div></div><div class="public anchor" id="var-polynomial"><h3>polynomial</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>A sub-package for efficiently dealing with polynomials.</p>
<p>Within the documentation for this sub-package, a finite power series, i.e., a polynomial (also referred to simply as a series) is represented by a 1-D numpy array of the polynomials coefficients, ordered from lowest order term to highest. For example, array([1,2,3]) represents <code>P_0 + 2*P_1 + 3*P_2</code>, where P_n is the n-th order basis polynomial applicable to the specific module in question, e.g., <code>polynomial</code> (which wraps the standard basis) or <code>chebyshev</code>. For optimal performance, all operations on polynomials, including evaluation at an argument, are implemented as operations on the coefficients. Additional (module-specific) information can be found in the docstring for the module of interest.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L28124">view source</a></div></div><div class="public anchor" id="var-polysub"><h3>polysub</h3><div class="usage"><code>(polysub &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Difference (subtraction) of two polynomials.</p>
<p>Given two polynomials <code>a1</code> and <code>a2</code>, returns <code>a1 - a2</code>. <code>a1</code> and <code>a2</code> can be either array_like sequences of the polynomials coefficients (including coefficients equal to zero), or <code>poly1d</code> objects.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a1, a2 : array_like or poly1d  Minuend and subtrahend polynomials, respectively.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray or poly1d  Array or <code>poly1d</code> object of the difference polynomials coefficients.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>polyval, polydiv, polymul, polyadd</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>.. math:: (2 x^2 + 10 x - 2) - (3 x^2 + 10 x -4) = (-x^2 + 2)</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.polysub([2, 10, -2], [3, 10, -4]) array([-1, 0, 2])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L9267">view source</a></div></div><div class="public anchor" id="var-polyval"><h3>polyval</h3><div class="usage"><code>(polyval &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Evaluate a polynomial at specific values.</p>
<p>If <code>p</code> is of length N, this function returns the value:</p>
<pre><code>``p[0]*x**(N-1) + p[1]*x**(N-2) + ... + p[N-2]*x + p[N-1]``
</code></pre>
<p>If <code>x</code> is a sequence, then <code>p(x)</code> is returned for each element of <code>x</code>. If <code>x</code> is another polynomial then the composite polynomial <code>p(x(t))</code> is returned.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>p : array_like or poly1d object  1D array of polynomial coefficients (including coefficients equal  to zero) from highest degree to the constant term, or an  instance of poly1d. x : array_like or poly1d object  A number, an array of numbers, or an instance of poly1d, at  which to evaluate <code>p</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>values : ndarray or poly1d  If <code>x</code> is a poly1d instance, the result is the composition of the two  polynomials, i.e., <code>x</code> is substituted in <code>p</code> and the simplified  result is returned. In addition, the type of <code>x</code> - array_like or  poly1d - governs the type of the output: <code>x</code> array_like =&gt; <code>values</code>  array_like, <code>x</code> a poly1d object =&gt; <code>values</code> is also.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>poly1d: A polynomial class.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Horners scheme [1]_ is used to evaluate the polynomial. Even so, for polynomials of high degree the values may be inaccurate due to rounding errors. Use carefully.</p>
<p>If <code>x</code> is a subtype of <code>ndarray</code> the return value will be of the same type.</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [1] I. N. Bronshtein, K. A. Semendyayev, and K. A. Hirsch (Eng.  trans. Ed.), <em>Handbook of Mathematics</em>, New York, Van Nostrand  Reinhold Co., 1985, pg. 720.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.polyval([3,0,1], 5) # 3 * 5**2 + 0 * 5**1 + 1 76 np.polyval([3,0,1], np.poly1d(5)) poly1d([76.]) np.polyval(np.poly1d([3,0,1]), 5) 76 np.polyval(np.poly1d([3,0,1]), np.poly1d(5)) poly1d([76.])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L2553">view source</a></div></div><div class="public anchor" id="var-positive"><h3>positive</h3><div class="usage"><code>(positive self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>positive(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Numerical positive, element-wise.</p>
<p>.. versionadded:: 1.13.0</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like or scalar  Input array.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray or scalar  Returned array or scalar: <code>y = +x</code>.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Equivalent to <code>x.copy()</code>, but only defined for types that support arithmetic.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L4385">view source</a></div></div><div class="public anchor" id="var-power"><h3>power</h3><div class="usage"><code>(power self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>power(x1, x2, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>First array elements raised to powers from second array, element-wise.</p>
<p>Raise each base in <code>x1</code> to the positionally-corresponding power in <code>x2</code>. <code>x1</code> and <code>x2</code> must be broadcastable to the same shape. Note that an integer type raised to a negative integer power will raise a ValueError.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x1 : array_like  The bases. x2 : array_like  The exponents. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output). out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray  The bases in <code>x1</code> raised to the exponents in <code>x2</code>.  This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>float_power : power function that promotes integers to float</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>Cube each element in a list.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x1 = range(6) x1 [0, 1, 2, 3, 4, 5] np.power(x1, 3) array([ 0, 1, 8, 27, 64, 125])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Raise the bases to different exponents.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x2 = [1.0, 2.0, 3.0, 3.0, 2.0, 1.0] np.power(x1, x2) array([ 0., 1., 8., 27., 16., 5.])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The effect of broadcasting.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x2 = np.array(<a href="null">1, 2, 3, 3, 2, 1], [1, 2, 3, 3, 2, 1</a>) x2 array(<a href="null">1, 2, 3, 3, 2, 1],
       [1, 2, 3, 3, 2, 1</a>) np.power(x1, x2) array(<a href="null"> 0,  1,  8, 27, 16,  5],
       [ 0,  1,  8, 27, 16,  5</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L14768">view source</a></div></div><div class="public anchor" id="var-ppmt"><h3>ppmt</h3><div class="usage"><code>(ppmt &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Compute the payment against loan principal.</p>
<p>.. deprecated:: 1.18</p>
<p><code>ppmt</code> is deprecated; for details, see NEP 32 [1]_.  Use the corresponding function in the numpy-financial library,  <a href="https://pypi.org/project/numpy-financial">https://pypi.org/project/numpy-financial</a>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>rate : array_like  Rate of interest (per period) per : array_like, int  Amount paid against the loan changes. The <code>per</code> is the period of  interest. nper : array_like  Number of compounding periods pv : array_like  Present value fv : array_like, optional  Future value when : {{begin, 1}, {end, 0}}, {string, int}  When payments are due (begin (1) or end (0))</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>pmt, pv, ipmt</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [1] NumPy Enhancement Proposal (NEP) 32,  <a href="https://numpy.org/neps/nep-0032-remove-financial-functions.html">https://numpy.org/neps/nep-0032-remove-financial-functions.html</a></p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L8912">view source</a></div></div><div class="public anchor" id="var-print_function"><h3>print_function</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L18036">view source</a></div></div><div class="public anchor" id="var-printoptions"><h3>printoptions</h3><div class="usage"><code>(printoptions &amp; [args {:as kwds}])</code></div><div class="doc"><div class="markdown"><p>Context manager for setting print options.</p>
<p>Set print options for the scope of the <code>with</code> block, and restore the old options at the end. See <code>set_printoptions</code> for the full description of available options.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>from numpy.testing import assert_equal with np.printoptions(precision=2):  np.array([2.0]) / 3 array([0.67])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The <code>as</code>-clause of the <code>with</code>-statement gives the current print options:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>with np.printoptions(precision=2) as opts:  assert_equal(opts, np.get_printoptions())</p>
    </blockquote>
  </blockquote>
</blockquote>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>set_printoptions, get_printoptions</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L20105">view source</a></div></div><div class="public anchor" id="var-prod"><h3>prod</h3><div class="usage"><code>(prod &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return the product of array elements over a given axis.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input data. axis : None or int or tuple of ints, optional  Axis or axes along which a product is performed. The default,  axis=None, will calculate the product of all the elements in the  input array. If axis is negative it counts from the last to the  first axis.</p>
<pre><code>.. versionadded:: 1.7.0

If axis is a tuple of ints, a product is performed on all of the
axes specified in the tuple instead of a single axis or all the
axes as before.
</code></pre>
<p>dtype : dtype, optional  The type of the returned array, as well as of the accumulator in  which the elements are multiplied. The dtype of <code>a</code> is used by  default unless <code>a</code> has an integer dtype of less precision than the  default platform integer. In that case, if <code>a</code> is signed then the  platform integer is used while if <code>a</code> is unsigned then an unsigned  integer of the same precision as the platform integer is used. out : ndarray, optional  Alternative output array in which to place the result. It must have  the same shape as the expected output, but the type of the output  values will be cast if necessary. keepdims : bool, optional  If this is set to True, the axes which are reduced are left in the  result as dimensions with size one. With this option, the result  will broadcast correctly against the input array.</p>
<pre><code>If the default value is passed, then `keepdims` will not be
passed through to the `prod` method of sub-classes of
`ndarray`, however any non-default value will be.  If the
sub-class' method does not implement `keepdims` any
exceptions will be raised.
</code></pre>
<p>initial : scalar, optional  The starting value for this product. See <code>~numpy.ufunc.reduce</code> for details.</p>
<pre><code>.. versionadded:: 1.15.0
</code></pre>
<p>where : array_like of bool, optional  Elements to include in the product. See <code>~numpy.ufunc.reduce</code> for details.</p>
<pre><code>.. versionadded:: 1.17.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>product_along_axis : ndarray, see <code>dtype</code> parameter above.  An array shaped as <code>a</code> but with the specified axis removed.  Returns a reference to <code>out</code> if specified.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>ndarray.prod : equivalent method ufuncs-output-type</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Arithmetic is modular when using integer types, and no error is raised on overflow. That means that, on a 32-bit platform:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.array([536870910, 536870910, 536870910, 536870910]) np.prod(x) 16 # may vary</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The product of an empty array is the neutral element 1:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.prod([]) 1.0</p>
    </blockquote>
  </blockquote>
</blockquote>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>By default, calculate the product of all elements:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.prod([1.,2.]) 2.0</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Even when the input array is two-dimensional:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.prod(<a href="null">1.,2.],[3.,4.</a>) 24.0</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>But we can also specify the axis over which to multiply:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.prod(<a href="null">1.,2.],[3.,4.</a>, axis=1) array([ 2., 12.])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Or select specific elements to include:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.prod([1., np.nan, 3.], where=[True, False, True]) 3.0</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>If the type of <code>x</code> is unsigned, then the output type is the unsigned platform integer:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.array([1, 2, 3], dtype=np.uint8) np.prod(x).dtype == np.uint True</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>If <code>x</code> is of a signed integer type, then the output type is the default platform integer:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.array([1, 2, 3], dtype=np.int8) np.prod(x).dtype == int True</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>You can also start the product with a value other than one:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.prod([1, 2], initial=5) 10</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L7242">view source</a></div></div><div class="public anchor" id="var-product"><h3>product</h3><div class="usage"><code>(product &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return the product of array elements over a given axis.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>prod : equivalent function; see for details.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L13517">view source</a></div></div><div class="public anchor" id="var-promote_types"><h3>promote_types</h3><div class="usage"><code>(promote_types self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>promote_types(type1, type2)</p>
<p>Returns the data type with the smallest size and smallest scalar kind to which both <code>type1</code> and <code>type2</code> may be safely cast. The returned data type is always in native byte order.</p>
<p>This function is symmetric, but rarely associative.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>type1 : dtype or dtype specifier  First data type. type2 : dtype or dtype specifier  Second data type.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : dtype  The promoted data type.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>.. versionadded:: 1.6.0</p>
<p>Starting in NumPy 1.9, promote_types function now returns a valid string length when given an integer or float dtype as one argument and a string dtype as another argument. Previously it always returned the input string dtype, even if it wasnt long enough to store the max integer/float value converted to a string.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>result_type, dtype, can_cast</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.promote_types(f4, f8) dtype(float64)</p>
      <p>np.promote_types(i8, f4) dtype(float64)</p>
      <p>np.promote_types(&gt;i8, &lt;c8) dtype(complex128)</p>
      <p>np.promote_types(i4, S8) dtype(S11)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>An example of a non-associative case:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>p = np.promote_types p(S, p(i1, u1)) dtype(S6) p(p(S, i1), u1) dtype(S4)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L20195">view source</a></div></div><div class="public anchor" id="var-ptp"><h3>ptp</h3><div class="usage"><code>(ptp &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Range of values (maximum - minimum) along an axis.</p>
<p>The name of the function comes from the acronym for peak to peak.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input values. axis : None or int or tuple of ints, optional  Axis along which to find the peaks. By default, flatten the  array. <code>axis</code> may be negative, in  which case it counts from the last to the first axis.</p>
<pre><code>.. versionadded:: 1.15.0

If this is a tuple of ints, a reduction is performed on multiple
axes, instead of a single axis or all the axes as before.
</code></pre>
<p>out : array_like  Alternative output array in which to place the result. It must  have the same shape and buffer length as the expected output,  but the type of the output values will be cast if necessary.</p>
<p>keepdims : bool, optional  If this is set to True, the axes which are reduced are left  in the result as dimensions with size one. With this option,  the result will broadcast correctly against the input array.</p>
<pre><code>If the default value is passed, then `keepdims` will not be
passed through to the `ptp` method of sub-classes of
`ndarray`, however any non-default value will be.  If the
sub-class' method does not implement `keepdims` any
exceptions will be raised.
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>ptp : ndarray  A new array holding the result, unless <code>out</code> was  specified, in which case a reference to <code>out</code> is returned.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.arange(4).reshape((2,2)) x array(<a href="null">0, 1],
       [2, 3</a>)</p>
      <p>np.ptp(x, axis=0) array([2, 2])</p>
      <p>np.ptp(x, axis=1) array([1, 1])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L13531">view source</a></div></div><div class="public anchor" id="var-put"><h3>put</h3><div class="usage"><code>(put &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Replaces specified elements of an array with given values.</p>
<p>The indexing works on the flattened target array. <code>put</code> is roughly equivalent to:</p>
<p>::</p>
<pre><code>a.flat[ind] = v
</code></pre>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : ndarray  Target array. ind : array_like  Target indices, interpreted as integers. v : array_like  Values to place in <code>a</code> at target indices. If <code>v</code> is shorter than  <code>ind</code> it will be repeated as necessary. mode : {raise, wrap, clip}, optional  Specifies how out-of-bounds indices will behave.</p>
<pre><code>* 'raise' -- raise an error (default)
* 'wrap' -- wrap around
* 'clip' -- clip to the range

'clip' mode means that all indices that are too large are replaced
by the index that addresses the last element along that axis. Note
that this disables indexing with negative numbers. In 'raise' mode,
if an exception occurs the target array may still be modified.
</code></pre>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>putmask, place put_along_axis : Put elements by matching the array and the index arrays</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.arange(5) np.put(a, [0, 2], [-44, -55]) a array([-44, 1, -55, 3, 4])</p>
      <p>a = np.arange(5) np.put(a, 22, -5, mode=clip) a array([ 0, 1, 2, 3, -5])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L6011">view source</a></div></div><div class="public anchor" id="var-put_along_axis"><h3>put_along_axis</h3><div class="usage"><code>(put_along_axis &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Put values into the destination array by matching 1d index and data slices.</p>
<p>This iterates over matching 1d slices oriented along the specified axis in the index and data arrays, and uses the former to place values into the latter. These slices can be different lengths.</p>
<p>Functions returning an index along an axis, like <code>argsort</code> and <code>argpartition</code>, produce suitable indices for this function.</p>
<p>.. versionadded:: 1.15.0</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>arr: ndarray (Ni, M, Nk)  Destination array. indices: ndarray (Ni, J, Nk)  Indices to change along each 1d slice of <code>arr</code>. This must match the  dimension of arr, but dimensions in Ni and Nj may be 1 to broadcast  against <code>arr</code>. values: array_like (Ni, J, Nk)  values to insert at those indices. Its shape and dimension are  broadcast to match that of <code>indices</code>. axis: int  The axis to take 1d slices along. If axis is None, the destination  array is treated as if a flattened 1d view had been created of it.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>This is equivalent to (but faster than) the following use of <code>ndindex</code> and <code>s_</code>, which sets each of <code>ii</code> and <code>kk</code> to a tuple of indices::</p>
<pre><code>Ni, M, Nk = a.shape[:axis], a.shape[axis], a.shape[axis+1:]
J = indices.shape[axis]  # Need not equal M

for ii in ndindex(Ni):
    for kk in ndindex(Nk):
        a_1d       = a      [ii + s_[:,] + kk]
        indices_1d = indices[ii + s_[:,] + kk]
        values_1d  = values [ii + s_[:,] + kk]
        for j in range(J):
            a_1d[indices_1d[j]] = values_1d[j]
</code></pre>
<p>Equivalently, eliminating the inner loop, the last two lines would be::</p>
<pre><code>        a_1d[indices_1d] = values_1d
</code></pre>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>take_along_axis :  Take values from the input array by matching 1d index and data slices</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>For this sample array</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array(<a href="null">10, 30, 20], [60, 40, 50</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>We can replace the maximum values with:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>ai = np.expand_dims(np.argmax(a, axis=1), axis=1) ai array(<a href="null">1],
       [0</a>) np.put_along_axis(a, ai, 99, axis=1) a array(<a href="null">10, 99, 20],
       [99, 40, 50</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L4258">view source</a></div></div><div class="public anchor" id="var-putmask"><h3>putmask</h3><div class="usage"><code>(putmask &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>putmask(a, mask, values)</p>
<p>Changes elements of an array based on conditional and input values.</p>
<p>Sets <code>a.flat[n] = values[n]</code> for each n where <code>mask.flat[n]==True</code>.</p>
<p>If <code>values</code> is not the same size as <code>a</code> and <code>mask</code> then it will repeat. This gives behavior different from <code>a[mask] = values</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Target array. mask : array_like  Boolean mask array. It has to be the same shape as <code>a</code>. values : array_like  Values to put into <code>a</code> where <code>mask</code> is True. If <code>values</code> is smaller  than <code>a</code> it will be repeated.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>place, put, take, copyto</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.arange(6).reshape(2, 3) np.putmask(x, x&gt;2, x**2) x array(<a href="null"> 0,  1,  2],
       [ 9, 16, 25</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>If <code>values</code> is smaller than <code>a</code> it is repeated:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.arange(5) np.putmask(x, x&gt;1, [-33, -44]) x array([ 0, 1, -33, -44, -33])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L11683">view source</a></div></div><div class="public anchor" id="var-pv"><h3>pv</h3><div class="usage"><code>(pv &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Compute the present value.</p>
<p>.. deprecated:: 1.18</p>
<p><code>pv</code> is deprecated; for details, see NEP 32 [1]_.  Use the corresponding function in the numpy-financial library,  <a href="https://pypi.org/project/numpy-financial">https://pypi.org/project/numpy-financial</a>.</p>
<p>Given:  * a future value, <code>fv</code>  * an interest <code>rate</code> compounded once per period, of which  there are  * <code>nper</code> total  * a (fixed) payment, <code>pmt</code>, paid either  * at the beginning (<code>when</code> = {begin, 1}) or the end  (<code>when</code> = {end, 0}) of each period</p>
<p>Return:  the value now</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>rate : array_like  Rate of interest (per period) nper : array_like  Number of compounding periods pmt : array_like  Payment fv : array_like, optional  Future value when : {{begin, 1}, {end, 0}}, {string, int}, optional  When payments are due (begin (1) or end (0))</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray, float  Present value of a series of payments or investments.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The present value is computed by solving the equation::</p>
<p>fv +  pv*(1 + rate)**nper +  pmt*(1 + rate*when)/rate*((1 + rate)**nper - 1) = 0</p>
<p>or, when <code>rate = 0</code>::</p>
<p>fv + pv + pmt * nper = 0</p>
<p>for <code>pv</code>, which is then returned.</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [1] NumPy Enhancement Proposal (NEP) 32,  <a href="https://numpy.org/neps/nep-0032-remove-financial-functions.html">https://numpy.org/neps/nep-0032-remove-financial-functions.html</a> .. [2] Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May).  Open Document Format for Office Applications (OpenDocument)v1.2,  Part 2: Recalculated Formula (OpenFormula) Format - Annotated Version,  Pre-Draft 12. Organization for the Advancement of Structured Information  Standards (OASIS). Billerica, MA, USA. [ODT Document].  Available:  <a href="http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula">http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula</a>  OpenDocument-formula-20090508.odt</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>What is the present value (e.g., the initial investment) of an investment that needs to total $15692.93 after 10 years of saving $100 every month? Assume the interest rate is 5% (annually) compounded monthly.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.pv(0.05/12, 10*12, -100, 15692.93) -100.00067131625819</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>By convention, the negative sign represents cash flow out (i.e., money not available today). Thus, to end up with $15,692.93 in 10 years saving $100 a month at 5% annual interest, ones initial deposit should also be $100.</p>
<p>If any input is array_like, <code>pv</code> returns an array of equal shape. Lets compare different interest rates in the example above:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array((0.05, 0.04, 0.03))/12 np.pv(a, 10*12, -100, 15692.93) array([ -100.00067132, -649.26771385, -1273.78633713]) # may vary</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>So, to end up with the same $15692.93 under the same $100 per month savings plan, for annual interest rates of 4% and 3%, one would need initial investments of $649.27 and $1273.79, respectively.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L27207">view source</a></div></div><div class="public anchor" id="var-PZERO"><h3>PZERO</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L9544">view source</a></div></div><div class="public anchor" id="var-quantile"><h3>quantile</h3><div class="usage"><code>(quantile &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Compute the q-th quantile of the data along the specified axis.</p>
<p>.. versionadded:: 1.15.0</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input array or object that can be converted to an array. q : array_like of float  Quantile or sequence of quantiles to compute, which must be between  0 and 1 inclusive. axis : {int, tuple of int, None}, optional  Axis or axes along which the quantiles are computed. The  default is to compute the quantile(s) along a flattened  version of the array. out : ndarray, optional  Alternative output array in which to place the result. It must  have the same shape and buffer length as the expected output,  but the type (of the output) will be cast if necessary. overwrite_input : bool, optional  If True, then allow the input array <code>a</code> to be modified by intermediate  calculations, to save memory. In this case, the contents of the input  <code>a</code> after this function completes is undefined. interpolation : {linear, lower, higher, midpoint, nearest}  This optional parameter specifies the interpolation method to  use when the desired quantile lies between two data points  <code>i &lt; j</code>:</p>
<pre><code>    * linear: ``i + (j - i) * fraction``, where ``fraction``
      is the fractional part of the index surrounded by ``i``
      and ``j``.
    * lower: ``i``.
    * higher: ``j``.
    * nearest: ``i`` or ``j``, whichever is nearest.
    * midpoint: ``(i + j) / 2``.
</code></pre>
<p>keepdims : bool, optional  If this is set to True, the axes which are reduced are left in  the result as dimensions with size one. With this option, the  result will broadcast correctly against the original array <code>a</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>quantile : scalar or ndarray  If <code>q</code> is a single quantile and <code>axis=None</code>, then the result  is a scalar. If multiple quantiles are given, first axis of  the result corresponds to the quantiles. The other axes are  the axes that remain after the reduction of <code>a</code>. If the input  contains integers or floats smaller than <code>float64</code>, the output  data-type is <code>float64</code>. Otherwise, the output data-type is the  same as that of the input. If <code>out</code> is specified, that array is  returned instead.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>mean percentile : equivalent to quantile, but with q in the range [0, 100]. median : equivalent to <code>quantile(..., 0.5)</code> nanquantile</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Given a vector <code>V</code> of length <code>N</code>, the q-th quantile of <code>V</code> is the value <code>q</code> of the way from the minimum to the maximum in a sorted copy of <code>V</code>. The values and distances of the two nearest neighbors as well as the <code>interpolation</code> parameter will determine the quantile if the normalized ranking does not match the location of <code>q</code> exactly. This function is the same as the median if <code>q=0.5</code>, the same as the minimum if <code>q=0.0</code> and the same as the maximum if <code>q=1.0</code>.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array(<a href="null">10, 7, 4], [3, 2, 1</a>) a array(<a href="null">10,  7,  4],
       [ 3,  2,  1</a>) np.quantile(a, 0.5) 3.5 np.quantile(a, 0.5, axis=0) array([6.5, 4.5, 2.5]) np.quantile(a, 0.5, axis=1) array([7., 2.]) np.quantile(a, 0.5, axis=1, keepdims=True) array(<a href="null">7.],
       [2.</a>) m = np.quantile(a, 0.5, axis=0) out = np.zeros_like(m) np.quantile(a, 0.5, axis=0, out=out) array([6.5, 4.5, 2.5]) m array([6.5, 4.5, 2.5]) b = a.copy() np.quantile(b, 0.5, axis=1, overwrite_input=True) array([7., 2.]) assert not np.all(a == b)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L12254">view source</a></div></div><div class="public anchor" id="var-r_"><h3>r_</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Translates slice objects to concatenation along the first axis.</p>
<p>This is a simple way to build up arrays quickly. There are two use cases.</p>
<ol>
  <li>If the index expression contains comma separated arrays, then stack  them along their first axis.</li>
  <li>If the index expression contains slice notation or scalars then create  a 1-D array with a range indicated by the slice notation.</li>
</ol>
<p>If slice notation is used, the syntax <code>start:stop:step</code> is equivalent to <code>np.arange(start, stop, step)</code> inside of the brackets. However, if <code>step</code> is an imaginary number (i.e. 100j) then its integer portion is interpreted as a number-of-points desired and the start and stop are inclusive. In other words <code>start:stop:stepj</code> is interpreted as <code>np.linspace(start, stop, step, endpoint=1)</code> inside of the brackets. After expansion of slice notation, all comma separated sequences are concatenated together.</p>
<p>Optional character strings placed as the first element of the index expression can be used to change the output. The strings r or c result in matrix output. If the result is 1-D and r is specified a 1 x N (row) matrix is produced. If the result is 1-D and c is specified, then a N x 1 (column) matrix is produced. If the result is 2-D then both provide the same matrix result.</p>
<p>A string integer specifies which axis to stack multiple comma separated arrays along. A string of two comma-separated integers allows indication of the minimum number of dimensions to force each entry into as the second integer (the axis to concatenate along is still the first integer).</p>
<p>A string with three comma-separated integers allows specification of the axis to concatenate along, the minimum number of dimensions to force the entries to, and which axis should contain the start of the arrays which are less than the specified number of dimensions. In other words the third integer allows you to specify where the 1s should be placed in the shape of the arrays that have their shapes upgraded. By default, they are placed in the front of the shape tuple. The third argument allows you to specify where the start of the array should be instead. Thus, a third argument of 0 would place the 1s at the end of the array shape. Negative integers specify where in the new shape tuple the last dimension of upgraded arrays should be placed, so the default is -1.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>Not a function, so takes no parameters</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>A concatenated ndarray or matrix.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>concatenate : Join a sequence of arrays along an existing axis. c_ : Translates slice objects to concatenation along the second axis.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.r_[np.array([1,2,3]), 0, 0, np.array([4,5,6])] array([1, 2, 3, , 4, 5, 6]) np.r_[-1:1:6j, [0]*3, 5, 6] array([-1. , -0.6, -0.2, 0.2, 0.6, 1. , 0. , 0. , 0. , 5. , 6. ])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>String integers specify the axis to concatenate along or the minimum number of dimensions to force entries into.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array(<a href="null">0, 1, 2], [3, 4, 5</a>) np.r_[-1, a, a] # concatenate along last axis array(<a href="null">0, 1, 2, 0, 1, 2],
       [3, 4, 5, 3, 4, 5</a>) np.r_[0,2, [1,2,3], [4,5,6]] # concatenate along first axis, dim&gt;=2 array(<a href="null">1, 2, 3],
       [4, 5, 6</a>)</p>
      <p>np.r_[0,2,0, [1,2,3], [4,5,6]] array(<a href="null">1],
       [2],
       [3],
       [4],
       [5],
       [6</a>) np.r_[1,2,0, [1,2,3], [4,5,6]] array(<a href="null">1, 4],
       [2, 5],
       [3, 6</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Using r or c as a first string argument creates a matrix.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.r_[r,[1,2,3], [4,5,6]] matrix(<a href="null">1, 2, 3, 4, 5, 6</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L2615">view source</a></div></div><div class="public anchor" id="var-rad2deg"><h3>rad2deg</h3><div class="usage"><code>(rad2deg self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>rad2deg(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Convert angles from radians to degrees.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Angle in radians. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray  The corresponding angle in degrees.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>deg2rad : Convert angles from degrees to radians. unwrap : Remove large jumps in angle by wrapping.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>.. versionadded:: 1.3.0</p>
<p>rad2deg(x) is <code>180 * x / pi</code>.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.rad2deg(np.pi/2) 90.0</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L6268">view source</a></div></div><div class="public anchor" id="var-radians"><h3>radians</h3><div class="usage"><code>(radians self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>radians(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Convert angles from degrees to radians.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Input array in degrees. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray  The corresponding radian values.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>deg2rad : equivalent function</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>Convert a degree array to radians</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>deg = np.arange(12.) * 30. np.radians(deg) array([ 0. , 0.52359878, 1.04719755, 1.57079633, 2.0943951 ,  2.61799388, 3.14159265, 3.66519143, 4.1887902 , 4.71238898,  5.23598776, 5.75958653])</p>
      <p>out = np.zeros((deg.shape)) ret = np.radians(deg, out) ret is out True</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L15574">view source</a></div></div><div class="public anchor" id="var-RAISE"><h3>RAISE</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L8772">view source</a></div></div><div class="public anchor" id="var-random"><h3>random</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>========================</p>
<h1><a href="#random-number-generation" name="random-number-generation"></a>Random Number Generation</h1>
<p>Use <code>default_rng()</code> to create a <code>Generator</code> and call its methods.</p>
<p>=============== ========================================================= Generator   Generator Class implementing all of the random number distributions default_rng Default constructor for <code>Generator</code> =============== =========================================================</p>
<p>============================================= === BitGenerator Streams that work with Generator   MT19937 PCG64 Philox SFC64 ============================================= ===</p>
<p>============================================= === Getting entropy to initialize a BitGenerator   SeedSequence ============================================= ===</p>
<h2><a href="#legacy" name="legacy"></a>Legacy</h2>
<p>For backwards compatibility with previous versions of numpy before 1.17, the various aliases to the global <code>RandomState</code> methods are left alone and do not use the new <code>Generator</code> API.</p>
<p>==================== ========================================================= Utility functions   random Uniformly distributed floats over <code>[0, 1)</code> bytes Uniformly distributed random bytes. permutation Randomly permute a sequence / generate a random sequence. shuffle Randomly permute a sequence in place. choice Random sample from 1-D array. ==================== =========================================================</p>
<p>==================== ========================================================= Compatibility functions - removed in the new API   rand Uniformly distributed values. randn Normally distributed values. ranf Uniformly distributed floating point numbers. random_integers Uniformly distributed integers in a given range.  (deprecated, use <code>integers(..., closed=True)</code> instead) random_sample Alias for <code>random_sample</code> randint Uniformly distributed integers in a given range seed Seed the legacy random number generator. ==================== =========================================================</p>
<p>==================== ========================================================= Univariate distributions   beta Beta distribution over <code>[0, 1]</code>. binomial Binomial distribution. chisquare :math:<code>\chi^2</code> distribution. exponential Exponential distribution. f F (Fisher-Snedecor) distribution. gamma Gamma distribution. geometric Geometric distribution. gumbel Gumbel distribution. hypergeometric Hypergeometric distribution. laplace Laplace distribution. logistic Logistic distribution. lognormal Log-normal distribution. logseries Logarithmic series distribution. negative_binomial Negative binomial distribution. noncentral_chisquare Non-central chi-square distribution. noncentral_f Non-central F distribution. normal Normal / Gaussian distribution. pareto Pareto distribution. poisson Poisson distribution. power Power distribution. rayleigh Rayleigh distribution. triangular Triangular distribution. uniform Uniform distribution. vonmises Von Mises circular distribution. wald Wald (inverse Gaussian) distribution. weibull Weibull distribution. zipf Zipfs distribution over ranked data. ==================== =========================================================</p>
<p>==================== ========================================================== Multivariate distributions  - dirichlet Multivariate generalization of Beta distribution. multinomial Multivariate generalization of the binomial distribution. multivariate_normal Multivariate generalization of the normal distribution. ==================== ==========================================================</p>
<p>==================== ========================================================= Standard distributions   standard_cauchy Standard Cauchy-Lorentz distribution. standard_exponential Standard exponential distribution. standard_gamma Standard Gamma distribution. standard_normal Standard normal distribution. standard_t Standard Students t-distribution. ==================== =========================================================</p>
<p>==================== ========================================================= Internal functions   get_state Get tuple representing internal state of generator. set_state Set state of generator. ==================== =========================================================</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L1248">view source</a></div></div><div class="public anchor" id="var-RankWarning"><h3>RankWarning</h3><div class="usage"><code>(RankWarning self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Issued by <code>polyfit</code> when the Vandermonde matrix is rank deficient.</p>
<p>For more information, a way to suppress the warning, and an example of <code>RankWarning</code> being issued, see <code>polyfit</code>.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L2544">view source</a></div></div><div class="public anchor" id="var-rate"><h3>rate</h3><div class="usage"><code>(rate &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Compute the rate of interest per period.</p>
<p>.. deprecated:: 1.18</p>
<p><code>rate</code> is deprecated; for details, see NEP 32 [1]_.  Use the corresponding function in the numpy-financial library,  <a href="https://pypi.org/project/numpy-financial">https://pypi.org/project/numpy-financial</a>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>nper : array_like  Number of compounding periods pmt : array_like  Payment pv : array_like  Present value fv : array_like  Future value when : {{begin, 1}, {end, 0}}, {string, int}, optional  When payments are due (begin (1) or end (0)) guess : Number, optional  Starting guess for solving the rate of interest, default 0.1 tol : Number, optional  Required tolerance for the solution, default 1e-6 maxiter : int, optional  Maximum iterations in finding the solution</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The rate of interest is computed by iteratively solving the (non-linear) equation::</p>
<p>fv + pv*(1+rate)**nper + pmt*(1+rate*when)/rate * ((1+rate)**nper - 1) = 0</p>
<p>for <code>rate</code>.</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [1] NumPy Enhancement Proposal (NEP) 32,  <a href="https://numpy.org/neps/nep-0032-remove-financial-functions.html">https://numpy.org/neps/nep-0032-remove-financial-functions.html</a> .. [2] Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May).  Open Document Format for Office Applications (OpenDocument)v1.2,  Part 2: Recalculated Formula (OpenFormula) Format - Annotated Version,  Pre-Draft 12. Organization for the Advancement of Structured Information  Standards (OASIS). Billerica, MA, USA. [ODT Document].  Available:  <a href="http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula">http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula</a>  OpenDocument-formula-20090508.odt</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L15098">view source</a></div></div><div class="public anchor" id="var-ravel"><h3>ravel</h3><div class="usage"><code>(ravel &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return a contiguous flattened array.</p>
<p>A 1-D array, containing the elements of the input, is returned. A copy is made only if needed.</p>
<p>As of NumPy 1.10, the returned array will have the same type as the input array. (for example, a masked array will be returned for a masked array input)</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input array. The elements in <code>a</code> are read in the order specified by  <code>order</code>, and packed as a 1-D array. order : {C,F, A, K}, optional</p>
<pre><code>The elements of `a` are read using this index order. 'C' means
to index the elements in row-major, C-style order,
with the last axis index changing fastest, back to the first
axis index changing slowest.  'F' means to index the elements
in column-major, Fortran-style order, with the
first index changing fastest, and the last index changing
slowest. Note that the 'C' and 'F' options take no account of
the memory layout of the underlying array, and only refer to
the order of axis indexing.  'A' means to read the elements in
Fortran-like index order if `a` is Fortran *contiguous* in
memory, C-like order otherwise.  'K' means to read the
elements in the order they occur in memory, except for
reversing the data when strides are negative.  By default, 'C'
index order is used.
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : array_like  y is an array of the same subtype as <code>a</code>, with shape <code>(a.size,)</code>.  Note that matrices are special cased for backward compatibility, if <code>a</code>  is a matrix, then y is a 1-D ndarray.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>ndarray.flat : 1-D iterator over an array. ndarray.flatten : 1-D array copy of the elements of an array  in row-major order. ndarray.reshape : Change the shape of an array without changing its data.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>In row-major, C-style order, in two dimensions, the row index varies the slowest, and the column index the quickest. This can be generalized to multiple dimensions, where row-major order implies that the index along the first axis varies slowest, and the index along the last quickest. The opposite holds for column-major, Fortran-style index ordering.</p>
<p>When a view is desired in as many cases as possible, <code>arr.reshape(-1)</code> may be preferable.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>It is equivalent to <code>reshape(-1, order=order)</code>.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.array(<a href="null">1, 2, 3], [4, 5, 6</a>) np.ravel(x) array([1, 2, 3, 4, 5, 6])</p>
      <p>x.reshape(-1) array([1, 2, 3, 4, 5, 6])</p>
      <p>np.ravel(x, order=F) array([1, 4, 2, 5, 3, 6])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>When <code>order</code> is A, it will preserve the arrays C or F ordering:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.ravel(x.T) array([1, 4, 2, 5, 3, 6]) np.ravel(x.T, order=A) array([1, 2, 3, 4, 5, 6])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>When <code>order</code> is K, it will preserve orderings that are neither C nor F, but wont reverse axes:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.arange(3)[::-1]; a array([2, 1, 0]) a.ravel(order=C) array([2, 1, 0]) a.ravel(order=K) array([2, 1, 0])</p>
      <p>a = np.arange(12).reshape(2,3,2).swapaxes(1,2); a array(<a href="null">[ 0,  2,  4],
        [ 1,  3,  5</a>,  <a href="null"> 6,  8, 10],
        [ 7,  9, 11</a>]) a.ravel(order=C) array([ 0, 2, 4, 1, 3, 5, 6, 8, 10, 7, 9, 11]) a.ravel(order=K) array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L17704">view source</a></div></div><div class="public anchor" id="var-ravel_multi_index"><h3>ravel_multi_index</h3><div class="usage"><code>(ravel_multi_index &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>ravel_multi_index(multi_index, dims, mode=raise, order=C)</p>
<p>Converts a tuple of index arrays into an array of flat indices, applying boundary modes to the multi-index.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>multi_index : tuple of array_like  A tuple of integer arrays, one array for each dimension. dims : tuple of ints  The shape of array into which the indices from <code>multi_index</code> apply. mode : {raise, wrap, clip}, optional  Specifies how out-of-bounds indices are handled. Can specify  either one mode or a tuple of modes, one mode per index.</p>
<pre><code>* 'raise' -- raise an error (default)
* 'wrap' -- wrap around
* 'clip' -- clip to the range

In 'clip' mode, a negative index which would normally
wrap will clip to 0 instead.
</code></pre>
<p>order : {C, F}, optional  Determines whether the multi-index should be viewed as  indexing in row-major (C-style) or column-major  (Fortran-style) order.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>raveled_indices : ndarray  An array of indices into the flattened version of an array  of dimensions <code>dims</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>unravel_index</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>.. versionadded:: 1.6.0</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>arr = np.array(<a href="null">3,6,6],[4,5,1</a>) np.ravel_multi_index(arr, (7,6)) array([22, 41, 37]) np.ravel_multi_index(arr, (7,6), order=F) array([31, 41, 13]) np.ravel_multi_index(arr, (4,6), mode=clip) array([22, 23, 19]) np.ravel_multi_index(arr, (4,4), mode=(clip,wrap)) array([12, 13, 13])</p>
      <p>np.ravel_multi_index((3,1,4,1), (6,7,8,9)) 1621</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L82">view source</a></div></div><div class="public anchor" id="var-real"><h3>real</h3><div class="usage"><code>(real &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return the real part of the complex argument.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>val : array_like  Input array.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray or scalar  The real component of the complex argument. If <code>val</code> is real, the type  of <code>val</code> is used for the output. If <code>val</code> has complex elements, the  returned type is float.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>real_if_close, imag, angle</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array([1+2j, 3+4j, 5+6j]) a.real array([1., 3., 5.]) a.real = 9 a array([9.+2.j, 9.+4.j, 9.+6.j]) a.real = np.array([9, 8, 7]) a array([9.+2.j, 8.+4.j, 7.+6.j]) np.real(1 + 1j) 1.0</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L15246">view source</a></div></div><div class="public anchor" id="var-real_if_close"><h3>real_if_close</h3><div class="usage"><code>(real_if_close &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>If complex input returns a real array if complex parts are close to zero.</p>
<p>Close to zero is defined as <code>tol</code> * (machine epsilon of the type for <code>a</code>).</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input array. tol : float  Tolerance in machine epsilons for the complex part of the elements  in the array.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  If <code>a</code> is real, the type of <code>a</code> is used for the output. If <code>a</code>  has complex elements, the returned type is float.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>real, imag, angle</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Machine epsilon varies from machine to machine and between data types but Python floats on most platforms have a machine epsilon equal to 2.2204460492503131e-16. You can use np.finfo(float).eps to print out the machine epsilon for floats.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.finfo(float).eps 2.2204460492503131e-16 # may vary</p>
      <p>np.real_if_close([2.1 + 4e-14j], tol=1000) array([2.1]) np.real_if_close([2.1 + 4e-13j], tol=1000) array([2.1+4.e-13j])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L6318">view source</a></div></div><div class="public anchor" id="var-rec"><h3>rec</h3><div class="usage"></div><div class="doc"><div class="markdown"><h1><a href="#record-arrays" name="record-arrays"></a>Record Arrays</h1>
<p>Record arrays expose the fields of structured arrays as properties.</p>
<p>Most commonly, ndarrays contain elements of a single type, e.g. floats, integers, bools etc. However, it is possible for elements to be combinations of these using structured types, such as::</p>
<p>&gt;&gt;&gt; a = np.array([(1, 2.0), (1, 2.0)], dtype=[(x, np.int64), (y, np.float64)])  &gt;&gt;&gt; a  array([(1, 2.), (1, 2.)], dtype=[(x, &lt;i8), (y, &lt;f8)])</p>
<p>Here, each element consists of two fields: x (and int), and y (a float). This is known as a structured array. The different fields are analogous to columns in a spread-sheet. The different fields can be accessed as one would a dictionary::</p>
<p>&gt;&gt;&gt; a[x]  array([1, 1])</p>
<p>&gt;&gt;&gt; a[y]  array([2., 2.])</p>
<p>Record arrays allow us to access fields as properties::</p>
<p>&gt;&gt;&gt; ar = np.rec.array(a)</p>
<p>&gt;&gt;&gt; ar.x  array([1, 1])</p>
<p>&gt;&gt;&gt; ar.y  array([2., 2.])</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L25729">view source</a></div></div><div class="public anchor" id="var-recarray"><h3>recarray</h3><div class="usage"><code>(recarray self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Construct an ndarray that allows field access using attributes.</p>
<p>Arrays may have a data-types containing fields, analogous to columns in a spread sheet. An example is <code>[(x, int), (y, float)]</code>, where each entry in the array is a pair of <code>(int, float)</code>. Normally, these attributes are accessed using dictionary lookups such as <code>arr['x']</code> and <code>arr['y']</code>. Record arrays allow the fields to be accessed as members of the array, using <code>arr.x</code> and <code>arr.y</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>shape : tuple  Shape of output array. dtype : data-type, optional  The desired data-type. By default, the data-type is determined  from <code>formats</code>, <code>names</code>, <code>titles</code>, <code>aligned</code> and <code>byteorder</code>. formats : list of data-types, optional  A list containing the data-types for the different columns, e.g.  <code>['i4', 'f8', 'i4']</code>. <code>formats</code> does <em>not</em> support the new  convention of using types directly, i.e. <code>(int, float, int)</code>.  Note that <code>formats</code> must be a list, not a tuple.  Given that <code>formats</code> is somewhat limited, we recommend specifying  <code>dtype</code> instead. names : tuple of str, optional  The name of each column, e.g. <code>('x', 'y', 'z')</code>. buf : buffer, optional  By default, a new array is created of the given shape and data-type.  If <code>buf</code> is specified and is an object exposing the buffer interface,  the array will use the memory from the existing buffer. In this case,  the <code>offset</code> and <code>strides</code> keywords are available.</p>
<h2><a href="#other-parameters" name="other-parameters"></a>Other Parameters</h2>
<p>titles : tuple of str, optional  Aliases for column names. For example, if <code>names</code> were  <code>('x', 'y', 'z')</code> and <code>titles</code> is  <code>('x_coordinate', 'y_coordinate', 'z_coordinate')</code>, then  <code>arr['x']</code> is equivalent to both <code>arr.x</code> and <code>arr.x_coordinate</code>. byteorder : {&lt;, &gt;, =}, optional  Byte-order for all fields. aligned : bool, optional  Align the fields in memory as the C-compiler would. strides : tuple of ints, optional  Buffer (<code>buf</code>) is interpreted according to these strides (strides  define how many bytes each array element, row, column, etc.  occupy in memory). offset : int, optional  Start reading buffer (<code>buf</code>) from this offset onwards. order : {C, F}, optional  Row-major (C-style) or column-major (Fortran-style) order.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>rec : recarray  Empty array of the given shape and type.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>rec.fromrecords : Construct a record array from data. record : fundamental data-type for <code>recarray</code>. format_parser : determine a data-type from formats, names, titles.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>This constructor can be compared to <code>empty</code>: it creates a new record array but does not fill it with data. To create a record array from data, use one of the following methods:</p>
<ol>
  <li>Create a standard ndarray and convert it to a record array,  using <code>arr.view(np.recarray)</code></li>
  <li>Use the <code>buf</code> keyword.</li>
  <li>Use <code>np.rec.fromrecords</code>.</li>
</ol>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>Create an array with two fields, <code>x</code> and <code>y</code>:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.array([(1.0, 2), (3.0, 4)], dtype=[(x, &lt;f8), (y, &lt;i8)]) x array([(1., 2), (3., 4)], dtype=[(x, &lt;f8), (y, &lt;i8)])</p>
      <p>x[x] array([1., 3.])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>View the array as a record array:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = x.view(np.recarray)</p>
      <p>x.x array([1., 3.])</p>
      <p>x.y array([2, 4])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Create a new, empty record array:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.recarray((2,),  dtype=[(x, int), (y, float), (z, int)]) #doctest: +SKIP rec.array([(-1073741821, 1.2249118382103472e-301, 24547520),  (3471280, 1.2134086255804012e-316, 0)],  dtype=[(x, &lt;i4), (y, &lt;f8), (z, &lt;i4)])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L19072">view source</a></div></div><div class="public anchor" id="var-recfromcsv"><h3>recfromcsv</h3><div class="usage"><code>(recfromcsv fname &amp; [{:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Load ASCII data stored in a comma-separated file.</p>
<p>The returned array is a record array (if <code>usemask=False</code>, see <code>recarray</code>) or a masked record array (if <code>usemask=True</code>, see <code>ma.mrecords.MaskedRecords</code>).</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>fname, kwargs : For a description of input parameters, see <code>genfromtxt</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>numpy.genfromtxt : generic function to load ASCII data.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>By default, <code>dtype</code> is None, which means that the data-type of the output array will be determined from the data.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L358">view source</a></div></div><div class="public anchor" id="var-recfromtxt"><h3>recfromtxt</h3><div class="usage"><code>(recfromtxt fname &amp; [{:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Load ASCII data from a file and return it in a record array.</p>
<p>If <code>usemask=False</code> a standard <code>recarray</code> is returned, if <code>usemask=True</code> a MaskedRecords array is returned.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>fname, kwargs : For a description of input parameters, see <code>genfromtxt</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>numpy.genfromtxt : generic function</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>By default, <code>dtype</code> is None, which means that the data-type of the output array will be determined from the data.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L17307">view source</a></div></div><div class="public anchor" id="var-reciprocal"><h3>reciprocal</h3><div class="usage"><code>(reciprocal self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>reciprocal(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Return the reciprocal of the argument, element-wise.</p>
<p>Calculates <code>1/x</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Input array. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray  Return array.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>.. note::  This function is not designed to work with integers.</p>
<p>For integer arguments with absolute value larger than 1 the result is always zero because of the way Python handles integer division. For integer zero the result is an overflow.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.reciprocal(2.) 0.5 np.reciprocal([1, 2., 3.33]) array([ 1. , 0.5 , 0.3003003])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L10308">view source</a></div></div><div class="public anchor" id="var-record"><h3>record</h3><div class="usage"><code>(record self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>A data-type scalar that allows field access as attribute lookup.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L6495">view source</a></div></div><div class="public anchor" id="var-remainder"><h3>remainder</h3><div class="usage"><code>(remainder self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>remainder(x1, x2, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Return element-wise remainder of division.</p>
<p>Computes the remainder complementary to the <code>floor_divide</code> function. It is equivalent to the Python modulus operator<code>x1 % x2</code> and has the same sign as the divisor <code>x2</code>. The MATLAB function equivalent to <code>np.remainder</code> is <code>mod</code>.</p>
<p>.. warning::</p>
<pre><code>This should not be confused with:

* Python 3.7's `math.remainder` and C's ``remainder``, which
  computes the IEEE remainder, which are the complement to
  ``round(x1 / x2)``.
* The MATLAB ``rem`` function and or the C ``%`` operator which is the
  complement to ``int(x1 / x2)``.
</code></pre>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x1 : array_like  Dividend array. x2 : array_like  Divisor array. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output). out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray  The element-wise remainder of the quotient <code>floor_divide(x1, x2)</code>.  This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>floor_divide : Equivalent of Python <code>//</code> operator. divmod : Simultaneous floor division and remainder. fmod : Equivalent of the MATLAB <code>rem</code> function. divide, floor</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Returns 0 when <code>x2</code> is 0 and both <code>x1</code> and <code>x2</code> are (arrays of) integers. <code>mod</code> is an alias of <code>remainder</code>.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.remainder([4, 7], [2, 3]) array([0, 1]) np.remainder(np.arange(7), 5) array([0, 1, 2, 3, 4, 0, 1])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L16398">view source</a></div></div><div class="public anchor" id="var-repeat"><h3>repeat</h3><div class="usage"><code>(repeat &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Repeat elements of an array.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input array. repeats : int or array of ints  The number of repetitions for each element. <code>repeats</code> is broadcasted  to fit the shape of the given axis. axis : int, optional  The axis along which to repeat values. By default, use the  flattened input array, and return a flat output array.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>repeated_array : ndarray  Output array which has the same shape as <code>a</code>, except along  the given axis.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>tile : Tile an array.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.repeat(3, 4) array([3, 3, 3, 3]) x = np.array(<a href="null">1,2],[3,4</a>) np.repeat(x, 2) array([1, 1, 2, 2, 3, 3, 4, 4]) np.repeat(x, 3, axis=1) array(<a href="null">1, 1, 1, 2, 2, 2],
       [3, 3, 3, 4, 4, 4</a>) np.repeat(x, [1, 2], axis=0) array(<a href="null">1, 2],
       [3, 4],
       [3, 4</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L8322">view source</a></div></div><div class="public anchor" id="var-require"><h3>require</h3><div class="usage"><code>(require a &amp; [{dtype :dtype, requirements :requirements}])</code><code>(require a &amp; [{dtype :dtype}])</code><code>(require a)</code></div><div class="doc"><div class="markdown"><p>Return an ndarray of the provided type that satisfies requirements.</p>
<p>This function is useful to be sure that an array with the correct flags is returned for passing to compiled code (perhaps through ctypes).</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  The object to be converted to a type-and-requirement-satisfying array. dtype : data-type  The required data-type. If None preserve the current dtype. If your  application requires the data to be in native byteorder, include  a byteorder specification as a part of the dtype specification. requirements : str or list of str  The requirements list can be any of the following</p>
<ul>
  <li>F_CONTIGUOUS (F) - ensure a Fortran-contiguous array</li>
  <li>C_CONTIGUOUS (C) - ensure a C-contiguous array</li>
  <li>ALIGNED (A) - ensure a data-type aligned array</li>
  <li>WRITEABLE (W) - ensure a writable array</li>
  <li>OWNDATA (O) - ensure an array that owns its own data</li>
  <li>ENSUREARRAY, (E) - ensure a base array, instead of a subclass</li>
</ul>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  Array with specified requirements and type if given.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>asarray : Convert input to an ndarray. asanyarray : Convert to an ndarray, but pass through ndarray subclasses. ascontiguousarray : Convert input to a contiguous array. asfortranarray : Convert input to an ndarray with column-major  memory order. ndarray.flags : Information about the memory layout of the array.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The returned array will be guaranteed to have the listed requirements by making a copy if needed.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.arange(6).reshape(2,3) x.flags  C_CONTIGUOUS : True  F_CONTIGUOUS : False  OWNDATA : False  WRITEABLE : True  ALIGNED : True  WRITEBACKIFCOPY : False  UPDATEIFCOPY : False</p>
      <p>y = np.require(x, dtype=np.float32, requirements=[A, O, W, F]) y.flags  C_CONTIGUOUS : False  F_CONTIGUOUS : True  OWNDATA : True  WRITEABLE : True  ALIGNED : True  WRITEBACKIFCOPY : False  UPDATEIFCOPY : False</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L10120">view source</a></div></div><div class="public anchor" id="var-reshape"><h3>reshape</h3><div class="usage"><code>(reshape &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Gives a new shape to an array without changing its data.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Array to be reshaped. newshape : int or tuple of ints  The new shape should be compatible with the original shape. If  an integer, then the result will be a 1-D array of that length.  One shape dimension can be -1. In this case, the value is  inferred from the length of the array and remaining dimensions. order : {C, F, A}, optional  Read the elements of <code>a</code> using this index order, and place the  elements into the reshaped array using this index order. C  means to read / write the elements using C-like index order,  with the last axis index changing fastest, back to the first  axis index changing slowest. F means to read / write the  elements using Fortran-like index order, with the first index  changing fastest, and the last index changing slowest. Note that  the C and F options take no account of the memory layout of  the underlying array, and only refer to the order of indexing.  A means to read / write the elements in Fortran-like index  order if <code>a</code> is Fortran <em>contiguous</em> in memory, C-like order  otherwise.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>reshaped_array : ndarray  This will be a new view object if possible; otherwise, it will  be a copy. Note there is no guarantee of the <em>memory layout</em> (C- or  Fortran- contiguous) of the returned array.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>ndarray.reshape : Equivalent method.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>It is not always possible to change the shape of an array without copying the data. If you want an error to be raised when the data is copied, you should assign the new shape to the shape attribute of the array::</p>
<p>&gt;&gt;&gt; a = np.zeros((10, 2))</p>
<p># A transpose makes the array non-contiguous  &gt;&gt;&gt; b = a.T</p>
<p># Taking a view makes it possible to modify the shape without modifying  # the initial object.  &gt;&gt;&gt; c = b.view()  &gt;&gt;&gt; c.shape = (20)  Traceback (most recent call last):    AttributeError: incompatible shape for a non-contiguous array</p>
<p>The <code>order</code> keyword gives the index ordering both for <em>fetching</em> the values from <code>a</code>, and then <em>placing</em> the values into the output array. For example, lets say you have an array:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.arange(6).reshape((3, 2)) a array(<a href="null">0, 1],
       [2, 3],
       [4, 5</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>You can think of reshaping as first raveling the array (using the given index order), then inserting the elements from the raveled array into the new array using the same kind of index ordering as was used for the raveling.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.reshape(a, (2, 3)) # C-like index ordering array(<a href="null">0, 1, 2],
       [3, 4, 5</a>) np.reshape(np.ravel(a), (2, 3)) # equivalent to C ravel then C reshape array(<a href="null">0, 1, 2],
       [3, 4, 5</a>) np.reshape(a, (2, 3), order=F) # Fortran-like index ordering array(<a href="null">0, 4, 3],
       [2, 1, 5</a>) np.reshape(np.ravel(a, order=F), (2, 3), order=F) array(<a href="null">0, 4, 3],
       [2, 1, 5</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array(<a href="null">1,2,3], [4,5,6</a>) np.reshape(a, 6) array([1, 2, 3, 4, 5, 6]) np.reshape(a, 6, order=F) array([1, 4, 2, 5, 3, 6])</p>
      <p>np.reshape(a, (3,-1)) # the unspecified value is inferred to be 2 array(<a href="null">1, 2],
       [3, 4],
       [5, 6</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L13851">view source</a></div></div><div class="public anchor" id="var-resize"><h3>resize</h3><div class="usage"><code>(resize &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return a new array with the specified shape.</p>
<p>If the new array is larger than the original array, then the new array is filled with repeated copies of <code>a</code>. Note that this behavior is different from a.resize(new_shape) which fills with zeros instead of repeated copies of <code>a</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Array to be resized.</p>
<p>new_shape : int or tuple of int  Shape of resized array.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>reshaped_array : ndarray  The new array is formed from the data in the old array, repeated  if necessary to fill out the required number of elements. The  data are repeated in the order that they are stored in memory.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>ndarray.resize : resize an array in-place.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Warning: This functionality does <strong>not</strong> consider axes separately, i.e. it does not apply interpolation/extrapolation. It fills the return array with the required number of elements, taken from <code>a</code> as they are laid out in memory, disregarding strides and axes. (This is in case the new shape is smaller. For larger, see above.) This functionality is therefore not suitable to resize images, or data where each axis represents a separate and distinct entity.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a=np.array(<a href="null">0,1],[2,3</a>) np.resize(a,(2,3)) array(<a href="null">0, 1, 2],
       [3, 0, 1</a>) np.resize(a,(1,4)) array(<a href="null">0, 1, 2, 3</a>) np.resize(a,(2,4)) array(<a href="null">0, 1, 2, 3],
       [0, 1, 2, 3</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L23725">view source</a></div></div><div class="public anchor" id="var-result_type"><h3>result_type</h3><div class="usage"><code>(result_type &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>result_type(*arrays_and_dtypes)</p>
<p>Returns the type that results from applying the NumPy type promotion rules to the arguments.</p>
<p>Type promotion in NumPy works similarly to the rules in languages like C++, with some slight differences. When both scalars and arrays are used, the arrays type takes precedence and the actual value of the scalar is taken into account.</p>
<p>For example, calculating 3*a, where a is an array of 32-bit floats, intuitively should result in a 32-bit float output. If the 3 is a 32-bit integer, the NumPy rules indicate it cant convert losslessly into a 32-bit float, so a 64-bit float should be the result type. By examining the value of the constant, 3, we see that it fits in an 8-bit integer, which can be cast losslessly into the 32-bit float.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>arrays_and_dtypes : list of arrays and dtypes  The operands of some operation whose result type is needed.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : dtype  The result type.</p>
<h2><a href="#see-also" name="see-also"></a>See also</h2>
<p>dtype, promote_types, min_scalar_type, can_cast</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>.. versionadded:: 1.6.0</p>
<p>The specific algorithm used is as follows.</p>
<p>Categories are determined by first checking which of boolean, integer (int/uint), or floating point (float/complex) the maximum kind of all the arrays and the scalars are.</p>
<p>If there are only scalars or the maximum category of the scalars is higher than the maximum category of the arrays, the data types are combined with :func:<code>promote_types</code> to produce the return value.</p>
<p>Otherwise, <code>min_scalar_type</code> is called on each array, and the resulting data types are all combined with :func:<code>promote_types</code> to produce the return value.</p>
<p>The set of int values is not a subset of the uint values for types with the same number of bits, something not reflected in :func:<code>min_scalar_type</code>, but handled as a special case in <code>result_type</code>.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.result_type(3, np.arange(7, dtype=i1)) dtype(int8)</p>
      <p>np.result_type(i4, c8) dtype(complex128)</p>
      <p>np.result_type(3.0, -2) dtype(float64)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L10">view source</a></div></div><div class="public anchor" id="var-right_shift"><h3>right_shift</h3><div class="usage"><code>(right_shift self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>right_shift(x1, x2, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Shift the bits of an integer to the right.</p>
<p>Bits are shifted to the right <code>x2</code>. Because the internal representation of numbers is in binary format, this operation is equivalent to dividing <code>x1</code> by <code>2**x2</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x1 : array_like, int  Input values. x2 : array_like, int  Number of bits to remove at the right of <code>x1</code>. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output). out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray, int  Return <code>x1</code> with bits shifted <code>x2</code> times to the right.  This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>left_shift : Shift the bits of an integer to the left. binary_repr : Return the binary representation of the input number  as a string.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.binary_repr(10) 1010 np.right_shift(10, 1) 5 np.binary_repr(5) 101</p>
      <p>np.right_shift(10, [1,2,3]) array([5, 2, 1])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L27978">view source</a></div></div><div class="public anchor" id="var-rint"><h3>rint</h3><div class="usage"><code>(rint self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>rint(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Round elements of the array to the nearest integer.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Input array. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray or scalar  Output array is same shape and type as <code>x</code>.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>ceil, floor, trunc</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0]) np.rint(a) array([-2., -2., -0., 0., 2., 2., 2.])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L28388">view source</a></div></div><div class="public anchor" id="var-roll"><h3>roll</h3><div class="usage"><code>(roll &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Roll array elements along a given axis.</p>
<p>Elements that roll beyond the last position are re-introduced at the first.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input array. shift : int or tuple of ints  The number of places by which elements are shifted. If a tuple,  then <code>axis</code> must be a tuple of the same size, and each of the  given axes is shifted by the corresponding number. If an int  while <code>axis</code> is a tuple of ints, then the same value is used for  all given axes. axis : int or tuple of ints, optional  Axis or axes along which elements are shifted. By default, the  array is flattened before shifting, after which the original  shape is restored.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>res : ndarray  Output array, with the same shape as <code>a</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>rollaxis : Roll the specified axis backwards, until it lies in a  given position.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>.. versionadded:: 1.12.0</p>
<p>Supports rolling over multiple dimensions simultaneously.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.arange(10) np.roll(x, 2) array([8, 9, 0, 1, 2, 3, 4, 5, 6, 7]) np.roll(x, -2) array([2, 3, 4, 5, 6, 7, 8, 9, 0, 1])</p>
      <p>x2 = np.reshape(x, (2,5)) x2 array(<a href="null">0, 1, 2, 3, 4],
       [5, 6, 7, 8, 9</a>) np.roll(x2, 1) array(<a href="null">9, 0, 1, 2, 3],
       [4, 5, 6, 7, 8</a>) np.roll(x2, -1) array(<a href="null">1, 2, 3, 4, 5],
       [6, 7, 8, 9, 0</a>) np.roll(x2, 1, axis=0) array(<a href="null">5, 6, 7, 8, 9],
       [0, 1, 2, 3, 4</a>) np.roll(x2, -1, axis=0) array(<a href="null">5, 6, 7, 8, 9],
       [0, 1, 2, 3, 4</a>) np.roll(x2, 1, axis=1) array(<a href="null">4, 0, 1, 2, 3],
       [9, 5, 6, 7, 8</a>) np.roll(x2, -1, axis=1) array(<a href="null">1, 2, 3, 4, 0],
       [6, 7, 8, 9, 5</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L22212">view source</a></div></div><div class="public anchor" id="var-rollaxis"><h3>rollaxis</h3><div class="usage"><code>(rollaxis &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Roll the specified axis backwards, until it lies in a given position.</p>
<p>This function continues to be supported for backward compatibility, but you should prefer <code>moveaxis</code>. The <code>moveaxis</code> function was added in NumPy 1.11.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : ndarray  Input array. axis : int  The axis to roll backwards. The positions of the other axes do not  change relative to one another. start : int, optional  The axis is rolled until it lies before this position. The default,  0, results in a complete roll.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>res : ndarray  For NumPy &gt;= 1.10.0 a view of <code>a</code> is always returned. For earlier  NumPy versions a view of <code>a</code> is returned only if the order of the  axes is changed, otherwise the input array is returned.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>moveaxis : Move array axes to new positions. roll : Roll the elements of an array by a number of positions along a  given axis.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.ones((3,4,5,6)) np.rollaxis(a, 3, 1).shape (3, 6, 4, 5) np.rollaxis(a, 2).shape (5, 3, 4, 6) np.rollaxis(a, 1, 4).shape (3, 5, 6, 4)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L8868">view source</a></div></div><div class="public anchor" id="var-roots"><h3>roots</h3><div class="usage"><code>(roots &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return the roots of a polynomial with coefficients given in p.</p>
<p>The values in the rank-1 array <code>p</code> are coefficients of a polynomial. If the length of <code>p</code> is n+1 then the polynomial is described by::</p>
<p>p[0] * x**n + p[1] * x**(n-1) +  + p[n-1]*x + p[n]</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>p : array_like  Rank-1 array of polynomial coefficients.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  An array containing the roots of the polynomial.</p>
<h2><a href="#raises" name="raises"></a>Raises</h2>
<p>ValueError  When <code>p</code> cannot be converted to a rank-1 array.</p>
<h2><a href="#see-also" name="see-also"></a>See also</h2>
<p>poly : Find the coefficients of a polynomial with a given sequence  of roots. polyval : Compute polynomial values. polyfit : Least squares polynomial fit. poly1d : A one-dimensional polynomial class.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The algorithm relies on computing the eigenvalues of the companion matrix [1]_.</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [1] R. A. Horn &amp; C. R. Johnson, <em>Matrix Analysis</em>. Cambridge, UK:  Cambridge University Press, 1999, pp. 146-7.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>coeff = [3.2, 2, 1] np.roots(coeff) array([-0.3125+0.46351241j, -0.3125-0.46351241j])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L8997">view source</a></div></div><div class="public anchor" id="var-rot90"><h3>rot90</h3><div class="usage"><code>(rot90 &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Rotate an array by 90 degrees in the plane specified by axes.</p>
<p>Rotation direction is from the first towards the second axis.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>m : array_like  Array of two or more dimensions. k : integer  Number of times the array is rotated by 90 degrees. axes: (2,) array_like  The array is rotated in the plane defined by the axes.  Axes must be different.</p>
<pre><code>.. versionadded:: 1.12.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray  A rotated view of <code>m</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>flip : Reverse the order of elements in an array along the given axis. fliplr : Flip an array horizontally. flipud : Flip an array vertically.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>rot90(m, k=1, axes=(1,0)) is the reverse of rot90(m, k=1, axes=(0,1)) rot90(m, k=1, axes=(1,0)) is equivalent to rot90(m, k=-1, axes=(0,1))</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>m = np.array(<a href="null">1,2],[3,4</a>, int) m array(<a href="null">1, 2],
       [3, 4</a>) np.rot90(m) array(<a href="null">2, 4],
       [1, 3</a>) np.rot90(m, 2) array(<a href="null">4, 3],
       [2, 1</a>) m = np.arange(8).reshape((2,2,2)) np.rot90(m, 1, (1,2)) array(<a href="null">[1, 3],
        [0, 2</a>,  <a href="null">5, 7],
        [4, 6</a>])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L24490">view source</a></div></div><div class="public anchor" id="var-round"><h3>round</h3><div class="usage"><code>(round &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Round an array to the given number of decimals.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>around : equivalent function; see for details.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L25600">view source</a></div></div><div class="public anchor" id="var-round_"><h3>round_</h3><div class="usage"><code>(round_ &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Round an array to the given number of decimals.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>around : equivalent function; see for details.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L22775">view source</a></div></div><div class="public anchor" id="var-row_stack"><h3>row_stack</h3><div class="usage"><code>(row_stack &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Stack arrays in sequence vertically (row wise).</p>
<p>This is equivalent to concatenation along the first axis after 1-D arrays of shape <code>(N,)</code> have been reshaped to <code>(1,N)</code>. Rebuilds arrays divided by <code>vsplit</code>.</p>
<p>This function makes most sense for arrays with up to 3 dimensions. For instance, for pixel-data with a height (first axis), width (second axis), and r/g/b channels (third axis). The functions <code>concatenate</code>, <code>stack</code> and <code>block</code> provide more general stacking and concatenation operations.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>tup : sequence of ndarrays  The arrays must have the same shape along all but the first axis.  1-D arrays must have the same length.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>stacked : ndarray  The array formed by stacking the given arrays, will be at least 2-D.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>stack : Join a sequence of arrays along a new axis. hstack : Stack arrays in sequence horizontally (column wise). dstack : Stack arrays in sequence depth wise (along third dimension). concatenate : Join a sequence of arrays along an existing axis. vsplit : Split array into a list of multiple sub-arrays vertically. block : Assemble arrays from blocks.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array([1, 2, 3]) b = np.array([2, 3, 4]) np.vstack((a,b)) array(<a href="null">1, 2, 3],
       [2, 3, 4</a>)</p>
      <p>a = np.array(<a href="null">1], [2], [3</a>) b = np.array(<a href="null">2], [3], [4</a>) np.vstack((a,b)) array(<a href="null">1],
       [2],
       [3],
       [2],
       [3],
       [4</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L27668">view source</a></div></div><div class="public anchor" id="var-s_"><h3>s_</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>A nicer way to build up index tuples for arrays.</p>
<p>.. note::  Use one of the two predefined instances <code>index_exp</code> or <code>s_</code>  rather than directly using <code>IndexExpression</code>.</p>
<p>For any index combination, including slicing and axis insertion, <code>a[indices]</code> is the same as <code>a[np.index_exp[indices]]</code> for any array <code>a</code>. However, <code>np.index_exp[indices]</code> can be used anywhere in Python code and returns a tuple of slice objects that can be used in the construction of complex index expressions.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>maketuple : bool  If True, always returns a tuple.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>index_exp : Predefined instance that always returns a tuple:  <code>index_exp = IndexExpression(maketuple=True)</code>. s_ : Predefined instance without tuple conversion:  <code>s_ = IndexExpression(maketuple=False)</code>.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>You can do all this with <code>slice()</code> plus a few special objects, but theres a lot to remember and this version is simpler because it uses the standard array indexing syntax.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.s_[2::2] slice(2, None, 2) np.index_exp[2::2] (slice(2, None, 2),)</p>
      <p>np.array([0, 1, 2, 3, 4])[np.s_[2::2]] array([2, 4])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L26686">view source</a></div></div><div class="public anchor" id="var-safe_eval"><h3>safe_eval</h3><div class="usage"><code>(safe_eval source)</code></div><div class="doc"><div class="markdown"><p>Protected string evaluation.</p>
<p>Evaluate a string containing a Python literal expression without allowing the execution of arbitrary non-literal code.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>source : str  The string to evaluate.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>obj : object  The result of evaluating <code>source</code>.</p>
<h2><a href="#raises" name="raises"></a>Raises</h2>
<p>SyntaxError  If the code has invalid Python syntax, or if it contains  non-literal code.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.safe_eval(1) 1 np.safe_eval([1, 2, 3]) [1, 2, 3] np.safe_eval({foo: (bar, 10.0)}) {foo: (bar, 10.0)}</p>
      <p>np.safe_eval(import os) Traceback (most recent call last):   SyntaxError: invalid syntax</p>
      <p>np.safe_eval(open(/home/user/.ssh/id_dsa).read()) Traceback (most recent call last):   ValueError: malformed node or string: &lt;_ast.Call object at 0x&gt;</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L20137">view source</a></div></div><div class="public anchor" id="var-save"><h3>save</h3><div class="usage"><code>(save &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Save an array to a binary file in NumPy <code>.npy</code> format.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>file : file, str, or pathlib.Path  File or filename to which the data is saved. If file is a file-object,  then the filename is unchanged. If file is a string or Path, a <code>.npy</code>  extension will be appended to the filename if it does not already  have one. arr : array_like  Array data to be saved. allow_pickle : bool, optional  Allow saving object arrays using Python pickles. Reasons for disallowing  pickles include security (loading pickled data can execute arbitrary  code) and portability (pickled objects may not be loadable on different  Python installations, for example if the stored objects require libraries  that are not available, and not all pickled data is compatible between  Python 2 and Python 3).  Default: True fix_imports : bool, optional  Only useful in forcing objects in object arrays on Python 3 to be  pickled in a Python 2 compatible way. If <code>fix_imports</code> is True, pickle  will try to map the new Python 3 names to the old module names used in  Python 2, so that the pickle data stream is readable with Python 2.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>savez : Save several arrays into a <code>.npz</code> archive savetxt, load</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>For a description of the <code>.npy</code> format, see :py:mod:<code>numpy.lib.format</code>.</p>
<p>Any data saved to the file is appended to the end of the file.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>from tempfile import TemporaryFile outfile = TemporaryFile()</p>
      <p>x = np.arange(10) np.save(outfile, x)</p>
      <p>_ = outfile.seek(0) # Only needed here to simulate closing &amp; reopening file np.load(outfile) array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</p>
      <p>with open(test.npy, wb) as f:  np.save(f, np.array([1, 2]))  np.save(f, np.array([1, 3])) with open(test.npy, rb) as f:  a = np.load(f)  b = np.load(f) print(a, b)</p>
      <h1><a href="#1-2" name="1-2"></a>[1 2] [1 3]</h1>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L1427">view source</a></div></div><div class="public anchor" id="var-savetxt"><h3>savetxt</h3><div class="usage"><code>(savetxt &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Save an array to a text file.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>fname : filename or file handle  If the filename ends in <code>.gz</code>, the file is automatically saved in  compressed gzip format. <code>loadtxt</code> understands gzipped files  transparently. X : 1D or 2D array_like  Data to be saved to a text file. fmt : str or sequence of strs, optional  A single format (%10.5f), a sequence of formats, or a  multi-format string, e.g. Iteration %d  %10.5f, in which  case <code>delimiter</code> is ignored. For complex <code>X</code>, the legal options  for <code>fmt</code> are:</p>
<pre><code>* a single specifier, `fmt='%.4e'`, resulting in numbers formatted
  like `' (%s+%sj)' % (fmt, fmt)`
* a full string specifying every real and imaginary part, e.g.
  `' %.4e %+.4ej %.4e %+.4ej %.4e %+.4ej'` for 3 columns
* a list of specifiers, one per column - in this case, the real
  and imaginary part must have separate specifiers,
  e.g. `['%.3e + %.3ej', '(%.15e%+.15ej)']` for 2 columns
</code></pre>
<p>delimiter : str, optional  String or character separating columns. newline : str, optional  String or character separating lines.</p>
<pre><code>.. versionadded:: 1.5.0
</code></pre>
<p>header : str, optional  String that will be written at the beginning of the file.</p>
<pre><code>.. versionadded:: 1.7.0
</code></pre>
<p>footer : str, optional  String that will be written at the end of the file.</p>
<pre><code>.. versionadded:: 1.7.0
</code></pre>
<p>comments : str, optional  String that will be prepended to the <code>header</code> and <code>footer</code> strings,  to mark them as comments. Default: # , as expected by e.g.  <code>numpy.loadtxt</code>.</p>
<pre><code>.. versionadded:: 1.7.0
</code></pre>
<p>encoding : {None, str}, optional  Encoding used to encode the outputfile. Does not apply to output  streams. If the encoding is something other than bytes or latin1  you will not be able to load the file in NumPy versions &lt; 1.14. Default  is latin1.</p>
<pre><code>.. versionadded:: 1.14.0
</code></pre>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>save : Save an array to a binary file in NumPy <code>.npy</code> format savez : Save several arrays into an uncompressed <code>.npz</code> archive savez_compressed : Save several arrays into a compressed <code>.npz</code> archive</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Further explanation of the <code>fmt</code> parameter (<code>%[flag]width[.precision]specifier</code>):</p>
<p>flags:  <code>-</code> : left justify</p>
<pre><code>``+`` : Forces to precede result with + or -.

``0`` : Left pad the number with zeros instead of space (see width).
</code></pre>
<p>width:  Minimum number of characters to be printed. The value is not truncated  if it has more characters.</p>
<p>precision:  - For integer specifiers (eg. <code>d,i,o,x</code>), the minimum number of  digits.  - For <code>e, E</code> and <code>f</code> specifiers, the number of digits to print  after the decimal point.  - For <code>g</code> and <code>G</code>, the maximum number of significant digits.  - For <code>s</code>, the maximum number of characters.</p>
<p>specifiers:  <code>c</code> : character</p>
<pre><code>``d`` or ``i`` : signed decimal integer

``e`` or ``E`` : scientific notation with ``e`` or ``E``.

``f`` : decimal floating point

``g,G`` : use the shorter of ``e,E`` or ``f``

``o`` : signed octal

``s`` : string of characters

``u`` : unsigned decimal integer

``x,X`` : unsigned hexadecimal integer
</code></pre>
<p>This explanation of <code>fmt</code> is not complete, for an exhaustive specification see [1]_.</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [1] <code>Format Specification Mini-Language
       &lt;https://docs.python.org/library/string.html#format-specification-mini-language&gt;</code>_,  Python Documentation.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = y = z = np.arange(0.0,5.0,1.0) np.savetxt(test.out, x, delimiter=,) # X is an array np.savetxt(test.out, (x,y,z)) # x,y,z equal sized 1D arrays np.savetxt(test.out, x, fmt=%1.4e) # use exponential notation</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L13223">view source</a></div></div><div class="public anchor" id="var-savez"><h3>savez</h3><div class="usage"><code>(savez &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Save several arrays into a single file in uncompressed <code>.npz</code> format.</p>
<p>If arguments are passed in with no keywords, the corresponding variable names, in the <code>.npz</code> file, are arr_0, arr_1, etc. If keyword arguments are given, the corresponding variable names, in the <code>.npz</code> file will match the keyword names.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>file : str or file  Either the filename (string) or an open file (file-like object)  where the data will be saved. If file is a string or a Path, the  <code>.npz</code> extension will be appended to the filename if it is not  already there. args : Arguments, optional  Arrays to save to the file. Since it is not possible for Python to  know the names of the arrays outside <code>savez</code>, the arrays will be saved  with names arr_0, arr_1, and so on. These arguments can be any  expression. kwds : Keyword arguments, optional  Arrays to save to the file. Arrays will be saved in the file with the  keyword names.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>None</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>save : Save a single array to a binary file in NumPy format. savetxt : Save an array to a file as plain text. savez_compressed : Save several arrays into a compressed <code>.npz</code> archive</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The <code>.npz</code> file format is a zipped archive of files named after the variables they contain. The archive is not compressed and each file in the archive contains one variable in <code>.npy</code> format. For a description of the <code>.npy</code> format, see :py:mod:<code>numpy.lib.format</code>.</p>
<p>When opening the saved <code>.npz</code> file with <code>load</code> a <code>NpzFile</code> object is returned. This is a dictionary-like object which can be queried for its list of arrays (with the <code>.files</code> attribute), and for the arrays themselves.</p>
<p>When saving dictionaries, the dictionary keys become filenames inside the ZIP archive. Therefore, keys should be valid filenames. E.g., avoid keys that begin with <code>/</code> or contain <code>.</code>.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>from tempfile import TemporaryFile outfile = TemporaryFile() x = np.arange(10) y = np.sin(x)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Using <code>savez</code> with *args, the arrays are saved with default names.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.savez(outfile, x, y) _ = outfile.seek(0) # Only needed here to simulate closing &amp; reopening file npzfile = np.load(outfile) npzfile.files [arr_0, arr_1] npzfile[arr_0] array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Using <code>savez</code> with **kwds, the arrays are saved with the keyword names.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>outfile = TemporaryFile() np.savez(outfile, x=x, y=y) _ = outfile.seek(0) npzfile = np.load(outfile) sorted(npzfile.files) [x, y] npzfile[x] array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L27721">view source</a></div></div><div class="public anchor" id="var-savez_compressed"><h3>savez_compressed</h3><div class="usage"><code>(savez_compressed &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Save several arrays into a single file in compressed <code>.npz</code> format.</p>
<p>If keyword arguments are given, then filenames are taken from the keywords. If arguments are passed in with no keywords, then stored filenames are arr_0, arr_1, etc.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>file : str or file  Either the filename (string) or an open file (file-like object)  where the data will be saved. If file is a string or a Path, the  <code>.npz</code> extension will be appended to the filename if it is not  already there. args : Arguments, optional  Arrays to save to the file. Since it is not possible for Python to  know the names of the arrays outside <code>savez</code>, the arrays will be saved  with names arr_0, arr_1, and so on. These arguments can be any  expression. kwds : Keyword arguments, optional  Arrays to save to the file. Arrays will be saved in the file with the  keyword names.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>None</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>numpy.save : Save a single array to a binary file in NumPy format. numpy.savetxt : Save an array to a file as plain text. numpy.savez : Save several arrays into an uncompressed <code>.npz</code> file format numpy.load : Load the files created by savez_compressed.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The <code>.npz</code> file format is a zipped archive of files named after the variables they contain. The archive is compressed with <code>zipfile.ZIP_DEFLATED</code> and each file in the archive contains one variable in <code>.npy</code> format. For a description of the <code>.npy</code> format, see :py:mod:<code>numpy.lib.format</code>.</p>
<p>When opening the saved <code>.npz</code> file with <code>load</code> a <code>NpzFile</code> object is returned. This is a dictionary-like object which can be queried for its list of arrays (with the <code>.files</code> attribute), and for the arrays themselves.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>test_array = np.random.rand(3, 2) test_vector = np.random.rand(4) np.savez_compressed(/tmp/123, a=test_array, b=test_vector) loaded = np.load(/tmp/123.npz) print(np.array_equal(test_array, loaded[a])) True print(np.array_equal(test_vector, loaded[b])) True</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L5819">view source</a></div></div><div class="public anchor" id="var-ScalarType"><h3>ScalarType</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Built-in immutable sequence.</p>
<p>If no argument is given, the constructor returns an empty tuple. If iterable is specified the tuple is initialized from iterables items.</p>
<p>If the argument is a tuple, the return value is the same object.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L22011">view source</a></div></div><div class="public anchor" id="var-sctype2char"><h3>sctype2char</h3><div class="usage"><code>(sctype2char sctype)</code></div><div class="doc"><div class="markdown"><p>Return the string representation of a scalar dtype.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>sctype : scalar dtype or object  If a scalar dtype, the corresponding string character is  returned. If an object, <code>sctype2char</code> tries to infer its scalar type  and then return the corresponding string character.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>typechar : str  The string character corresponding to the scalar type.</p>
<h2><a href="#raises" name="raises"></a>Raises</h2>
<p>ValueError  If <code>sctype</code> is an object for which the type can not be inferred.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>obj2sctype, issctype, issubsctype, mintypecode</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>for sctype in [np.int32, np.double, np.complex_, np.string_, np.ndarray]:  print(np.sctype2char(sctype)) l # may vary d D S O</p>
      <p>x = np.array([1., 2-1.j]) np.sctype2char(x) D np.sctype2char(list) O</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L1649">view source</a></div></div><div class="public anchor" id="var-sctypeDict"><h3>sctypeDict</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping objects  (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:  d = {}  for k, v in iterable:  d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs  in the keyword argument list. For example: dict(one=1, two=2)</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L16794">view source</a></div></div><div class="public anchor" id="var-sctypeNA"><h3>sctypeNA</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L11195">view source</a></div></div><div class="public anchor" id="var-sctypes"><h3>sctypes</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping objects  (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:  d = {}  for k, v in iterable:  d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs  in the keyword argument list. For example: dict(one=1, two=2)</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L2123">view source</a></div></div><div class="public anchor" id="var-searchsorted"><h3>searchsorted</h3><div class="usage"><code>(searchsorted &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Find indices where elements should be inserted to maintain order.</p>
<p>Find the indices into a sorted array <code>a</code> such that, if the corresponding elements in <code>v</code> were inserted before the indices, the order of <code>a</code> would be preserved.</p>
<p>Assuming that <code>a</code> is sorted:</p>
<p>====== ============================ <code>side</code> returned index <code>i</code> satisfies ====== ============================ left <code>a[i-1] &lt; v &lt;= a[i]</code> right <code>a[i-1] &lt;= v &lt; a[i]</code> ====== ============================</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : 1-D array_like  Input array. If <code>sorter</code> is None, then it must be sorted in  ascending order, otherwise <code>sorter</code> must be an array of indices  that sort it. v : array_like  Values to insert into <code>a</code>. side : {left, right}, optional  If left, the index of the first suitable location found is given.  If right, return the last such index. If there is no suitable  index, return either 0 or N (where N is the length of <code>a</code>). sorter : 1-D array_like, optional  Optional array of integer indices that sort array a into ascending  order. They are typically the result of argsort.</p>
<pre><code>.. versionadded:: 1.7.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>indices : array of ints  Array of insertion points with the same shape as <code>v</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>sort : Return a sorted copy of an array. histogram : Produce histogram from 1-D data.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Binary search is used to find the required insertion points.</p>
<p>As of NumPy 1.4.0 <code>searchsorted</code> works with real/complex arrays containing <code>nan</code> values. The enhanced sort order is documented in <code>sort</code>.</p>
<p>This function uses the same algorithm as the builtin python <code>bisect.bisect_left</code> (<code>side='left'</code>) and <code>bisect.bisect_right</code> (<code>side='right'</code>) functions, which is also vectorized in the <code>v</code> argument.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.searchsorted([1,2,3,4,5], 3) 2 np.searchsorted([1,2,3,4,5], 3, side=right) 3 np.searchsorted([1,2,3,4,5], [-10, 10, 2, 3]) array([0, 5, 1, 2])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L15809">view source</a></div></div><div class="public anchor" id="var-select"><h3>select</h3><div class="usage"><code>(select &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return an array drawn from elements in choicelist, depending on conditions.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>condlist : list of bool ndarrays  The list of conditions which determine from which array in <code>choicelist</code>  the output elements are taken. When multiple conditions are satisfied,  the first one encountered in <code>condlist</code> is used. choicelist : list of ndarrays  The list of arrays from which the output elements are taken. It has  to be of the same length as <code>condlist</code>. default : scalar, optional  The element inserted in <code>output</code> when all conditions evaluate to False.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>output : ndarray  The output at position m is the m-th element of the array in  <code>choicelist</code> where the m-th element of the corresponding array in  <code>condlist</code> is True.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>where : Return elements from one of two arrays depending on condition. take, choose, compress, diag, diagonal</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.arange(10) condlist = [x&lt;3, x&gt;5] choicelist = [x, x**2] np.select(condlist, choicelist) array([ 0, 1, 2, , 49, 64, 81])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L16860">view source</a></div></div><div class="public anchor" id="var-set_numeric_ops"><h3>set_numeric_ops</h3><div class="usage"><code>(set_numeric_ops self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>set_numeric_ops(op1=func1, op2=func2, )</p>
<p>Set numerical operators for array objects.</p>
<p>.. deprecated:: 1.16</p>
<pre><code>For the general case, use :c:func:`PyUFunc_ReplaceLoopBySignature`.
For ndarray subclasses, define the ``__array_ufunc__`` method and
override the relevant ufunc.
</code></pre>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>op1, op2,  : callable  Each <code>op = func</code> pair describes an operator to be replaced.  For example, <code>add = lambda x, y: np.add(x, y) % 5</code> would replace  addition by modulus 5 addition.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>saved_ops : list of callables  A list of all operators, stored before making replacements.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>.. WARNING::  Use with care! Incorrect usage may lead to memory errors.</p>
<p>A function replacing an operator cannot make use of that operator. For example, when replacing add, you may not use <code>+</code>. Instead, directly call ufuncs.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>def add_mod5(x, y):  return np.add(x, y) % 5  old_funcs = np.set_numeric_ops(add=add_mod5)</p>
      <p>x = np.arange(12).reshape((3, 4)) x + x array(<a href="null">0, 2, 4, 1],
       [3, 0, 2, 4],
       [1, 3, 0, 2</a>)</p>
      <p>ignore = np.set_numeric_ops(**old_funcs) # restore operators</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L10917">view source</a></div></div><div class="public anchor" id="var-set_printoptions"><h3>set_printoptions</h3><div class="usage"><code>(set_printoptions &amp; [{infstr :infstr, linewidth :linewidth, suppress :suppress, :as kwarg, sign :sign, formatter :formatter, precision :precision, floatmode :floatmode, edgeitems :edgeitems, threshold :threshold, nanstr :nanstr}])</code><code>(set_printoptions &amp; [{infstr :infstr, linewidth :linewidth, suppress :suppress, :as kwarg, sign :sign, formatter :formatter, precision :precision, edgeitems :edgeitems, threshold :threshold, nanstr :nanstr}])</code><code>(set_printoptions &amp; [{infstr :infstr, linewidth :linewidth, suppress :suppress, :as kwarg, formatter :formatter, precision :precision, edgeitems :edgeitems, threshold :threshold, nanstr :nanstr}])</code><code>(set_printoptions &amp; [{precision :precision, threshold :threshold, edgeitems :edgeitems, linewidth :linewidth, suppress :suppress, nanstr :nanstr, infstr :infstr, :as kwarg}])</code><code>(set_printoptions &amp; [{precision :precision, threshold :threshold, edgeitems :edgeitems, linewidth :linewidth, suppress :suppress, nanstr :nanstr, :as kwarg}])</code><code>(set_printoptions &amp; [{precision :precision, threshold :threshold, edgeitems :edgeitems, linewidth :linewidth, suppress :suppress, :as kwarg}])</code><code>(set_printoptions &amp; [{precision :precision, threshold :threshold, edgeitems :edgeitems, linewidth :linewidth, :as kwarg}])</code><code>(set_printoptions &amp; [{precision :precision, threshold :threshold, edgeitems :edgeitems, :as kwarg}])</code><code>(set_printoptions &amp; [{precision :precision, threshold :threshold, :as kwarg}])</code><code>(set_printoptions &amp; [{precision :precision, :as kwarg}])</code><code>(set_printoptions &amp; [{:as kwarg}])</code></div><div class="doc"><div class="markdown"><p>Set printing options.</p>
<p>These options determine the way floating point numbers, arrays and other NumPy objects are displayed.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>precision : int or None, optional  Number of digits of precision for floating point output (default 8).  May be None if <code>floatmode</code> is not <code>fixed</code>, to print as many digits as  necessary to uniquely specify the value. threshold : int, optional  Total number of array elements which trigger summarization  rather than full repr (default 1000).  To always use the full repr without summarization, pass <code>sys.maxsize</code>. edgeitems : int, optional  Number of array items in summary at beginning and end of  each dimension (default 3). linewidth : int, optional  The number of characters per line for the purpose of inserting  line breaks (default 75). suppress : bool, optional  If True, always print floating point numbers using fixed point  notation, in which case numbers equal to zero in the current precision  will print as zero. If False, then scientific notation is used when  absolute value of the smallest number is &lt; 1e-4 or the ratio of the
    maximum absolute value to the minimum is &gt; 1e3. The default is False. nanstr : str, optional  String representation of floating point not-a-number (default nan). infstr : str, optional  String representation of floating point infinity (default inf). sign : string, either -, +, or  , optional  Controls printing of the sign of floating-point types. If +, always  print the sign of positive values. If  , always prints a space  (whitespace character) in the sign position of positive values. If  -, omit the sign character of positive values. (default -) formatter : dict of callables, optional  If not None, the keys should indicate the type(s) that the respective  formatting function applies to. Callables should return a string.  Types that are not specified (by their corresponding keys) are handled  by the default formatters. Individual types for which a formatter  can be set are:</p>
<pre><code>- 'bool'
- 'int'
- 'timedelta' : a `numpy.timedelta64`
- 'datetime' : a `numpy.datetime64`
- 'float'
- 'longfloat' : 128-bit floats
- 'complexfloat'
- 'longcomplexfloat' : composed of two 128-bit floats
- 'numpystr' : types `numpy.string_` and `numpy.unicode_`
- 'object' : `np.object_` arrays
- 'str' : all other strings

Other keys that can be used to set a group of types at once are:

- 'all' : sets all types
- 'int_kind' : sets 'int'
- 'float_kind' : sets 'float' and 'longfloat'
- 'complex_kind' : sets 'complexfloat' and 'longcomplexfloat'
- 'str_kind' : sets 'str' and 'numpystr'
</code></pre>
<p>floatmode : str, optional  Controls the interpretation of the <code>precision</code> option for  floating-point types. Can take the following values  (default maxprec_equal):</p>
<pre><code>* 'fixed': Always print exactly `precision` fractional digits,
        even if this would print more or fewer digits than
        necessary to specify the value uniquely.
* 'unique': Print the minimum number of fractional digits necessary
        to represent each value uniquely. Different elements may
        have a different number of digits. The value of the
        `precision` option is ignored.
* 'maxprec': Print at most `precision` fractional digits, but if
        an element can be uniquely represented with fewer digits
        only print it with that many.
* 'maxprec_equal': Print at most `precision` fractional digits,
        but if every element in the array can be uniquely
        represented with an equal number of fewer digits, use that
        many digits for all elements.
</code></pre>
<p>legacy : string or <code>False</code>, optional  If set to the string <code>'1.13'</code> enables 1.13 legacy printing mode. This  approximates numpy 1.13 print output by including a space in the sign  position of floats and different behavior for 0d arrays. If set to  <code>False</code>, disables legacy mode. Unrecognized strings will be ignored  with a warning for forward compatibility.</p>
<pre><code>.. versionadded:: 1.14.0
</code></pre>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>get_printoptions, printoptions, set_string_function, array2string</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p><code>formatter</code> is always reset with a call to <code>set_printoptions</code>.</p>
<p>Use <code>printoptions</code> as a context manager to set the values temporarily.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>Floating point precision can be set:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.set_printoptions(precision=4) np.array([1.123456789]) [1.1235]</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Long arrays can be summarised:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.set_printoptions(threshold=5) np.arange(10) array([0, 1, 2, , 7, 8, 9])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Small results can be suppressed:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>eps = np.finfo(float).eps x = np.arange(4.) x**2 - (x + eps)**2 array([-4.9304e-32, -4.4409e-16, 0.0000e+00, 0.0000e+00]) np.set_printoptions(suppress=True) x**2 - (x + eps)**2 array([-0., -0., 0., 0.])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>A custom formatter can be used to display array elements as desired:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.set_printoptions(formatter={all:lambda x: int: +str(-x)}) x = np.arange(3) x array([int: 0, int: -1, int: -2]) np.set_printoptions() # formatter gets reset x array([0, 1, 2])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>To put back the default options, you can use:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.set_printoptions(edgeitems=3, infstr=inf,  linewidth=75, nanstr=nan, precision=8,  suppress=False, threshold=1000, formatter=None)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Also to temporarily override options, use <code>printoptions</code> as a context manager:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>with np.printoptions(precision=2, suppress=True, threshold=5):  np.linspace(0, 10, 10) array([ 0. , 1.11, 2.22, , 7.78, 8.89, 10. ])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L2782">view source</a></div></div><div class="public anchor" id="var-set_string_function"><h3>set_string_function</h3><div class="usage"><code>(set_string_function f &amp; [{repr :repr}])</code><code>(set_string_function f)</code></div><div class="doc"><div class="markdown"><p>Set a Python function to be used when pretty printing arrays.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>f : function or None  Function to be used to pretty print arrays. The function should expect  a single array argument and return a string of the representation of  the array. If None, the function is reset to the default NumPy function  to print arrays. repr : bool, optional  If True (default), the function for pretty printing (<code>__repr__</code>)  is set, if False the function that returns the default string  representation (<code>__str__</code>) is set.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>set_printoptions, get_printoptions</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>def pprint(arr):  return HA! - What are you going to do now?  np.set_string_function(pprint) a = np.arange(10) a HA! - What are you going to do now? _ = a</p>
      <h1><a href="#0-1-2-3-4-5-6-7-8-9" name="0-1-2-3-4-5-6-7-8-9"></a>[0 1 2 3 4 5 6 7 8 9]</h1>
    </blockquote>
  </blockquote>
</blockquote>
<p>We can reset the function to the default:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.set_string_function(None) a array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p><code>repr</code> affects either pretty printing or normal string representation. Note that <code>__repr__</code> is still affected by setting <code>__str__</code> because the width of each array element in the returned string becomes equal to the length of the result of <code>__str__()</code>.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.arange(4) np.set_string_function(lambda x:random, repr=False) x.__str__() random x.__repr__() array([0, 1, 2, 3])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L23940">view source</a></div></div><div class="public anchor" id="var-setbufsize"><h3>setbufsize</h3><div class="usage"><code>(setbufsize size)</code></div><div class="doc"><div class="markdown"><p>Set the size of the buffer used in ufuncs.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>size : int  Size of buffer.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L9533">view source</a></div></div><div class="public anchor" id="var-setdiff1d"><h3>setdiff1d</h3><div class="usage"><code>(setdiff1d &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Find the set difference of two arrays.</p>
<p>Return the unique values in <code>ar1</code> that are not in <code>ar2</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>ar1 : array_like  Input array. ar2 : array_like  Input comparison array. assume_unique : bool  If True, the input arrays are both assumed to be unique, which  can speed up the calculation. Default is False.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>setdiff1d : ndarray  1D array of values in <code>ar1</code> that are not in <code>ar2</code>. The result  is sorted when <code>assume_unique=False</code>, but otherwise only sorted  if the input is sorted.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>numpy.lib.arraysetops : Module with a number of other functions for  performing set operations on arrays.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array([1, 2, 3, 2, 4, 1]) b = np.array([3, 4, 5, 6]) np.setdiff1d(a, b) array([1, 2])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L16287">view source</a></div></div><div class="public anchor" id="var-seterr"><h3>seterr</h3><div class="usage"><code>(seterr &amp; [{all :all, divide :divide, over :over, under :under, invalid :invalid}])</code><code>(seterr &amp; [{all :all, divide :divide, over :over, under :under}])</code><code>(seterr &amp; [{all :all, divide :divide, over :over}])</code><code>(seterr &amp; [{all :all, divide :divide}])</code><code>(seterr &amp; [{all :all}])</code><code>(seterr)</code></div><div class="doc"><div class="markdown"><p>Set how floating-point errors are handled.</p>
<p>Note that operations on integer scalar types (such as <code>int16</code>) are handled like floating point, and are affected by these settings.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>all : {ignore, warn, raise, call, print, log}, optional  Set treatment for all types of floating-point errors at once:</p>
<pre><code>- ignore: Take no action when the exception occurs.
- warn: Print a `RuntimeWarning` (via the Python `warnings` module).
- raise: Raise a `FloatingPointError`.
- call: Call a function specified using the `seterrcall` function.
- print: Print a warning directly to ``stdout``.
- log: Record error in a Log object specified by `seterrcall`.

The default is not to change the current behavior.
</code></pre>
<p>divide : {ignore, warn, raise, call, print, log}, optional  Treatment for division by zero. over : {ignore, warn, raise, call, print, log}, optional  Treatment for floating-point overflow. under : {ignore, warn, raise, call, print, log}, optional  Treatment for floating-point underflow. invalid : {ignore, warn, raise, call, print, log}, optional  Treatment for invalid floating-point operation.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>old_settings : dict  Dictionary containing the old settings.</p>
<h2><a href="#see-also" name="see-also"></a>See also</h2>
<p>seterrcall : Set a callback function for the call mode. geterr, geterrcall, errstate</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The floating-point exceptions are defined in the IEEE 754 standard [1]_:</p>
<ul>
  <li>Division by zero: infinite result obtained from finite numbers.</li>
  <li>Overflow: result too large to be expressed.</li>
  <li>Underflow: result so close to zero that some precision  was lost.</li>
  <li>Invalid operation: result is not an expressible number, typically  indicates that a NaN was produced.</li>
</ul>
<p>.. [1] <a href="https://en.wikipedia.org/wiki/IEEE_754">https://en.wikipedia.org/wiki/IEEE_754</a></p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>old_settings = np.seterr(all=ignore) #seterr to known value np.seterr(over=raise) {divide: ignore, over: ignore, under: ignore, invalid: ignore} np.seterr(**old_settings) # reset to default {divide: ignore, over: raise, under: ignore, invalid: ignore}</p>
      <p>np.int16(32000) * np.int16(3) 30464 old_settings = np.seterr(all=warn, over=raise) np.int16(32000) * np.int16(3) Traceback (most recent call last):  File <stdin>, line 1, in <module> FloatingPointError: overflow encountered in short_scalars</module></stdin></p>
      <p>from collections import OrderedDict old_settings = np.seterr(all=print) OrderedDict(np.geterr()) OrderedDict([(divide, print), (over, print), (under, print), (invalid, print)]) np.int16(32000) * np.int16(3) 30464</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L2347">view source</a></div></div><div class="public anchor" id="var-seterrcall"><h3>seterrcall</h3><div class="usage"><code>(seterrcall func)</code></div><div class="doc"><div class="markdown"><p>Set the floating-point error callback function or log object.</p>
<p>There are two ways to capture floating-point error messages. The first is to set the error-handler to call, using <code>seterr</code>. Then, set the function to call using this function.</p>
<p>The second is to set the error-handler to log, using <code>seterr</code>. Floating-point errors then trigger a call to the write method of the provided object.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>func : callable f(err, flag) or object with write method  Function to call upon floating-point errors (call-mode) or  object whose write method is used to log such message (log-mode).</p>
<pre><code>The call function takes two arguments. The first is a string describing
the type of error (such as "divide by zero", "overflow", "underflow",
or "invalid value"), and the second is the status flag.  The flag is a
byte, whose four least-significant bits indicate the type of error, one
of "divide", "over", "under", "invalid"::

  [0 0 0 0 divide over under invalid]

In other words, ``flags = divide + 2*over + 4*under + 8*invalid``.

If an object is provided, its write method should take one argument,
a string.
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>h : callable, log instance or None  The old error handler.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>seterr, geterr, geterrcall</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>Callback upon error:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>def err_handler(type, flag):  print(Floating point error (%s), with flag %s % (type, flag)) </p>
      <p>saved_handler = np.seterrcall(err_handler) save_err = np.seterr(all=call) from collections import OrderedDict</p>
      <p>np.array([1, 2, 3]) / 0.0 Floating point error (divide by zero), with flag 1 array([inf, inf, inf])</p>
      <p>np.seterrcall(saved_handler) &lt;function err_handler at 0x&gt; OrderedDict(sorted(np.seterr(**save_err).items())) OrderedDict([(divide, call), (invalid, call), (over, call), (under, call)])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Log error message:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>class Log(object):  def write(self, msg):  print(LOG: %s % msg) </p>
      <p>log = Log() saved_handler = np.seterrcall(log) save_err = np.seterr(all=log)</p>
      <p>np.array([1, 2, 3]) / 0.0 LOG: Warning: divide by zero encountered in true_divide array([inf, inf, inf])</p>
      <p>np.seterrcall(saved_handler) &lt;numpy.core.numeric.Log object at 0x&gt; OrderedDict(sorted(np.seterr(**save_err).items())) OrderedDict([(divide, log), (invalid, log), (over, log), (under, log)])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L11939">view source</a></div></div><div class="public anchor" id="var-seterrobj"><h3>seterrobj</h3><div class="usage"><code>(seterrobj self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>seterrobj(errobj)</p>
<p>Set the object that defines floating-point error handling.</p>
<p>The error object contains all information that defines the error handling behavior in NumPy. <code>seterrobj</code> is used internally by the other functions that set error handling behavior (<code>seterr</code>, <code>seterrcall</code>).</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>errobj : list  The error object, a list containing three elements:  [internal numpy buffer size, error mask, error callback function].</p>
<pre><code>The error mask is a single integer that holds the treatment information
on all four floating point errors. The information for each error type
is contained in three bits of the integer. If we print it in base 8, we
can see what treatment is set for "invalid", "under", "over", and
"divide" (in that order). The printed string can be interpreted with

* 0 : 'ignore'
* 1 : 'warn'
* 2 : 'raise'
* 3 : 'call'
* 4 : 'print'
* 5 : 'log'
</code></pre>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>geterrobj, seterr, geterr, seterrcall, geterrcall getbufsize, setbufsize</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>For complete documentation of the types of floating-point exceptions and treatment options, see <code>seterr</code>.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>old_errobj = np.geterrobj() # first get the defaults old_errobj [8192, 521, None]</p>
      <p>def err_handler(type, flag):  print(Floating point error (%s), with flag %s % (type, flag))  new_errobj = [20000, 12, err_handler] np.seterrobj(new_errobj) np.base_repr(12, 8) # int for divide=4 (print) and over=1 (warn) 14 np.geterr() {over: warn, divide: print, invalid: ignore, under: ignore} np.geterrcall() is err_handler True</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L27456">view source</a></div></div><div class="public anchor" id="var-setxor1d"><h3>setxor1d</h3><div class="usage"><code>(setxor1d &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Find the set exclusive-or of two arrays.</p>
<p>Return the sorted, unique values that are in only one (not both) of the input arrays.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>ar1, ar2 : array_like  Input arrays. assume_unique : bool  If True, the input arrays are both assumed to be unique, which  can speed up the calculation. Default is False.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>setxor1d : ndarray  Sorted 1D array of unique values that are in only one of the input  arrays.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array([1, 2, 3, 2, 4]) b = np.array([2, 3, 5, 7, 5]) np.setxor1d(a,b) array([1, 4, 5, 7])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L4823">view source</a></div></div><div class="public anchor" id="var-shape"><h3>shape</h3><div class="usage"><code>(shape &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return the shape of an array.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input array.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>shape : tuple of ints  The elements of the shape tuple give the lengths of the  corresponding array dimensions.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>alen ndarray.shape : Equivalent array method.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.shape(np.eye(3)) (3, 3) np.shape(<a href="null">1, 2</a>) (1, 2) np.shape([0]) (1,) np.shape(0) ()</p>
      <p>a = np.array([(1, 2), (3, 4)], dtype=[(x, i4), (y, i4)]) np.shape(a) (2,) a.shape (2,)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L5579">view source</a></div></div><div class="public anchor" id="var-shares_memory"><h3>shares_memory</h3><div class="usage"><code>(shares_memory &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>shares_memory(a, b, max_work=None)</p>
<p>Determine if two arrays share memory</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a, b : ndarray  Input arrays max_work : int, optional  Effort to spend on solving the overlap problem (maximum number  of candidate solutions to consider). The following special  values are recognized:</p>
<pre><code>max_work=MAY_SHARE_EXACT  (default)
    The problem is solved exactly. In this case, the function returns
    True only if there is an element shared between the arrays.
max_work=MAY_SHARE_BOUNDS
    Only the memory bounds of a and b are checked.
</code></pre>
<h2><a href="#raises" name="raises"></a>Raises</h2>
<p>numpy.TooHardError  Exceeded max_work.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : bool</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>may_share_memory</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.may_share_memory(np.array([1,2]), np.array([5,8,9])) False</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L11412">view source</a></div></div><div class="public anchor" id="var-SHIFT_DIVIDEBYZERO"><h3>SHIFT_DIVIDEBYZERO</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L16670">view source</a></div></div><div class="public anchor" id="var-SHIFT_INVALID"><h3>SHIFT_INVALID</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L2072">view source</a></div></div><div class="public anchor" id="var-SHIFT_OVERFLOW"><h3>SHIFT_OVERFLOW</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L12034">view source</a></div></div><div class="public anchor" id="var-SHIFT_UNDERFLOW"><h3>SHIFT_UNDERFLOW</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L21615">view source</a></div></div><div class="public anchor" id="var-short"><h3>short</h3><div class="usage"><code>(short self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Signed integer type, compatible with C <code>short</code>. Character code: <code>'h'</code>. Canonical name: <code>np.short</code>. Alias <em>on this platform</em>: <code>np.int16</code>: 16-bit signed integer (-32768 to 32767).</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L12397">view source</a></div></div><div class="public anchor" id="var-show_config"><h3>show_config</h3><div class="usage"><code>(show_config)</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L20946">view source</a></div></div><div class="public anchor" id="var-sign"><h3>sign</h3><div class="usage"><code>(sign self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>sign(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Returns an element-wise indication of the sign of a number.</p>
<p>The <code>sign</code> function returns <code>-1 if x &lt; 0, 0 if x==0, 1 if x &gt; 0</code>. nan is returned for nan inputs.</p>
<p>For complex inputs, the <code>sign</code> function returns <code>sign(x.real) + 0j if x.real != 0 else sign(x.imag) + 0j</code>.</p>
<p>complex(nan, 0) is returned for complex nan inputs.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Input values. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray  The sign of <code>x</code>.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>There is more than one definition of sign in common use for complex numbers. The definition used here is equivalent to :math:<code>x/\sqrt{x*x}</code> which is different from a common alternative, :math:<code>x/|x|</code>.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.sign([-5., 4.5]) array([-1., 1.]) np.sign(0) 0 np.sign(5-2j) (1+0j)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L25917">view source</a></div></div><div class="public anchor" id="var-signbit"><h3>signbit</h3><div class="usage"><code>(signbit self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>signbit(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Returns element-wise True where signbit is set (less than zero).</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  The input value(s). out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>result : ndarray of bool  Output array, or reference to <code>out</code> if that was supplied.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.signbit(-1.2) True np.signbit(np.array([1, -2.3, 2.1])) array([False, True, False])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L23258">view source</a></div></div><div class="public anchor" id="var-signedinteger"><h3>signedinteger</h3><div class="usage"><code>(signedinteger self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Abstract base class of all signed integer scalar types.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L13733">view source</a></div></div><div class="public anchor" id="var-sin"><h3>sin</h3><div class="usage"><code>(sin self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>sin(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Trigonometric sine, element-wise.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Angle, in radians (:math:<code>2 \pi</code> rad equals 360 degrees). out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : array_like  The sine of each element of x.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>arcsin, sinh, cos</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The sine is one of the fundamental functions of trigonometry (the mathematical study of triangles). Consider a circle of radius 1 centered on the origin. A ray comes in from the :math:<code>+x</code> axis, makes an angle at the origin (measured counter-clockwise from that axis), and departs from the origin. The :math:<code>y</code> coordinate of the outgoing rays intersection with the unit circle is the sine of that angle. It ranges from -1 for :math:<code>x=3\pi / 2</code> to +1 for :math:<code>\pi / 2.</code> The function has zeroes where the angle is a multiple of :math:<code>\pi</code>. Sines of angles between :math:<code>\pi</code> and :math:<code>2\pi</code> are negative. The numerous properties of the sine and related functions are included in any standard trigonometry text.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>Print sine of one angle:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.sin(np.pi/2.) 1.0</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Print sines of an array of angles given in degrees:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.sin(np.array((0., 30., 45., 60., 90.)) * np.pi / 180. ) array([ 0. , 0.5 , 0.70710678, 0.8660254 , 1. ])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Plot the sine function:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>import matplotlib.pylab as plt x = np.linspace(-np.pi, np.pi, 201) plt.plot(x, np.sin(x)) plt.xlabel(Angle [rad]) plt.ylabel(sin(x)) plt.axis(tight) plt.show()</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L14648">view source</a></div></div><div class="public anchor" id="var-sinc"><h3>sinc</h3><div class="usage"><code>(sinc &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return the sinc function.</p>
<p>The sinc function is :math:<code>\sin(\pi x)/(\pi x)</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : ndarray  Array (possibly multi-dimensional) of values for which to to  calculate <code>sinc(x)</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  <code>sinc(x)</code>, which has the same shape as the input.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p><code>sinc(0)</code> is the limit value 1.</p>
<p>The name sinc is short for sine cardinal or sinus cardinalis.</p>
<p>The sinc function is used in various signal processing applications, including in anti-aliasing, in the construction of a Lanczos resampling filter, and in interpolation.</p>
<p>For bandlimited interpolation of discrete-time signals, the ideal interpolation kernel is proportional to the sinc function.</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [1] Weisstein, Eric W. Sinc Function. From MathWorldA Wolfram Web  Resource. <a href="http://mathworld.wolfram.com/SincFunction.html">http://mathworld.wolfram.com/SincFunction.html</a> .. [2] Wikipedia, Sinc function,  <a href="https://en.wikipedia.org/wiki/Sinc_function">https://en.wikipedia.org/wiki/Sinc_function</a></p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>import matplotlib.pyplot as plt x = np.linspace(-4, 4, 41) np.sinc(x)  array([-3.89804309e-17, -4.92362781e-02, -8.40918587e-02, # may vary  -8.90384387e-02, -5.84680802e-02, 3.89804309e-17,  6.68206631e-02, 1.16434881e-01, 1.26137788e-01,  8.50444803e-02, -3.89804309e-17, -1.03943254e-01,  -1.89206682e-01, -2.16236208e-01, -1.55914881e-01,  3.89804309e-17, 2.33872321e-01, 5.04551152e-01,  7.56826729e-01, 9.35489284e-01, 1.00000000e+00,  9.35489284e-01, 7.56826729e-01, 5.04551152e-01,  2.33872321e-01, 3.89804309e-17, -1.55914881e-01,  -2.16236208e-01, -1.89206682e-01, -1.03943254e-01,  -3.89804309e-17, 8.50444803e-02, 1.26137788e-01,  1.16434881e-01, 6.68206631e-02, 3.89804309e-17,  -5.84680802e-02, -8.90384387e-02, -8.40918587e-02,  -4.92362781e-02, -3.89804309e-17])</p>
      <p>plt.plot(x, np.sinc(x)) [&lt;matplotlib.lines.Line2D object at 0x&gt;] plt.title(Sinc Function) Text(0.5, 1.0, Sinc Function) plt.ylabel(Amplitude) Text(0, 0.5, Amplitude) plt.xlabel(X) Text(0.5, 0, X) plt.show()</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L17565">view source</a></div></div><div class="public anchor" id="var-single"><h3>single</h3><div class="usage"><code>(single self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Single-precision floating-point number type, compatible with C <code>float</code>. Character code: <code>'f'</code>. Canonical name: <code>np.single</code>. Alias <em>on this platform</em>: <code>np.float32</code>: 32-bit-precision floating-point number type: sign bit, 8 bits exponent, 23 bits mantissa.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L22984">view source</a></div></div><div class="public anchor" id="var-singlecomplex"><h3>singlecomplex</h3><div class="usage"><code>(singlecomplex self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Complex number type composed of two single-precision floating-point numbers. Character code: <code>'F'</code>. Canonical name: <code>np.csingle</code>. Alias: <code>np.singlecomplex</code>. Alias <em>on this platform</em>: <code>np.complex64</code>: Complex number type composed of 2 32-bit-precision floating-point numbers.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L24359">view source</a></div></div><div class="public anchor" id="var-sinh"><h3>sinh</h3><div class="usage"><code>(sinh self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>sinh(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Hyperbolic sine, element-wise.</p>
<p>Equivalent to <code>1/2 * (np.exp(x) - np.exp(-x))</code> or <code>-1j * np.sin(1j*x)</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Input array. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray  The corresponding hyperbolic sine values.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>If <code>out</code> is provided, the function writes the result into it, and returns a reference to <code>out</code>. (See Examples)</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions. New York, NY: Dover, 1972, pg. 83.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.sinh(0) 0.0 np.sinh(np.pi*1j/2) 1j np.sinh(np.pi*1j) # (exact value is 0) 1.2246063538223773e-016j</p>
      <h1><a href="#discrepancy-due-to-vagaries-of-floating-point-arithmetic-" name="discrepancy-due-to-vagaries-of-floating-point-arithmetic-"></a>Discrepancy due to vagaries of floating point arithmetic.</h1>
      <h1><a href="#example-of-providing-the-optional-output-parameter" name="example-of-providing-the-optional-output-parameter"></a>Example of providing the optional output parameter</h1>
      <p>out1 = np.array([0], dtype=d) out2 = np.sinh([0.1], out1) out2 is out1 True</p>
      <h1><a href="#example-of-valueerror-due-to-provision-of-shape-mis-matched" name="example-of-valueerror-due-to-provision-of-shape-mis-matched"></a>Example of ValueError due to provision of shape mis-matched <code>out</code></h1>
      <p>np.sinh(np.zeros((3,3)),np.zeros((2,2))) Traceback (most recent call last):  File <stdin>, line 1, in <module> ValueError: operands could not be broadcast together with shapes (3,3) (2,2)</module></stdin></p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L24394">view source</a></div></div><div class="public anchor" id="var-size"><h3>size</h3><div class="usage"><code>(size &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return the number of elements along a given axis.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input data. axis : int, optional  Axis along which the elements are counted. By default, give  the total number of elements.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>element_count : int  Number of elements along the specified axis.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>shape : dimensions of array ndarray.shape : dimensions of array ndarray.size : number of elements in array</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array(<a href="null">1,2,3],[4,5,6</a>) np.size(a) 6 np.size(a,1) 3 np.size(a,0) 2</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L23777">view source</a></div></div><div class="public anchor" id="var-sometrue"><h3>sometrue</h3><div class="usage"><code>(sometrue &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Check whether some values are true.</p>
<p>Refer to <code>any</code> for full documentation.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>any : equivalent function; see for details.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L24345">view source</a></div></div><div class="public anchor" id="var-sort"><h3>sort</h3><div class="usage"><code>(sort &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return a sorted copy of an array.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Array to be sorted. axis : int or None, optional  Axis along which to sort. If None, the array is flattened before  sorting. The default is -1, which sorts along the last axis. kind : {quicksort, mergesort, heapsort, stable}, optional  Sorting algorithm. The default is quicksort. Note that both stable  and mergesort use timsort or radix sort under the covers and, in general,  the actual implementation will vary with data type. The mergesort option  is retained for backwards compatibility.</p>
<pre><code>.. versionchanged:: 1.15.0.
   The 'stable' option was added.
</code></pre>
<p>order : str or list of str, optional  When <code>a</code> is an array with fields defined, this argument specifies  which fields to compare first, second, etc. A single field can  be specified as a string, and not all fields need be specified,  but unspecified fields will still be used, in the order in which  they come up in the dtype, to break ties.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>sorted_array : ndarray  Array of the same type and shape as <code>a</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>ndarray.sort : Method to sort an array in-place. argsort : Indirect sort. lexsort : Indirect stable sort on multiple keys. searchsorted : Find elements in a sorted array. partition : Partial sort.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The various sorting algorithms are characterized by their average speed, worst case performance, work space size, and whether they are stable. A stable sort keeps items with the same key in the same relative order. The four algorithms implemented in NumPy have the following properties:</p>
<p>=========== ======= ============= ============ ========  kind speed worst case work space stable =========== ======= ============= ============ ======== quicksort 1 O(n^2) 0 no heapsort 3 O(n*log(n)) 0 no mergesort 2 O(n*log(n)) ~n/2 yes timsort 2 O(n*log(n)) ~n/2 yes =========== ======= ============= ============ ========</p>
<p>.. note:: The datatype determines which of mergesort or timsort  is actually used, even if mergesort is specified. User selection  at a finer scale is not currently available.</p>
<p>All the sort algorithms make temporary copies of the data when sorting along any but the last axis. Consequently, sorting along the last axis is faster and uses less space than sorting along any other axis.</p>
<p>The sort order for complex numbers is lexicographic. If both the real and imaginary parts are non-nan then the order is determined by the real parts except when they are equal, in which case the order is determined by the imaginary parts.</p>
<p>Previous to numpy 1.4.0 sorting real and complex arrays containing nan values led to undefined behaviour. In numpy versions &gt;= 1.4.0 nan values are sorted to the end. The extended sort order is:</p>
<ul>
  <li>Real: [R, nan]</li>
  <li>Complex: [R + Rj, R + nanj, nan + Rj, nan + nanj]</li>
</ul>
<p>where R is a non-nan real value. Complex values with the same nan placements are sorted according to the non-nan part if it exists. Non-nan values are sorted as before.</p>
<p>.. versionadded:: 1.12.0</p>
<p>quicksort has been changed to <code>introsort &lt;https://en.wikipedia.org/wiki/Introsort&gt;</code>_. When sorting does not make enough progress it switches to <code>heapsort &lt;https://en.wikipedia.org/wiki/Heapsort&gt;</code>_. This implementation makes quicksort O(n*log(n)) in the worst case.</p>
<p>stable automatically chooses the best stable sorting algorithm for the data type being sorted. It, along with mergesort is currently mapped to <code>timsort &lt;https://en.wikipedia.org/wiki/Timsort&gt;</code>_ or <code>radix sort &lt;https://en.wikipedia.org/wiki/Radix_sort&gt;</code>_ depending on the data type. API forward compatibility currently limits the ability to select the implementation and it is hardwired for the different data types.</p>
<p>.. versionadded:: 1.17.0</p>
<p>Timsort is added for better performance on already or nearly sorted data. On random data timsort is almost identical to mergesort. It is now used for stable sort while quicksort is still the default sort if none is chosen. For timsort details, refer to <code>CPython listsort.txt &lt;https://github.com/python/cpython/blob/3.7/Objects/listsort.txt&gt;</code>_. mergesort and stable are mapped to radix sort for integer data types. Radix sort is an O(n) sort instead of O(n log n).</p>
<p>.. versionchanged:: 1.17.0</p>
<p>NaT now sorts to the end of arrays for consistency with NaN.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array(<a href="null">1,4],[3,1</a>) np.sort(a) # sort along the last axis array(<a href="null">1, 4],
       [1, 3</a>) np.sort(a, axis=None) # sort the flattened array array([1, 1, 3, 4]) np.sort(a, axis=0) # sort along the first axis array(<a href="null">1, 1],
       [3, 4</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Use the <code>order</code> keyword to specify a field to use when sorting a structured array:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>dtype = [(name, S10), (height, float), (age, int)] values = [(Arthur, 1.8, 41), (Lancelot, 1.9, 38),  (Galahad, 1.7, 38)] a = np.array(values, dtype=dtype) # create a structured array np.sort(a, order=height) # doctest: +SKIP array([(Galahad, 1.7, 38), (Arthur, 1.8, 41),  (Lancelot, 1.8999999999999999, 38)],  dtype=[(name, |S10), (height, &lt;f8), (age, &lt;i4)])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Sort by age, then height if ages are equal:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.sort(a, order=[age, height]) # doctest: +SKIP array([(Galahad, 1.7, 38), (Lancelot, 1.8999999999999999, 38),  (Arthur, 1.8, 41)],  dtype=[(name, |S10), (height, &lt;f8), (age, &lt;i4)])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L12643">view source</a></div></div><div class="public anchor" id="var-sort_complex"><h3>sort_complex</h3><div class="usage"><code>(sort_complex &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Sort a complex array using the real part first, then the imaginary part.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input array</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : complex ndarray  Always returns a sorted complex array.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.sort_complex([5, 3, 6, 2, 1]) array([1.+0.j, 2.+0.j, 3.+0.j, 5.+0.j, 6.+0.j])</p>
      <p>np.sort_complex([1 + 2j, 2 - 1j, 3 - 2j, 3 - 3j, 3 + 5j]) array([1.+2.j, 2.-1.j, 3.-3.j, 3.-2.j, 3.+5.j])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L20437">view source</a></div></div><div class="public anchor" id="var-source"><h3>source</h3><div class="usage"><code>(source object &amp; [{output :output}])</code><code>(source object)</code></div><div class="doc"><div class="markdown"><p>Print or write to a file the source code for a NumPy object.</p>
<p>The source code is only returned for objects written in Python. Many functions and classes are defined in C and will therefore not return useful information.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>object : numpy object  Input object. This can be any object (function, class, module,  ). output : file object, optional  If <code>output</code> not supplied then source code is printed to screen  (sys.stdout). File object must be created with either write w or  append a modes.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>lookfor, info</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.source(np.interp) #doctest: +SKIP In file: /usr/lib/python2.6/dist-packages/numpy/lib/function_base.py def interp(x, xp, fp, left=None, right=None):  "". (full docstring printed)""  if isinstance(x, (float, int, number)):  return compiled_interp([x], xp, fp, left, right).item()  else:  return compiled_interp(x, xp, fp, left, right)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The source code is only returned for objects written in Python.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.source(np.array) #doctest: +SKIP Not available for this object.</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L20351">view source</a></div></div><div class="public anchor" id="var-spacing"><h3>spacing</h3><div class="usage"><code>(spacing self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>spacing(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Return the distance between x and the nearest adjacent number.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Values to find the spacing of. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray or scalar  The spacing of values of <code>x</code>.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>It can be considered as a generalization of EPS: <code>spacing(np.float64(1)) == np.finfo(np.float64).eps</code>, and there should not be any representable number between <code>x + spacing(x)</code> and x for any finite x.</p>
<p>Spacing of +- inf and NaN is NaN.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.spacing(1) == np.finfo(np.float64).eps True</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L2491">view source</a></div></div><div class="public anchor" id="var-split"><h3>split</h3><div class="usage"><code>(split &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Split an array into multiple sub-arrays as views into <code>ary</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>ary : ndarray  Array to be divided into sub-arrays. indices_or_sections : int or 1-D array  If <code>indices_or_sections</code> is an integer, N, the array will be divided  into N equal arrays along <code>axis</code>. If such a split is not possible,  an error is raised.</p>
<pre><code>If `indices_or_sections` is a 1-D array of sorted integers, the entries
indicate where along `axis` the array is split.  For example,
``[2, 3]`` would, for ``axis=0``, result in

  - ary[:2]
  - ary[2:3]
  - ary[3:]

If an index exceeds the dimension of the array along `axis`,
an empty sub-array is returned correspondingly.
</code></pre>
<p>axis : int, optional  The axis along which to split, default is 0.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>sub-arrays : list of ndarrays  A list of sub-arrays as views into <code>ary</code>.</p>
<h2><a href="#raises" name="raises"></a>Raises</h2>
<p>ValueError  If <code>indices_or_sections</code> is given as an integer, but  a split does not result in equal division.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>array_split : Split an array into multiple sub-arrays of equal or  near-equal size. Does not raise an exception if  an equal division cannot be made. hsplit : Split array into multiple sub-arrays horizontally (column-wise). vsplit : Split array into multiple sub-arrays vertically (row wise). dsplit : Split array into multiple sub-arrays along the 3rd axis (depth). concatenate : Join a sequence of arrays along an existing axis. stack : Join a sequence of arrays along a new axis. hstack : Stack arrays in sequence horizontally (column wise). vstack : Stack arrays in sequence vertically (row wise). dstack : Stack arrays in sequence depth wise (along third dimension).</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.arange(9.0) np.split(x, 3) [array([0., 1., 2.]), array([3., 4., 5.]), array([6., 7., 8.])]</p>
      <p>x = np.arange(8.0) np.split(x, [3, 5, 6, 10]) [array([0., 1., 2.]),  array([3., 4.]),  array([5.]),  array([6., 7.]),  array([], dtype=float64)]</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L17212">view source</a></div></div><div class="public anchor" id="var-sqrt"><h3>sqrt</h3><div class="usage"><code>(sqrt self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>sqrt(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Return the non-negative square-root of an array, element-wise.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  The values whose square-roots are required. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray  An array of the same shape as <code>x</code>, containing the positive  square-root of each element in <code>x</code>. If any element in <code>x</code> is  complex, a complex array is returned (and the square-roots of  negative reals are calculated). If all of the elements in <code>x</code>  are real, so is <code>y</code>, with negative elements returning <code>nan</code>.  If <code>out</code> was provided, <code>y</code> is a reference to it.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>lib.scimath.sqrt  A version which returns complex numbers when given negative reals.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p><em>sqrt</em> hasconsistent with common conventionas its branch cut the real interval [<code>-inf</code>, 0), and is continuous from above on it. A branch cut is a curve in the complex plane across which a given complex function fails to be continuous.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.sqrt([1,4,9]) array([ 1., 2., 3.])</p>
      <p>np.sqrt([4, -1, -3+4J]) array([ 2.+0.j, 0.+1.j, 1.+2.j])</p>
      <p>np.sqrt([4, -1, np.inf]) array([ 2., nan, inf])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L18184">view source</a></div></div><div class="public anchor" id="var-square"><h3>square</h3><div class="usage"><code>(square self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>square(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Return the element-wise square of the input.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Input data. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray or scalar  Element-wise <code>x*x</code>, of the same shape and dtype as <code>x</code>.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>numpy.linalg.matrix_power sqrt power</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.square([-1j, 1]) array([-1.-0.j, 1.+0.j])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L20252">view source</a></div></div><div class="public anchor" id="var-squeeze"><h3>squeeze</h3><div class="usage"><code>(squeeze &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Remove single-dimensional entries from the shape of an array.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input data. axis : None or int or tuple of ints, optional  .. versionadded:: 1.7.0</p>
<pre><code>Selects a subset of the single-dimensional entries in the
shape. If an axis is selected with shape entry greater than
one, an error is raised.
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>squeezed : ndarray  The input array, but with all or a subset of the  dimensions of length 1 removed. This is always <code>a</code> itself  or a view into <code>a</code>.</p>
<h2><a href="#raises" name="raises"></a>Raises</h2>
<p>ValueError  If <code>axis</code> is not None, and an axis being squeezed is not of length 1</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>expand_dims : The inverse operation, adding singleton dimensions reshape : Insert, remove, and combine dimensions, and resize existing ones</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.array(<a href="null">[0], [1], [2</a>]) x.shape (1, 3, 1) np.squeeze(x).shape (3,) np.squeeze(x, axis=0).shape (3, 1) np.squeeze(x, axis=1).shape Traceback (most recent call last):  ValueError: cannot select an axis to squeeze out which has size not equal to one np.squeeze(x, axis=2).shape (1, 3)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L3628">view source</a></div></div><div class="public anchor" id="var-stack"><h3>stack</h3><div class="usage"><code>(stack &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Join a sequence of arrays along a new axis.</p>
<p>The <code>axis</code> parameter specifies the index of the new axis in the dimensions of the result. For example, if <code>axis=0</code> it will be the first dimension and if <code>axis=-1</code> it will be the last dimension.</p>
<p>.. versionadded:: 1.10.0</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>arrays : sequence of array_like  Each array must have the same shape.</p>
<p>axis : int, optional  The axis in the result array along which the input arrays are stacked.</p>
<p>out : ndarray, optional  If provided, the destination to place the result. The shape must be  correct, matching that of what stack would have returned if no  out argument were specified.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>stacked : ndarray  The stacked array has one more dimension than the input arrays.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>concatenate : Join a sequence of arrays along an existing axis. split : Split array into a list of multiple sub-arrays of equal size. block : Assemble arrays from blocks.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>arrays = [np.random.randn(3, 4) for _ in range(10)] np.stack(arrays, axis=0).shape (10, 3, 4)</p>
      <p>np.stack(arrays, axis=1).shape (3, 10, 4)</p>
      <p>np.stack(arrays, axis=2).shape (3, 4, 10)</p>
      <p>a = np.array([1, 2, 3]) b = np.array([2, 3, 4]) np.stack((a, b)) array(<a href="null">1, 2, 3],
       [2, 3, 4</a>)</p>
      <p>np.stack((a, b), axis=-1) array(<a href="null">1, 2],
       [2, 3],
       [3, 4</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L27919">view source</a></div></div><div class="public anchor" id="var-std"><h3>std</h3><div class="usage"><code>(std &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Compute the standard deviation along the specified axis.</p>
<p>Returns the standard deviation, a measure of the spread of a distribution, of the array elements. The standard deviation is computed for the flattened array by default, otherwise over the specified axis.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Calculate the standard deviation of these values. axis : None or int or tuple of ints, optional  Axis or axes along which the standard deviation is computed. The  default is to compute the standard deviation of the flattened array.</p>
<pre><code>.. versionadded:: 1.7.0

If this is a tuple of ints, a standard deviation is performed over
multiple axes, instead of a single axis or all the axes as before.
</code></pre>
<p>dtype : dtype, optional  Type to use in computing the standard deviation. For arrays of  integer type the default is float64, for arrays of float types it is  the same as the array type. out : ndarray, optional  Alternative output array in which to place the result. It must have  the same shape as the expected output but the type (of the calculated  values) will be cast if necessary. ddof : int, optional  Means Delta Degrees of Freedom. The divisor used in calculations  is <code>N - ddof</code>, where <code>N</code> represents the number of elements.  By default <code>ddof</code> is zero. keepdims : bool, optional  If this is set to True, the axes which are reduced are left  in the result as dimensions with size one. With this option,  the result will broadcast correctly against the input array.</p>
<pre><code>If the default value is passed, then `keepdims` will not be
passed through to the `std` method of sub-classes of
`ndarray`, however any non-default value will be.  If the
sub-class' method does not implement `keepdims` any
exceptions will be raised.
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>standard_deviation : ndarray, see dtype parameter above.  If <code>out</code> is None, return a new array containing the standard deviation,  otherwise return a reference to the output array.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>var, mean, nanmean, nanstd, nanvar ufuncs-output-type</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The standard deviation is the square root of the average of the squared deviations from the mean, i.e., <code>std = sqrt(mean(abs(x - x.mean())**2))</code>.</p>
<p>The average squared deviation is normally calculated as <code>x.sum() / N</code>, where <code>N = len(x)</code>. If, however, <code>ddof</code> is specified, the divisor <code>N - ddof</code> is used instead. In standard statistical practice, <code>ddof=1</code> provides an unbiased estimator of the variance of the infinite population. <code>ddof=0</code> provides a maximum likelihood estimate of the variance for normally distributed variables. The standard deviation computed in this function is the square root of the estimated variance, so even with <code>ddof=1</code>, it will not be an unbiased estimate of the standard deviation per se.</p>
<p>Note that, for complex numbers, <code>std</code> takes the absolute value before squaring, so that the result is always real and nonnegative.</p>
<p>For floating-point input, the <em>std</em> is computed using the same precision the input has. Depending on the input data, this can cause the results to be inaccurate, especially for float32 (see example below). Specifying a higher-accuracy accumulator using the <code>dtype</code> keyword can alleviate this issue.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array(<a href="null">1, 2], [3, 4</a>) np.std(a) 1.1180339887498949 # may vary np.std(a, axis=0) array([1., 1.]) np.std(a, axis=1) array([0.5, 0.5])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>In single precision, std() can be inaccurate:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.zeros((2, 512*512), dtype=np.float32) a[0, :] = 1.0 a[1, :] = 0.1 np.std(a) 0.45000005</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Computing the standard deviation in float64 is more accurate:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.std(a, dtype=np.float64) 0.44999999925494177 # may vary</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L3383">view source</a></div></div><div class="public anchor" id="var-str"><h3>str</h3><div class="usage"><code>(str self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>str(object=) -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.__str__() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to strict.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L7592">view source</a></div></div><div class="public anchor" id="var-str0"><h3>str0</h3><div class="usage"><code>(str0 self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L17522">view source</a></div></div><div class="public anchor" id="var-str_"><h3>str_</h3><div class="usage"><code>(str_ self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L24356">view source</a></div></div><div class="public anchor" id="var-string_"><h3>string_</h3><div class="usage"><code>(string_ self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L18536">view source</a></div></div><div class="public anchor" id="var-subtract"><h3>subtract</h3><div class="usage"><code>(subtract self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>subtract(x1, x2, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Subtract arguments, element-wise.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x1, x2 : array_like  The arrays to be subtracted from each other. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output). out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray  The difference of <code>x1</code> and <code>x2</code>, element-wise.  This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Equivalent to <code>x1 - x2</code> in terms of array broadcasting.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.subtract(1.0, 4.0) -3.0</p>
      <p>x1 = np.arange(9.0).reshape((3, 3)) x2 = np.arange(3.0) np.subtract(x1, x2) array(<a href="null"> 0.,  0.,  0.],
       [ 3.,  3.,  3.],
       [ 6.,  6.,  6.</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L16748">view source</a></div></div><div class="public anchor" id="var-sum"><h3>sum</h3><div class="usage"><code>(sum &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Sum of array elements over a given axis.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Elements to sum. axis : None or int or tuple of ints, optional  Axis or axes along which a sum is performed. The default,  axis=None, will sum all of the elements of the input array. If  axis is negative it counts from the last to the first axis.</p>
<pre><code>.. versionadded:: 1.7.0

If axis is a tuple of ints, a sum is performed on all of the axes
specified in the tuple instead of a single axis or all the axes as
before.
</code></pre>
<p>dtype : dtype, optional  The type of the returned array and of the accumulator in which the  elements are summed. The dtype of <code>a</code> is used by default unless <code>a</code>  has an integer dtype of less precision than the default platform  integer. In that case, if <code>a</code> is signed then the platform integer  is used while if <code>a</code> is unsigned then an unsigned integer of the  same precision as the platform integer is used. out : ndarray, optional  Alternative output array in which to place the result. It must have  the same shape as the expected output, but the type of the output  values will be cast if necessary. keepdims : bool, optional  If this is set to True, the axes which are reduced are left  in the result as dimensions with size one. With this option,  the result will broadcast correctly against the input array.</p>
<pre><code>If the default value is passed, then `keepdims` will not be
passed through to the `sum` method of sub-classes of
`ndarray`, however any non-default value will be.  If the
sub-class' method does not implement `keepdims` any
exceptions will be raised.
</code></pre>
<p>initial : scalar, optional  Starting value for the sum. See <code>~numpy.ufunc.reduce</code> for details.</p>
<pre><code>.. versionadded:: 1.15.0
</code></pre>
<p>where : array_like of bool, optional  Elements to include in the sum. See <code>~numpy.ufunc.reduce</code> for details.</p>
<pre><code>.. versionadded:: 1.17.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>sum_along_axis : ndarray  An array with the same shape as <code>a</code>, with the specified  axis removed. If <code>a</code> is a 0-d array, or if <code>axis</code> is None, a scalar  is returned. If an output array is specified, a reference to  <code>out</code> is returned.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>ndarray.sum : Equivalent method.</p>
<p>add.reduce : Equivalent functionality of <code>add</code>.</p>
<p>cumsum : Cumulative sum of array elements.</p>
<p>trapz : Integration of array values using the composite trapezoidal rule.</p>
<p>mean, average</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Arithmetic is modular when using integer types, and no error is raised on overflow.</p>
<p>The sum of an empty array is the neutral element 0:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.sum([]) 0.0</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>For floating point numbers the numerical precision of sum (and <code>np.add.reduce</code>) is in general limited by directly adding each number individually to the result causing rounding errors in every step. However, often numpy will use a numerically better approach (partial pairwise summation) leading to improved precision in many use-cases. This improved precision is always provided when no <code>axis</code> is given. When <code>axis</code> is given, it will depend on which axis is summed. Technically, to provide the best speed possible, the improved precision is only used when the summation is along the fast axis in memory. Note that the exact precision may vary depending on other parameters. In contrast to NumPy, Pythons <code>math.fsum</code> function uses a slower but more precise approach to summation. Especially when summing a large number of lower precision floating point numbers, such as <code>float32</code>, numerical errors can become significant. In such cases it can be advisable to use <code>dtype="float64"</code> to use a higher precision for the output.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.sum([0.5, 1.5]) 2.0 np.sum([0.5, 0.7, 0.2, 1.5], dtype=np.int32) 1 np.sum(<a href="null">0, 1], [0, 5</a>) 6 np.sum(<a href="null">0, 1], [0, 5</a>, axis=0) array([0, 6]) np.sum(<a href="null">0, 1], [0, 5</a>, axis=1) array([1, 5]) np.sum(<a href="null">0, 1], [np.nan, 5</a>, where=[False, True], axis=1) array([1., 5.])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>If the accumulator is too small, overflow occurs:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.ones(128, dtype=np.int8).sum(dtype=np.int8) -128</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>You can also start the sum with a value other than zero:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.sum([10], initial=5) 15</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L7470">view source</a></div></div><div class="public anchor" id="var-swapaxes"><h3>swapaxes</h3><div class="usage"><code>(swapaxes &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Interchange two axes of an array.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input array. axis1 : int  First axis. axis2 : int  Second axis.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>a_swapped : ndarray  For NumPy &gt;= 1.10.0, if <code>a</code> is an ndarray, then a view of <code>a</code> is  returned; otherwise a new array is created. For earlier NumPy  versions a view of <code>a</code> is returned only if the order of the  axes is changed, otherwise the input array is returned.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.array(<a href="null">1,2,3</a>) np.swapaxes(x,0,1) array(<a href="null">1],
       [2],
       [3</a>)</p>
      <p>x = np.array(<a href="null">[0,1],[2,3</a>,<a href="null">4,5],[6,7</a>]) x array(<a href="null">[0, 1],
        [2, 3</a>,  <a href="null">4, 5],
        [6, 7</a>])</p>
      <p>np.swapaxes(x,0,2) array(<a href="null">[0, 4],
        [2, 6</a>,  <a href="null">1, 5],
        [3, 7</a>])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L20391">view source</a></div></div><div class="public anchor" id="var-sys"><h3>sys</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>This module provides access to some objects used or maintained by the interpreter and to functions that interact strongly with the interpreter.</p>
<p>Dynamic objects:</p>
<p>argv  command line arguments; argv[0] is the script pathname if known path  module search path; path[0] is the script directory, else  modules  dictionary of loaded modules</p>
<p>displayhook  called to show results in an interactive session excepthook  called to handle any uncaught exception other than SystemExit  To customize printing in an interactive session or to install a custom  top-level exception handler, assign other functions to replace these.</p>
<p>stdin  standard input file object; used by input() stdout  standard output file object; used by print() stderr  standard error object; used for error messages  By assigning other file objects (or objects that behave like files)  to these, it is possible to redirect all of the interpreters I/O.</p>
<p>last_type  type of last uncaught exception last_value  value of last uncaught exception last_traceback  traceback of last uncaught exception  These three are only available in an interactive session after a  traceback has been printed.</p>
<p>Static objects:</p>
<p>builtin_module_names  tuple of module names built into this interpreter copyright  copyright notice pertaining to this interpreter exec_prefix  prefix used to find the machine-specific Python library executable  absolute path of the executable binary of the Python interpreter float_info  a named tuple with information about the float implementation. float_repr_style  string indicating the style of repr() output for floats hash_info  a named tuple with information about the hash algorithm. hexversion  version information encoded as a single integer implementation  Python implementation information. int_info  a named tuple with information about the int implementation. maxsize  the largest supported length of containers. maxunicode  the value of the largest Unicode code point platform  platform identifier prefix  prefix used to find the Python library thread_info  a named tuple with information about the thread implementation. version  the version of this interpreter as a string version_info  version information as a named tuple <strong>stdin</strong>  the original stdin; dont touch! <strong>stdout</strong>  the original stdout; dont touch! <strong>stderr</strong>  the original stderr; dont touch! <strong>displayhook</strong>  the original displayhook; dont touch! <strong>excepthook</strong>  the original excepthook; dont touch!</p>
<p>Functions:</p>
<p>displayhook()  print an object to the screen, and save it in builtins._ excepthook()  print an exception and its traceback to sys.stderr exc_info()  return thread-safe information about the current exception exit()  exit the interpreter by raising SystemExit getdlopenflags()  returns flags to be used for dlopen() calls getprofile()  get the global profiling function getrefcount()  return the reference count for an object (plus one :-) getrecursionlimit()  return the max recursion depth for the interpreter getsizeof()  return the size of an object in bytes gettrace()  get the global debug tracing function setcheckinterval()  control how often the interpreter checks for events setdlopenflags()  set the flags to be used for dlopen() calls setprofile()  set the global profiling function setrecursionlimit()  set the max recursion depth for the interpreter settrace()  set the global debug tracing function</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L23485">view source</a></div></div><div class="public anchor" id="var-take"><h3>take</h3><div class="usage"><code>(take &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Take elements from an array along an axis.</p>
<p>When axis is not None, this function does the same thing as fancy indexing (indexing arrays using arrays); however, it can be easier to use if you need elements along a given axis. A call such as <code>np.take(arr, indices, axis=3)</code> is equivalent to <code>arr[:,:,:,indices,...]</code>.</p>
<p>Explained without fancy indexing, this is equivalent to the following use of <code>ndindex</code>, which sets each of <code>ii</code>, <code>jj</code>, and <code>kk</code> to a tuple of indices::</p>
<pre><code>Ni, Nk = a.shape[:axis], a.shape[axis+1:]
Nj = indices.shape
for ii in ndindex(Ni):
    for jj in ndindex(Nj):
        for kk in ndindex(Nk):
            out[ii + jj + kk] = a[ii + (indices[jj],) + kk]
</code></pre>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like (Ni, M, Nk)  The source array. indices : array_like (Nj)  The indices of the values to extract.</p>
<pre><code>.. versionadded:: 1.8.0

Also allow scalars for indices.
</code></pre>
<p>axis : int, optional  The axis over which to select values. By default, the flattened  input array is used. out : ndarray, optional (Ni, Nj, Nk)  If provided, the result will be placed in this array. It should  be of the appropriate shape and dtype. Note that <code>out</code> is always  buffered if <code>mode='raise'</code>; use other modes for better performance. mode : {raise, wrap, clip}, optional  Specifies how out-of-bounds indices will behave.</p>
<pre><code>* 'raise' -- raise an error (default)
* 'wrap' -- wrap around
* 'clip' -- clip to the range

'clip' mode means that all indices that are too large are replaced
by the index that addresses the last element along that axis. Note
that this disables indexing with negative numbers.
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray (Ni, Nj, Nk)  The returned array has the same type as <code>a</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>compress : Take elements using a boolean mask ndarray.take : equivalent method take_along_axis : Take elements by matching the array and the index arrays</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>By eliminating the inner loop in the description above, and using <code>s_</code> to build simple slice objects, <code>take</code> can be expressed in terms of applying fancy indexing to each 1-d slice::</p>
<pre><code>Ni, Nk = a.shape[:axis], a.shape[axis+1:]
for ii in ndindex(Ni):
    for kk in ndindex(Nj):
        out[ii + s_[...,] + kk] = a[ii + s_[:,] + kk][indices]
</code></pre>
<p>For this reason, it is equivalent to (but faster than) the following use of <code>apply_along_axis</code>::</p>
<pre><code>out = np.apply_along_axis(lambda a_1d: a_1d[indices], axis, a)
</code></pre>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = [4, 3, 5, 7, 6, 8] indices = [0, 1, 4] np.take(a, indices) array([4, 3, 6])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>In this example if <code>a</code> is an ndarray, fancy indexing can be used.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array(a) a[indices] array([4, 3, 6])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>If <code>indices</code> is not one dimensional, the output also has these dimensions.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.take(a, <a href="null">0, 1], [2, 3</a>) array(<a href="null">4, 3],
       [5, 7</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L11788">view source</a></div></div><div class="public anchor" id="var-take_along_axis"><h3>take_along_axis</h3><div class="usage"><code>(take_along_axis &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Take values from the input array by matching 1d index and data slices.</p>
<p>This iterates over matching 1d slices oriented along the specified axis in the index and data arrays, and uses the former to look up values in the latter. These slices can be different lengths.</p>
<p>Functions returning an index along an axis, like <code>argsort</code> and <code>argpartition</code>, produce suitable indices for this function.</p>
<p>.. versionadded:: 1.15.0</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>arr: ndarray (Ni, M, Nk)  Source array indices: ndarray (Ni, J, Nk)  Indices to take along each 1d slice of <code>arr</code>. This must match the  dimension of arr, but dimensions Ni and Nj only need to broadcast  against <code>arr</code>. axis: int  The axis to take 1d slices along. If axis is None, the input array is  treated as if it had first been flattened to 1d, for consistency with  <code>sort</code> and <code>argsort</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out: ndarray (Ni, J, Nk)  The indexed result.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>This is equivalent to (but faster than) the following use of <code>ndindex</code> and <code>s_</code>, which sets each of <code>ii</code> and <code>kk</code> to a tuple of indices::</p>
<pre><code>Ni, M, Nk = a.shape[:axis], a.shape[axis], a.shape[axis+1:]
J = indices.shape[axis]  # Need not equal M
out = np.empty(Ni + (J,) + Nk)

for ii in ndindex(Ni):
    for kk in ndindex(Nk):
        a_1d       = a      [ii + s_[:,] + kk]
        indices_1d = indices[ii + s_[:,] + kk]
        out_1d     = out    [ii + s_[:,] + kk]
        for j in range(J):
            out_1d[j] = a_1d[indices_1d[j]]
</code></pre>
<p>Equivalently, eliminating the inner loop, the last two lines would be::</p>
<pre><code>        out_1d[:] = a_1d[indices_1d]
</code></pre>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>take : Take along an axis, using the same indices for every 1d slice put_along_axis :  Put values into the destination array by matching 1d index and data slices</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>For this sample array</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array(<a href="null">10, 30, 20], [60, 40, 50</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>We can sort either by using sort directly, or argsort and this function</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.sort(a, axis=1) array(<a href="null">10, 20, 30],
       [40, 50, 60</a>) ai = np.argsort(a, axis=1); ai array(<a href="null">0, 2, 1],
       [1, 2, 0</a>) np.take_along_axis(a, ai, axis=1) array(<a href="null">10, 20, 30],
       [40, 50, 60</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The same works for max and min, if you expand the dimensions:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.expand_dims(np.max(a, axis=1), axis=1) array(<a href="null">30],
       [60</a>) ai = np.expand_dims(np.argmax(a, axis=1), axis=1) ai array(<a href="null">1],
       [0</a>) np.take_along_axis(a, ai, axis=1) array(<a href="null">30],
       [60</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>If we want to get the max and min at the same time, we can stack the indices first</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>ai_min = np.expand_dims(np.argmin(a, axis=1), axis=1) ai_max = np.expand_dims(np.argmax(a, axis=1), axis=1) ai = np.concatenate([ai_min, ai_max], axis=1) ai array(<a href="null">0, 1],
       [1, 0</a>) np.take_along_axis(a, ai, axis=1) array(<a href="null">10, 30],
       [40, 60</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L7138">view source</a></div></div><div class="public anchor" id="var-tan"><h3>tan</h3><div class="usage"><code>(tan self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>tan(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Compute tangent element-wise.</p>
<p>Equivalent to <code>np.sin(x)/np.cos(x)</code> element-wise.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Input array. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray  The corresponding tangent values.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>If <code>out</code> is provided, the function writes the result into it, and returns a reference to <code>out</code>. (See Examples)</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions. New York, NY: Dover, 1972.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>from math import pi np.tan(np.array([-pi,pi/2,pi])) array([ 1.22460635e-16, 1.63317787e+16, -1.22460635e-16])</p>
      <h1><a href="#example-of-providing-the-optional-output-parameter-illustrating" name="example-of-providing-the-optional-output-parameter-illustrating"></a>Example of providing the optional output parameter illustrating</h1>
      <h1><a href="#that-what-is-returned-is-a-reference-to-said-parameter" name="that-what-is-returned-is-a-reference-to-said-parameter"></a>that what is returned is a reference to said parameter</h1>
      <p>out1 = np.array([0], dtype=d) out2 = np.cos([0.1], out1) out2 is out1 True</p>
      <h1><a href="#example-of-valueerror-due-to-provision-of-shape-mis-matched" name="example-of-valueerror-due-to-provision-of-shape-mis-matched"></a>Example of ValueError due to provision of shape mis-matched <code>out</code></h1>
      <p>np.cos(np.zeros((3,3)),np.zeros((2,2))) Traceback (most recent call last):  File <stdin>, line 1, in <module> ValueError: operands could not be broadcast together with shapes (3,3) (2,2)</module></stdin></p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L19003">view source</a></div></div><div class="public anchor" id="var-tanh"><h3>tanh</h3><div class="usage"><code>(tanh self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>tanh(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Compute hyperbolic tangent element-wise.</p>
<p>Equivalent to <code>np.sinh(x)/np.cosh(x)</code> or <code>-1j * np.tan(1j*x)</code>.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Input array. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray  The corresponding hyperbolic tangent values.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>If <code>out</code> is provided, the function writes the result into it, and returns a reference to <code>out</code>. (See Examples)</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [1] M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions.  New York, NY: Dover, 1972, pg. 83.  <a href="http://www.math.sfu.ca/~cbm/aands/">http://www.math.sfu.ca/~cbm/aands/</a></p>
<p>.. [2] Wikipedia, Hyperbolic function,  <a href="https://en.wikipedia.org/wiki/Hyperbolic_function">https://en.wikipedia.org/wiki/Hyperbolic_function</a></p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.tanh((0, np.pi*1j, np.pi*1j/2)) array([ 0. +0.00000000e+00j, 0. -1.22460635e-16j, 0. +1.63317787e+16j])</p>
      <h1><a href="#example-of-providing-the-optional-output-parameter-illustrating" name="example-of-providing-the-optional-output-parameter-illustrating"></a>Example of providing the optional output parameter illustrating</h1>
      <h1><a href="#that-what-is-returned-is-a-reference-to-said-parameter" name="that-what-is-returned-is-a-reference-to-said-parameter"></a>that what is returned is a reference to said parameter</h1>
      <p>out1 = np.array([0], dtype=d) out2 = np.tanh([0.1], out1) out2 is out1 True</p>
      <h1><a href="#example-of-valueerror-due-to-provision-of-shape-mis-matched" name="example-of-valueerror-due-to-provision-of-shape-mis-matched"></a>Example of ValueError due to provision of shape mis-matched <code>out</code></h1>
      <p>np.tanh(np.zeros((3,3)),np.zeros((2,2))) Traceback (most recent call last):  File <stdin>, line 1, in <module> ValueError: operands could not be broadcast together with shapes (3,3) (2,2)</module></stdin></p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L26875">view source</a></div></div><div class="public anchor" id="var-tensordot"><h3>tensordot</h3><div class="usage"><code>(tensordot &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Compute tensor dot product along specified axes.</p>
<p>Given two tensors, <code>a</code> and <code>b</code>, and an array_like object containing two array_like objects, <code>(a_axes, b_axes)</code>, sum the products of <code>a</code>s and <code>b</code>s elements (components) over the axes specified by <code>a_axes</code> and <code>b_axes</code>. The third argument can be a single non-negative integer_like scalar, <code>N</code>; if it is such, then the last <code>N</code> dimensions of <code>a</code> and the first <code>N</code> dimensions of <code>b</code> are summed over.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a, b : array_like  Tensors to dot.</p>
<p>axes : int or (2,) array_like  * integer_like  If an int N, sum over the last N axes of <code>a</code> and the first N axes  of <code>b</code> in order. The sizes of the corresponding axes must match.  * (2,) array_like  Or, a list of axes to be summed over, first sequence applying to <code>a</code>,  second to <code>b</code>. Both elements array_like must be of the same length.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>output : ndarray  The tensor dot product of the input.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>dot, einsum</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Three common use cases are:  * <code>axes = 0</code> : tensor product :math:<code>a\otimes b</code>  * <code>axes = 1</code> : tensor dot product :math:<code>a\cdot b</code>  * <code>axes = 2</code> : (default) tensor double contraction :math:<code>a:b</code></p>
<p>When <code>axes</code> is integer_like, the sequence for evaluation will be: first the -Nth axis in <code>a</code> and 0th axis in <code>b</code>, and the -1th axis in <code>a</code> and Nth axis in <code>b</code> last.</p>
<p>When there is more than one axis to sum over - and they are not the last (first) axes of <code>a</code> (<code>b</code>) - the argument <code>axes</code> should consist of two sequences of the same length, with the first axis to sum over given first in both sequences, the second axis second, and so forth.</p>
<p>The shape of the result consists of the non-contracted axes of the first tensor, followed by the non-contracted axes of the second.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>A traditional example:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.arange(60.).reshape(3,4,5) b = np.arange(24.).reshape(4,3,2) c = np.tensordot(a,b, axes=([1,0],[0,1])) c.shape (5, 2) c array(<a href="null">4400., 4730.],
       [4532., 4874.],
       [4664., 5018.],
       [4796., 5162.],
       [4928., 5306.</a>)</p>
      <h1><a href="#a-slower-but-equivalent-way-of-computing-the-same" name="a-slower-but-equivalent-way-of-computing-the-same"></a>A slower but equivalent way of computing the same</h1>
      <p>d = np.zeros((5,2)) for i in range(5):  for j in range(2):  for k in range(3):  for n in range(4):  d[i,j] += a[k,n,i] * b[n,k,j] c == d array(<a href="null"> True,  True],
       [ True,  True],
       [ True,  True],
       [ True,  True],
       [ True,  True</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>An extended example taking advantage of the overloading of + and *:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array(range(1, 9)) a.shape = (2, 2, 2) A = np.array((a, b, c, d), dtype=object) A.shape = (2, 2) a; A array(<a href="null">[1, 2],
        [3, 4</a>,  <a href="null">5, 6],
        [7, 8</a>]) array(<a href="null">'a', 'b'],
       ['c', 'd'</a>, dtype=object)</p>
      <p>np.tensordot(a, A) # third argument default is 2 for double-contraction array([abbcccdddd, aaaaabbbbbbcccccccdddddddd], dtype=object)</p>
      <p>np.tensordot(a, A, 1) array(<a href="null">['acc', 'bdd'],
        ['aaacccc', 'bbbdddd'</a>,  <a href="null">'aaaaacccccc', 'bbbbbdddddd'],
        ['aaaaaaacccccccc', 'bbbbbbbdddddddd'</a>], dtype=object)</p>
      <p>np.tensordot(a, A, 0) # tensor product (result too long to incl.) array(<a href="null">[[['a', 'b'],
          ['c', 'd'</a>,  </p>
      <p>np.tensordot(a, A, (0, 1)) array(<a href="null">['abbbbb', 'cddddd'],
        ['aabbbbbb', 'ccdddddd'</a>,  <a href="null">'aaabbbbbbb', 'cccddddddd'],
        ['aaaabbbbbbbb', 'ccccdddddddd'</a>], dtype=object)</p>
      <p>np.tensordot(a, A, (2, 1)) array(<a href="null">['abb', 'cdd'],
        ['aaabbbb', 'cccdddd'</a>,  <a href="null">'aaaaabbbbbb', 'cccccdddddd'],
        ['aaaaaaabbbbbbbb', 'cccccccdddddddd'</a>], dtype=object)</p>
      <p>np.tensordot(a, A, ((0, 1), (0, 1))) array([abbbcccccddddddd, aabbbbccccccdddddddd], dtype=object)</p>
      <p>np.tensordot(a, A, ((2, 1), (1, 0))) array([acccbbdddd, aaaaacccccccbbbbbbdddddddd], dtype=object)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L19235">view source</a></div></div><div class="public anchor" id="var-test"><h3>test</h3><div class="usage"><code>(test self module_name)</code></div><div class="doc"><div class="markdown"><p>Pytest test runner.</p>
<p>A test function is typically added to a packages <strong>init</strong>.py like so::</p>
<p>from numpy._pytesttester import PytestTester  test = PytestTester(__name__).test  del PytestTester</p>
<p>Calling this test function finds and runs all tests associated with the module and all its sub-modules.</p>
<h2><a href="#attributes" name="attributes"></a>Attributes</h2>
<p>module_name : str  Full path to the package to test.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>module_name : module name  The name of the module to test.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Unlike the previous <code>nose</code>-based implementation, this class is not publicly exposed as it performs some <code>numpy</code>-specific warning suppression.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L27850">view source</a></div></div><div class="public anchor" id="var-tile"><h3>tile</h3><div class="usage"><code>(tile &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Construct an array by repeating A the number of times given by reps.</p>
<p>If <code>reps</code> has length <code>d</code>, the result will have dimension of <code>max(d, A.ndim)</code>.</p>
<p>If <code>A.ndim &lt; d</code>, <code>A</code> is promoted to be d-dimensional by prepending new axes. So a shape (3,) array is promoted to (1, 3) for 2-D replication, or shape (1, 1, 3) for 3-D replication. If this is not the desired behavior, promote <code>A</code> to d-dimensions manually before calling this function.</p>
<p>If <code>A.ndim &gt; d</code>, <code>reps</code> is promoted to <code>A</code>.ndim by pre-pending 1s to it. Thus for an <code>A</code> of shape (2, 3, 4, 5), a <code>reps</code> of (2, 2) is treated as (1, 1, 2, 2).</p>
<p>Note : Although tile may be used for broadcasting, it is strongly recommended to use numpys broadcasting operations and functions.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>A : array_like  The input array. reps : array_like  The number of repetitions of <code>A</code> along each axis.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>c : ndarray  The tiled output array.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>repeat : Repeat elements of an array. broadcast_to : Broadcast an array to a new shape</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array([0, 1, 2]) np.tile(a, 2) array([0, 1, 2, 0, 1, 2]) np.tile(a, (2, 2)) array(<a href="null">0, 1, 2, 0, 1, 2],
       [0, 1, 2, 0, 1, 2</a>) np.tile(a, (2, 1, 2)) array(<a href="null">[0, 1, 2, 0, 1, 2</a>,  <a href="null">0, 1, 2, 0, 1, 2</a>])</p>
      <p>b = np.array(<a href="null">1, 2], [3, 4</a>) np.tile(b, 2) array(<a href="null">1, 2, 1, 2],
       [3, 4, 3, 4</a>) np.tile(b, (2, 1)) array(<a href="null">1, 2],
       [3, 4],
       [1, 2],
       [3, 4</a>)</p>
      <p>c = np.array([1,2,3,4]) np.tile(c,(4,1)) array(<a href="null">1, 2, 3, 4],
       [1, 2, 3, 4],
       [1, 2, 3, 4],
       [1, 2, 3, 4</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L16170">view source</a></div></div><div class="public anchor" id="var-timedelta64"><h3>timedelta64</h3><div class="usage"><code>(timedelta64 self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L13344">view source</a></div></div><div class="public anchor" id="var-TooHardError"><h3>TooHardError</h3><div class="usage"><code>(TooHardError self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L1646">view source</a></div></div><div class="public anchor" id="var-trace"><h3>trace</h3><div class="usage"><code>(trace &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return the sum along diagonals of the array.</p>
<p>If <code>a</code> is 2-D, the sum along its diagonal with the given offset is returned, i.e., the sum of elements <code>a[i,i+offset]</code> for all i.</p>
<p>If <code>a</code> has more than two dimensions, then the axes specified by axis1 and axis2 are used to determine the 2-D sub-arrays whose traces are returned. The shape of the resulting array is the same as that of <code>a</code> with <code>axis1</code> and <code>axis2</code> removed.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input array, from which the diagonals are taken. offset : int, optional  Offset of the diagonal from the main diagonal. Can be both positive  and negative. Defaults to 0. axis1, axis2 : int, optional  Axes to be used as the first and second axis of the 2-D sub-arrays  from which the diagonals should be taken. Defaults are the first two  axes of <code>a</code>. dtype : dtype, optional  Determines the data-type of the returned array and of the accumulator  where the elements are summed. If dtype has the value None and <code>a</code> is  of integer type of precision less than the default integer  precision, then the default integer precision is used. Otherwise,  the precision is the same as that of <code>a</code>. out : ndarray, optional  Array into which the output is placed. Its type is preserved and  it must be of the right shape to hold the output.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>sum_along_diagonals : ndarray  If <code>a</code> is 2-D, the sum along the diagonal is returned. If <code>a</code> has  larger dimensions, then an array of sums along diagonals is returned.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>diag, diagonal, diagflat</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.trace(np.eye(3)) 3.0 a = np.arange(8).reshape((2,2,2)) np.trace(a) array([6, 8])</p>
      <p>a = np.arange(24).reshape((2,2,2,3)) np.trace(a).shape (2, 3)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L7909">view source</a></div></div><div class="public anchor" id="var-tracemalloc_domain"><h3>tracemalloc_domain</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L436">view source</a></div></div><div class="public anchor" id="var-transpose"><h3>transpose</h3><div class="usage"><code>(transpose &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Permute the dimensions of an array.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Input array. axes : list of ints, optional  By default, reverse the dimensions, otherwise permute the axes  according to the values given.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>p : ndarray  <code>a</code> with its axes permuted. A view is returned whenever  possible.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>moveaxis argsort</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Use <code>transpose(a, argsort(axes))</code> to invert the transposition of tensors when using the <code>axes</code> keyword argument.</p>
<p>Transposing a 1-D array returns an unchanged view of the original array.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.arange(4).reshape((2,2)) x array(<a href="null">0, 1],
       [2, 3</a>)</p>
      <p>np.transpose(x) array(<a href="null">0, 2],
       [1, 3</a>)</p>
      <p>x = np.ones((1, 2, 3)) np.transpose(x, (1, 0, 2)).shape (2, 1, 3)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L26425">view source</a></div></div><div class="public anchor" id="var-trapz"><h3>trapz</h3><div class="usage"><code>(trapz &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Integrate along the given axis using the composite trapezoidal rule.</p>
<p>Integrate <code>y</code> (<code>x</code>) along given axis.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>y : array_like  Input array to integrate. x : array_like, optional  The sample points corresponding to the <code>y</code> values. If <code>x</code> is None,  the sample points are assumed to be evenly spaced <code>dx</code> apart. The  default is None. dx : scalar, optional  The spacing between sample points when <code>x</code> is None. The default is 1. axis : int, optional  The axis along which to integrate.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>trapz : float  Definite integral as approximated by trapezoidal rule.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>sum, cumsum</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Image [2]_ illustrates trapezoidal rule  y-axis locations of points will be taken from <code>y</code> array, by default x-axis distances between points will be 1.0, alternatively they can be provided with <code>x</code> array or with <code>dx</code> scalar. Return value will be equal to combined area under the red lines.</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [1] Wikipedia page: <a href="https://en.wikipedia.org/wiki/Trapezoidal_rule">https://en.wikipedia.org/wiki/Trapezoidal_rule</a></p>
<p>.. [2] Illustration image:  <a href="https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png">https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png</a></p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.trapz([1,2,3]) 4.0 np.trapz([1,2,3], x=[4,6,8]) 8.0 np.trapz([1,2,3], dx=2) 8.0 a = np.arange(6).reshape(2, 3) a array(<a href="null">0, 1, 2],
       [3, 4, 5</a>) np.trapz(a, axis=0) array([1.5, 2.5, 3.5]) np.trapz(a, axis=1) array([2., 8.])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L5039">view source</a></div></div><div class="public anchor" id="var-tri"><h3>tri</h3><div class="usage"><code>(tri N &amp; [{M :M, k :k, dtype :dtype}])</code><code>(tri N &amp; [{M :M, k :k}])</code><code>(tri N &amp; [{M :M}])</code><code>(tri N)</code></div><div class="doc"><div class="markdown"><p>An array with ones at and below the given diagonal and zeros elsewhere.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>N : int  Number of rows in the array. M : int, optional  Number of columns in the array.  By default, <code>M</code> is taken equal to <code>N</code>. k : int, optional  The sub-diagonal at and below which the array is filled.  <code>k</code> = 0 is the main diagonal, while <code>k</code> &lt; 0 is below it,  and <code>k</code> &gt; 0 is above. The default is 0. dtype : dtype, optional  Data type of the returned array. The default is float.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>tri : ndarray of shape (N, M)  Array with its lower triangle filled with ones and zero elsewhere;  in other words <code>T[i,j] == 1</code> for <code>j &lt;= i + k</code>, 0 otherwise.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.tri(3, 5, 2, dtype=int) array(<a href="null">1, 1, 1, 0, 0],
       [1, 1, 1, 1, 0],
       [1, 1, 1, 1, 1</a>)</p>
      <p>np.tri(3, 5, -1) array(<a href="null">0.,  0.,  0.,  0.,  0.],
       [1.,  0.,  0.,  0.,  0.],
       [1.,  1.,  0.,  0.,  0.</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L27112">view source</a></div></div><div class="public anchor" id="var-tril"><h3>tril</h3><div class="usage"><code>(tril &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Lower triangle of an array.</p>
<p>Return a copy of an array with elements above the <code>k</code>-th diagonal zeroed.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>m : array_like, shape (M, N)  Input array. k : int, optional  Diagonal above which to zero elements. <code>k = 0</code> (the default) is the  main diagonal, <code>k &lt; 0</code> is below it and <code>k &gt; 0</code> is above.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>tril : ndarray, shape (M, N)  Lower triangle of <code>m</code>, of same shape and data-type as <code>m</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>triu : same thing, only for the upper triangle</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.tril(<a href="null">1,2,3],[4,5,6],[7,8,9],[10,11,12</a>, -1) array(<a href="null"> 0,  0,  0],
       [ 4,  0,  0],
       [ 7,  8,  0],
       [10, 11, 12</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L14615">view source</a></div></div><div class="public anchor" id="var-tril_indices"><h3>tril_indices</h3><div class="usage"><code>(tril_indices n &amp; [{k :k, m :m}])</code><code>(tril_indices n &amp; [{k :k}])</code><code>(tril_indices n)</code></div><div class="doc"><div class="markdown"><p>Return the indices for the lower-triangle of an (n, m) array.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>n : int  The row dimension of the arrays for which the returned  indices will be valid. k : int, optional  Diagonal offset (see <code>tril</code> for details). m : int, optional  .. versionadded:: 1.9.0</p>
<pre><code>The column dimension of the arrays for which the returned
arrays will be valid.
By default `m` is taken equal to `n`.
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>inds : tuple of arrays  The indices for the triangle. The returned tuple contains two arrays,  each with the indices along one dimension of the array.</p>
<h2><a href="#see-also" name="see-also"></a>See also</h2>
<p>triu_indices : similar function, for upper-triangular. mask_indices : generic function accepting an arbitrary mask function. tril, triu</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>.. versionadded:: 1.4.0</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>Compute two different sets of indices to access 4x4 arrays, one for the lower triangular part starting at the main diagonal, and one starting two diagonals further right:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>il1 = np.tril_indices(4) il2 = np.tril_indices(4, 2)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Here is how they can be used with a sample array:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.arange(16).reshape(4, 4) a array(<a href="null"> 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Both for indexing:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a[il1] array([ 0, 4, 5, , 13, 14, 15])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>And for assigning values:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a[il1] = -1 a array(<a href="null">-1,  1,  2,  3],
       [-1, -1,  6,  7],
       [-1, -1, -1, 11],
       [-1, -1, -1, -1</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>These cover almost the whole array (two diagonals right of the main one):</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a[il2] = -10 a array(<a href="null">-10, -10, -10,   3],
       [-10, -10, -10, -10],
       [-10, -10, -10, -10],
       [-10, -10, -10, -10</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L26472">view source</a></div></div><div class="public anchor" id="var-tril_indices_from"><h3>tril_indices_from</h3><div class="usage"><code>(tril_indices_from &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return the indices for the lower-triangle of arr.</p>
<p>See <code>tril_indices</code> for full details.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>arr : array_like  The indices will be valid for square arrays whose dimensions are  the same as arr. k : int, optional  Diagonal offset (see <code>tril</code> for details).</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>tril_indices, tril</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>.. versionadded:: 1.4.0</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L20777">view source</a></div></div><div class="public anchor" id="var-trim_zeros"><h3>trim_zeros</h3><div class="usage"><code>(trim_zeros &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Trim the leading and/or trailing zeros from a 1-D array or sequence.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>filt : 1-D array or sequence  Input array. trim : str, optional  A string with f representing trim from front and b to trim from  back. Default is fb, trim zeros from both front and back of the  array.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>trimmed : 1-D array or sequence  The result of trimming the input. The input data type is preserved.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array((0, 0, 0, 1, 2, 3, 0, 2, 1, 0)) np.trim_zeros(a) array([1, 2, 3, 0, 2, 1])</p>
      <p>np.trim_zeros(a, b) array([0, 0, 0, , 0, 2, 1])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The input data type is preserved, list/tuple in means list/tuple out.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.trim_zeros([0, 1, 2, 0]) [1, 2]</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L21775">view source</a></div></div><div class="public anchor" id="var-triu"><h3>triu</h3><div class="usage"><code>(triu &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Upper triangle of an array.</p>
<p>Return a copy of a matrix with the elements below the <code>k</code>-th diagonal zeroed.</p>
<p>Please refer to the documentation for <code>tril</code> for further details.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>tril : lower triangle of an array</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.triu(<a href="null">1,2,3],[4,5,6],[7,8,9],[10,11,12</a>, -1) array(<a href="null"> 1,  2,  3],
       [ 4,  5,  6],
       [ 0,  8,  9],
       [ 0,  0, 12</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L25622">view source</a></div></div><div class="public anchor" id="var-triu_indices"><h3>triu_indices</h3><div class="usage"><code>(triu_indices n &amp; [{k :k, m :m}])</code><code>(triu_indices n &amp; [{k :k}])</code><code>(triu_indices n)</code></div><div class="doc"><div class="markdown"><p>Return the indices for the upper-triangle of an (n, m) array.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>n : int  The size of the arrays for which the returned indices will  be valid. k : int, optional  Diagonal offset (see <code>triu</code> for details). m : int, optional  .. versionadded:: 1.9.0</p>
<pre><code>The column dimension of the arrays for which the returned
arrays will be valid.
By default `m` is taken equal to `n`.
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>inds : tuple, shape(2) of ndarrays, shape(<code>n</code>)  The indices for the triangle. The returned tuple contains two arrays,  each with the indices along one dimension of the array. Can be used  to slice a ndarray of shape(<code>n</code>, <code>n</code>).</p>
<h2><a href="#see-also" name="see-also"></a>See also</h2>
<p>tril_indices : similar function, for lower-triangular. mask_indices : generic function accepting an arbitrary mask function. triu, tril</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>.. versionadded:: 1.4.0</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<p>Compute two different sets of indices to access 4x4 arrays, one for the upper triangular part starting at the main diagonal, and one starting two diagonals further right:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>iu1 = np.triu_indices(4) iu2 = np.triu_indices(4, 2)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Here is how they can be used with a sample array:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.arange(16).reshape(4, 4) a array(<a href="null"> 0,  1,  2,  3],
       [ 4,  5,  6,  7],
       [ 8,  9, 10, 11],
       [12, 13, 14, 15</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Both for indexing:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a[iu1] array([ 0, 1, 2, , 10, 11, 15])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>And for assigning values:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a[iu1] = -1 a array(<a href="null">-1, -1, -1, -1],
       [ 4, -1, -1, -1],
       [ 8,  9, -1, -1],
       [12, 13, 14, -1</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>These cover only a small part of the whole array (two diagonals right of the main one):</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a[iu2] = -10 a array(<a href="null"> -1,  -1, -10, -10],
       [  4,  -1,  -1, -10],
       [  8,   9,  -1,  -1],
       [ 12,  13,  14,  -1</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L19814">view source</a></div></div><div class="public anchor" id="var-triu_indices_from"><h3>triu_indices_from</h3><div class="usage"><code>(triu_indices_from &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return the indices for the upper-triangle of arr.</p>
<p>See <code>triu_indices</code> for full details.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>arr : ndarray, shape(N, N)  The indices will be valid for square arrays. k : int, optional  Diagonal offset (see <code>triu</code> for details).</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>triu_indices_from : tuple, shape(2) of ndarray, shape(N)  Indices for the upper-triangle of <code>arr</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>triu_indices, triu</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>.. versionadded:: 1.4.0</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L24460">view source</a></div></div><div class="public anchor" id="var-True_"><h3>True_</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L11014">view source</a></div></div><div class="public anchor" id="var-true_divide"><h3>true_divide</h3><div class="usage"><code>(true_divide self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>true_divide(x1, x2, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Returns a true division of the inputs, element-wise.</p>
<p>Instead of the Python traditional floor division, this returns a true division. True division adjusts the output type to present the best answer, regardless of input types.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x1 : array_like  Dividend array. x2 : array_like  Divisor array. If <code>x1.shape != x2.shape</code>, they must be broadcastable to a common shape (which becomes the shape of the output). out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray or scalar  This is a scalar if both <code>x1</code> and <code>x2</code> are scalars.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The floor division operator <code>//</code> was added in Python 2.2 making <code>//</code> and <code>/</code> equivalent operators. The default floor division operation of <code>/</code> can be replaced by true division with <code>from
__future__ import division</code>.</p>
<p>In Python 3.0, <code>//</code> is the floor division operator and <code>/</code> the true division operator. The <code>true_divide(x1, x2)</code> function is equivalent to true division in Python.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.arange(5) np.true_divide(x, 4) array([ 0. , 0.25, 0.5 , 0.75, 1. ])</p>
      <p>x//4 array([0, 0, 0, 0, 1])</p>
      <p>from <strong>future</strong> import division x/4 array([ 0. , 0.25, 0.5 , 0.75, 1. ]) x//4 array([0, 0, 0, 0, 1])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L23555">view source</a></div></div><div class="public anchor" id="var-trunc"><h3>trunc</h3><div class="usage"><code>(trunc self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>trunc(x, /, out=None, *, where=True, casting=same_kind, order=K, dtype=None, subok=True[, signature, extobj])</p>
<p>Return the truncated value of the input, element-wise.</p>
<p>The truncated value of the scalar <code>x</code> is the nearest integer <code>i</code> which is closer to zero than <code>x</code> is. In short, the fractional part of the signed number <code>x</code> is discarded.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  Input data. out : ndarray, None, or tuple of ndarray and None, optional  A location into which the result is stored. If provided, it must have  a shape that the inputs broadcast to. If not provided or None,  a freshly-allocated array is returned. A tuple (possible only as a  keyword argument) must have length equal to the number of outputs. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the  :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>y : ndarray or scalar  The truncated value of each element in <code>x</code>.  This is a scalar if <code>x</code> is a scalar.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>ceil, floor, rint</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>.. versionadded:: 1.3.0</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7, 2.0]) np.trunc(a) array([-1., -1., -0., 0., 1., 1., 2.])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L19521">view source</a></div></div><div class="public anchor" id="var-typecodes"><h3>typecodes</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping objects  (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:  d = {}  for k, v in iterable:  d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs  in the keyword argument list. For example: dict(one=1, two=2)</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L14605">view source</a></div></div><div class="public anchor" id="var-typeDict"><h3>typeDict</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>dict() -&gt; new empty dictionary dict(mapping) -&gt; new dictionary initialized from a mapping objects  (key, value) pairs dict(iterable) -&gt; new dictionary initialized as if via:  d = {}  for k, v in iterable:  d[k] = v dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs  in the keyword argument list. For example: dict(one=1, two=2)</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L17202">view source</a></div></div><div class="public anchor" id="var-typeNA"><h3>typeNA</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L3139">view source</a></div></div><div class="public anchor" id="var-typename"><h3>typename</h3><div class="usage"><code>(typename char)</code></div><div class="doc"><div class="markdown"><p>Return a description for the given data type code.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>char : str  Data type code.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : str  Description of the input data type code.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>dtype, typecodes</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>typechars = [S1, ?, B, D, G, F, I, H, L, O, Q,  S, U, V, b, d, g, f, i, h, l, q] for typechar in typechars:  print(typechar,  : , np.typename(typechar))  S1 : character ? : bool B : unsigned char D : complex double precision G : complex long double precision F : complex single precision I : unsigned integer H : unsigned short L : unsigned long integer O : object Q : unsigned long long integer S : string U : unicode V : void b : signed char d : double precision g : long precision f : single precision i : integer h : short l : long integer q : long long integer</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L27800">view source</a></div></div><div class="public anchor" id="var-ubyte"><h3>ubyte</h3><div class="usage"><code>(ubyte self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Unsigned integer type, compatible with C <code>unsigned char</code>. Character code: <code>'B'</code>. Canonical name: <code>np.ubyte</code>. Alias <em>on this platform</em>: <code>np.uint8</code>: 8-bit unsigned integer (0 to 255).</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L25616">view source</a></div></div><div class="public anchor" id="var-ufunc"><h3>ufunc</h3><div class="usage"><code>(ufunc self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Functions that operate element by element on whole arrays.</p>
<p>To see the documentation for a specific ufunc, use <code>info</code>. For example, <code>np.info(np.sin)</code>. Because ufuncs are written in C (for speed) and linked into Python with NumPys ufunc facility, Pythons help() function finds this page whenever help() is called on a ufunc.</p>
<p>A detailed explanation of ufuncs can be found in the docs for :ref:<code>ufuncs</code>.</p>
<h1><a href="#calling-ufuncs-" name="calling-ufuncs-"></a>Calling ufuncs:</h1>
<p>op(*x[, out], where=True, **kwargs) Apply <code>op</code> to the arguments <code>*x</code> elementwise, broadcasting the arguments.</p>
<p>The broadcasting rules are:</p>
<ul>
  <li>Dimensions of length 1 may be prepended to either array.</li>
  <li>Arrays may be repeated along dimensions of length 1.</li>
</ul>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>*x : array_like  Input arrays. out : ndarray, None, or tuple of ndarray and None, optional  Alternate array object(s) in which to put the result; if provided, it  must have a shape that the inputs broadcast to. A tuple of arrays  (possible only as a keyword argument) must have length equal to the  number of outputs; use None for uninitialized outputs to be  allocated by the ufunc. where : array_like, optional  This condition is broadcast over the input. At locations where the  condition is True, the <code>out</code> array will be set to the ufunc result.  Elsewhere, the <code>out</code> array will retain its original value.  Note that if an uninitialized <code>out</code> array is created via the default  <code>out=None</code>, locations within it where the condition is False will  remain uninitialized. **kwargs  For other keyword-only arguments, see the :ref:<code>ufunc docs &lt;ufuncs.kwargs&gt;</code>.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>r : ndarray or tuple of ndarray  <code>r</code> will have the shape that the arrays in <code>x</code> broadcast to; if <code>out</code> is  provided, it will be returned. If not, <code>r</code> will be allocated and  may contain uninitialized values. If the function has more than one  output, then the result will be a tuple of arrays.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L1596">view source</a></div></div><div class="public anchor" id="var-UFUNC_BUFSIZE_DEFAULT"><h3>UFUNC_BUFSIZE_DEFAULT</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L1395">view source</a></div></div><div class="public anchor" id="var-UFUNC_PYVALS_NAME"><h3>UFUNC_PYVALS_NAME</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L15736">view source</a></div></div><div class="public anchor" id="var-uint"><h3>uint</h3><div class="usage"><code>(uint self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Unsigned integer type, compatible with C <code>unsigned long</code>. Character code: <code>'L'</code>. Canonical name: <code>np.uint</code>. Alias <em>on this platform</em>: <code>np.uint64</code>: 64-bit unsigned integer (0 to 18446744073709551615). Alias <em>on this platform</em>: <code>np.uintp</code>: Unsigned integer large enough to fit pointer, compatible with C <code>uintptr_t</code>.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L5411">view source</a></div></div><div class="public anchor" id="var-uint0"><h3>uint0</h3><div class="usage"><code>(uint0 self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Unsigned integer type, compatible with C <code>unsigned long</code>. Character code: <code>'L'</code>. Canonical name: <code>np.uint</code>. Alias <em>on this platform</em>: <code>np.uint64</code>: 64-bit unsigned integer (0 to 18446744073709551615). Alias <em>on this platform</em>: <code>np.uintp</code>: Unsigned integer large enough to fit pointer, compatible with C <code>uintptr_t</code>.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L2277">view source</a></div></div><div class="public anchor" id="var-uint16"><h3>uint16</h3><div class="usage"><code>(uint16 self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Unsigned integer type, compatible with C <code>unsigned short</code>. Character code: <code>'H'</code>. Canonical name: <code>np.ushort</code>. Alias <em>on this platform</em>: <code>np.uint16</code>: 16-bit unsigned integer (0 to 65535).</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L5702">view source</a></div></div><div class="public anchor" id="var-uint32"><h3>uint32</h3><div class="usage"><code>(uint32 self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Unsigned integer type, compatible with C <code>unsigned int</code>. Character code: <code>'I'</code>. Canonical name: <code>np.uintc</code>. Alias <em>on this platform</em>: <code>np.uint32</code>: 32-bit unsigned integer (0 to 4294967295).</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L6901">view source</a></div></div><div class="public anchor" id="var-uint64"><h3>uint64</h3><div class="usage"><code>(uint64 self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Unsigned integer type, compatible with C <code>unsigned long</code>. Character code: <code>'L'</code>. Canonical name: <code>np.uint</code>. Alias <em>on this platform</em>: <code>np.uint64</code>: 64-bit unsigned integer (0 to 18446744073709551615). Alias <em>on this platform</em>: <code>np.uintp</code>: Unsigned integer large enough to fit pointer, compatible with C <code>uintptr_t</code>.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L15910">view source</a></div></div><div class="public anchor" id="var-uint8"><h3>uint8</h3><div class="usage"><code>(uint8 self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Unsigned integer type, compatible with C <code>unsigned char</code>. Character code: <code>'B'</code>. Canonical name: <code>np.ubyte</code>. Alias <em>on this platform</em>: <code>np.uint8</code>: 8-bit unsigned integer (0 to 255).</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L16626">view source</a></div></div><div class="public anchor" id="var-uintc"><h3>uintc</h3><div class="usage"><code>(uintc self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Unsigned integer type, compatible with C <code>unsigned int</code>. Character code: <code>'I'</code>. Canonical name: <code>np.uintc</code>. Alias <em>on this platform</em>: <code>np.uint32</code>: 32-bit unsigned integer (0 to 4294967295).</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L23719">view source</a></div></div><div class="public anchor" id="var-uintp"><h3>uintp</h3><div class="usage"><code>(uintp self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Unsigned integer type, compatible with C <code>unsigned long</code>. Character code: <code>'L'</code>. Canonical name: <code>np.uint</code>. Alias <em>on this platform</em>: <code>np.uint64</code>: 64-bit unsigned integer (0 to 18446744073709551615). Alias <em>on this platform</em>: <code>np.uintp</code>: Unsigned integer large enough to fit pointer, compatible with C <code>uintptr_t</code>.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L25609">view source</a></div></div><div class="public anchor" id="var-ulonglong"><h3>ulonglong</h3><div class="usage"><code>(ulonglong self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Signed integer type, compatible with C <code>unsigned long long</code>. Character code: <code>'Q'</code>.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L17199">view source</a></div></div><div class="public anchor" id="var-unicode"><h3>unicode</h3><div class="usage"><code>(unicode self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>str(object=) -&gt; str str(bytes_or_buffer[, encoding[, errors]]) -&gt; str</p>
<p>Create a new string object from the given object. If encoding or errors is specified, then the object must expose a data buffer that will be decoded using the given encoding and error handler. Otherwise, returns the result of object.__str__() (if defined) or repr(object). encoding defaults to sys.getdefaultencoding(). errors defaults to strict.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L12022">view source</a></div></div><div class="public anchor" id="var-unicode_"><h3>unicode_</h3><div class="usage"><code>(unicode_ self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L14993">view source</a></div></div><div class="public anchor" id="var-union1d"><h3>union1d</h3><div class="usage"><code>(union1d &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Find the union of two arrays.</p>
<p>Return the unique, sorted array of values that are in either of the two input arrays.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>ar1, ar2 : array_like  Input arrays. They are flattened if they are not already 1D.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>union1d : ndarray  Unique, sorted union of the input arrays.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>numpy.lib.arraysetops : Module with a number of other functions for  performing set operations on arrays.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.union1d([-1, 0, 1], [-2, 0, 2]) array([-2, -1, 0, 1, 2])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>To find the union of more than two arrays, use functools.reduce:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>from functools import reduce reduce(np.union1d, ([1, 3, 4, 3], [3, 1, 2, 1], [6, 3, 4, 2])) array([1, 2, 3, 4, 6])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L20587">view source</a></div></div><div class="public anchor" id="var-unique"><h3>unique</h3><div class="usage"><code>(unique &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Find the unique elements of an array.</p>
<p>Returns the sorted unique elements of an array. There are three optional outputs in addition to the unique elements:</p>
<ul>
  <li>the indices of the input array that give the unique values</li>
  <li>the indices of the unique array that reconstruct the input array</li>
  <li>the number of times each unique value comes up in the input array</li>
</ul>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>ar : array_like  Input array. Unless <code>axis</code> is specified, this will be flattened if it  is not already 1-D. return_index : bool, optional  If True, also return the indices of <code>ar</code> (along the specified axis,  if provided, or in the flattened array) that result in the unique array. return_inverse : bool, optional  If True, also return the indices of the unique array (for the specified  axis, if provided) that can be used to reconstruct <code>ar</code>. return_counts : bool, optional  If True, also return the number of times each unique item appears  in <code>ar</code>.</p>
<pre><code>.. versionadded:: 1.9.0
</code></pre>
<p>axis : int or None, optional  The axis to operate on. If None, <code>ar</code> will be flattened. If an integer,  the subarrays indexed by the given axis will be flattened and treated  as the elements of a 1-D array with the dimension of the given axis,  see the notes for more details. Object arrays or structured arrays  that contain objects are not supported if the <code>axis</code> kwarg is used. The  default is None.</p>
<pre><code>.. versionadded:: 1.13.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>unique : ndarray  The sorted unique values. unique_indices : ndarray, optional  The indices of the first occurrences of the unique values in the  original array. Only provided if <code>return_index</code> is True. unique_inverse : ndarray, optional  The indices to reconstruct the original array from the  unique array. Only provided if <code>return_inverse</code> is True. unique_counts : ndarray, optional  The number of times each of the unique values comes up in the  original array. Only provided if <code>return_counts</code> is True.</p>
<pre><code>.. versionadded:: 1.9.0
</code></pre>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>numpy.lib.arraysetops : Module with a number of other functions for  performing set operations on arrays.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>When an axis is specified the subarrays indexed by the axis are sorted. This is done by making the specified axis the first dimension of the array (move the axis to the first dimension to keep the order of the other axes) and then flattening the subarrays in C order. The flattened subarrays are then viewed as a structured type with each element given a label, with the effect that we end up with a 1-D array of structured types that can be treated in the same way as any other 1-D array. The result is that the flattened subarrays are sorted in lexicographic order starting with the first element.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.unique([1, 1, 2, 2, 3, 3]) array([1, 2, 3]) a = np.array(<a href="null">1, 1], [2, 3</a>) np.unique(a) array([1, 2, 3])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Return the unique rows of a 2D array</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array(<a href="null">1, 0, 0], [1, 0, 0], [2, 3, 4</a>) np.unique(a, axis=0) array(<a href="null">1, 0, 0], [2, 3, 4</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Return the indices of the original array that give the unique values:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array([a, b, b, c, a]) u, indices = np.unique(a, return_index=True) u array([a, b, c], dtype=&lt;U1) indices array([0, 1, 3]) a[indices] array([a, b, c], dtype=&lt;U1)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Reconstruct the input array from the unique values:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array([1, 2, 6, 4, 2, 3, 2]) u, indices = np.unique(a, return_inverse=True) u array([1, 2, 3, 4, 6]) indices array([0, 1, 4, , 1, 2, 1]) u[indices] array([1, 2, 6, , 2, 3, 2])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L1692">view source</a></div></div><div class="public anchor" id="var-unpackbits"><h3>unpackbits</h3><div class="usage"><code>(unpackbits &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>unpackbits(a, axis=None, count=None, bitorder=big)</p>
<p>Unpacks elements of a uint8 array into a binary-valued output array.</p>
<p>Each element of <code>a</code> represents a bit-field that should be unpacked into a binary-valued output array. The shape of the output array is either 1-D (if <code>axis</code> is <code>None</code>) or the same shape as the input array with unpacking done along the axis specified.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : ndarray, uint8 type  Input array. axis : int, optional  The dimension over which bit-unpacking is done.  <code>None</code> implies unpacking the flattened array. count : int or None, optional  The number of elements to unpack along <code>axis</code>, provided as a way  of undoing the effect of packing a size that is not a multiple  of eight. A non-negative number means to only unpack <code>count</code>  bits. A negative number means to trim off that many bits from  the end. <code>None</code> means to unpack the entire array (the  default). Counts larger than the available number of bits will  add zero padding to the output. Negative counts must not  exceed the available number of bits.</p>
<pre><code>.. versionadded:: 1.17.0
</code></pre>
<p>bitorder : {big, little}, optional  The order of the returned bits. big will mimic bin(val),  <code>3 = 0b00000011 =&gt; [0, 0, 0, 0, 0, 0, 1, 1]</code>, little will reverse  the order to <code>[1, 1, 0, 0, 0, 0, 0, 0]</code>.  Defaults to big.</p>
<pre><code>.. versionadded:: 1.17.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>unpacked : ndarray, uint8 type  The elements are binary-valued (0 or 1).</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>packbits : Packs the elements of a binary-valued array into bits in  a uint8 array.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array(<a href="null">2], [7], [23</a>, dtype=np.uint8) a array(<a href="null"> 2],
       [ 7],
       [23</a>, dtype=uint8) b = np.unpackbits(a, axis=1) b array(<a href="null">0, 0, 0, 0, 0, 0, 1, 0],
       [0, 0, 0, 0, 0, 1, 1, 1],
       [0, 0, 0, 1, 0, 1, 1, 1</a>, dtype=uint8) c = np.unpackbits(a, axis=1, count=-3) c array(<a href="null">0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0],
       [0, 0, 0, 1, 0</a>, dtype=uint8)</p>
      <p>p = np.packbits(b, axis=0) np.unpackbits(p, axis=0) array(<a href="null">0, 0, 0, 0, 0, 0, 1, 0],
       [0, 0, 0, 0, 0, 1, 1, 1],
       [0, 0, 0, 1, 0, 1, 1, 1],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0</a>, dtype=uint8) np.array_equal(b, np.unpackbits(p, axis=0, count=b.shape[0])) True</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L20506">view source</a></div></div><div class="public anchor" id="var-unravel_index"><h3>unravel_index</h3><div class="usage"><code>(unravel_index &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>unravel_index(indices, shape, order=C)</p>
<p>Converts a flat index or array of flat indices into a tuple of coordinate arrays.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>indices : array_like  An integer array whose elements are indices into the flattened  version of an array of dimensions <code>shape</code>. Before version 1.6.0,  this function accepted just one index value. shape : tuple of ints  The shape of the array to use for unraveling <code>indices</code>.</p>
<pre><code>.. versionchanged:: 1.16.0
    Renamed from ``dims`` to ``shape``.
</code></pre>
<p>order : {C, F}, optional  Determines whether the indices should be viewed as indexing in  row-major (C-style) or column-major (Fortran-style) order.</p>
<pre><code>.. versionadded:: 1.6.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>unraveled_coords : tuple of ndarray  Each array in the tuple has the same shape as the <code>indices</code>  array.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>ravel_multi_index</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.unravel_index([22, 41, 37], (7,6)) (array([3, 6, 6]), array([4, 5, 1])) np.unravel_index([31, 41, 13], (7,6), order=F) (array([3, 6, 6]), array([4, 5, 1]))</p>
      <p>np.unravel_index(1621, (6,7,8,9)) (3, 1, 4, 1)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L16006">view source</a></div></div><div class="public anchor" id="var-unsignedinteger"><h3>unsignedinteger</h3><div class="usage"><code>(unsignedinteger self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Abstract base class of all unsigned integer scalar types.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L23812">view source</a></div></div><div class="public anchor" id="var-unwrap"><h3>unwrap</h3><div class="usage"><code>(unwrap &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Unwrap by changing deltas between values to 2*pi complement.</p>
<p>Unwrap radian phase <code>p</code> by changing absolute jumps greater than <code>discont</code> to their 2*pi complement along the given axis.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>p : array_like  Input array. discont : float, optional  Maximum discontinuity between values, default is <code>pi</code>. axis : int, optional  Axis along which unwrap will operate, default is the last axis.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  Output array.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>rad2deg, deg2rad</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>If the discontinuity in <code>p</code> is smaller than <code>pi</code>, but larger than <code>discont</code>, no unwrapping is done because taking the 2*pi complement would only make the discontinuity larger.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>phase = np.linspace(0, np.pi, num=5) phase[3:] += np.pi phase array([ 0. , 0.78539816, 1.57079633, 5.49778714, 6.28318531]) # may vary np.unwrap(phase) array([ 0. , 0.78539816, 1.57079633, -0.78539816, 0. ]) # may vary</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L12353">view source</a></div></div><div class="public anchor" id="var-ushort"><h3>ushort</h3><div class="usage"><code>(ushort self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Unsigned integer type, compatible with C <code>unsigned short</code>. Character code: <code>'H'</code>. Canonical name: <code>np.ushort</code>. Alias <em>on this platform</em>: <code>np.uint16</code>: 16-bit unsigned integer (0 to 65535).</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L12066">view source</a></div></div><div class="public anchor" id="var-vander"><h3>vander</h3><div class="usage"><code>(vander &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Generate a Vandermonde matrix.</p>
<p>The columns of the output matrix are powers of the input vector. The order of the powers is determined by the <code>increasing</code> boolean argument. Specifically, when <code>increasing</code> is False, the <code>i</code>-th output column is the input vector raised element-wise to the power of <code>N - i - 1</code>. Such a matrix with a geometric progression in each row is named for Alexandre- Theophile Vandermonde.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>x : array_like  1-D input array. N : int, optional  Number of columns in the output. If <code>N</code> is not specified, a square  array is returned (<code>N = len(x)</code>). increasing : bool, optional  Order of the powers of the columns. If True, the powers increase  from left to right, if False (the default) they are reversed.</p>
<pre><code>.. versionadded:: 1.9.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  Vandermonde matrix. If <code>increasing</code> is False, the first column is  <code>x^(N-1)</code>, the second <code>x^(N-2)</code> and so forth. If <code>increasing</code> is  True, the columns are <code>x^0, x^1, ..., x^(N-1)</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>polynomial.polynomial.polyvander</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.array([1, 2, 3, 5]) N = 3 np.vander(x, N) array(<a href="null"> 1,  1,  1],
       [ 4,  2,  1],
       [ 9,  3,  1],
       [25,  5,  1</a>)</p>
      <p>np.column_stack([x**(N-1-i) for i in range(N)]) array(<a href="null"> 1,  1,  1],
       [ 4,  2,  1],
       [ 9,  3,  1],
       [25,  5,  1</a>)</p>
      <p>x = np.array([1, 2, 3, 5]) np.vander(x) array(<a href="null">  1,   1,   1,   1],
       [  8,   4,   2,   1],
       [ 27,   9,   3,   1],
       [125,  25,   5,   1</a>) np.vander(x, increasing=True) array(<a href="null">  1,   1,   1,   1],
       [  1,   2,   4,   8],
       [  1,   3,   9,  27],
       [  1,   5,  25, 125</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The determinant of a square Vandermonde matrix is the product of the differences between the values of the input vector:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.linalg.det(np.vander(x)) 48.000000000000043 # may vary (5-3)*(5-2)*(5-1)*(3-2)*(3-1)*(2-1) 48</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L21007">view source</a></div></div><div class="public anchor" id="var-var"><h3>var</h3><div class="usage"><code>(var &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Compute the variance along the specified axis.</p>
<p>Returns the variance of the array elements, a measure of the spread of a distribution. The variance is computed for the flattened array by default, otherwise over the specified axis.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  Array containing numbers whose variance is desired. If <code>a</code> is not an  array, a conversion is attempted. axis : None or int or tuple of ints, optional  Axis or axes along which the variance is computed. The default is to  compute the variance of the flattened array.</p>
<pre><code>.. versionadded:: 1.7.0

If this is a tuple of ints, a variance is performed over multiple axes,
instead of a single axis or all the axes as before.
</code></pre>
<p>dtype : data-type, optional  Type to use in computing the variance. For arrays of integer type  the default is <code>float64</code>; for arrays of float types it is the same as  the array type. out : ndarray, optional  Alternate output array in which to place the result. It must have  the same shape as the expected output, but the type is cast if  necessary. ddof : int, optional  Delta Degrees of Freedom: the divisor used in the calculation is  <code>N - ddof</code>, where <code>N</code> represents the number of elements. By  default <code>ddof</code> is zero. keepdims : bool, optional  If this is set to True, the axes which are reduced are left  in the result as dimensions with size one. With this option,  the result will broadcast correctly against the input array.</p>
<pre><code>If the default value is passed, then `keepdims` will not be
passed through to the `var` method of sub-classes of
`ndarray`, however any non-default value will be.  If the
sub-class' method does not implement `keepdims` any
exceptions will be raised.
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>variance : ndarray, see dtype parameter above  If <code>out=None</code>, returns a new array containing the variance;  otherwise, a reference to the output array is returned.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>std, mean, nanmean, nanstd, nanvar ufuncs-output-type</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The variance is the average of the squared deviations from the mean, i.e., <code>var = mean(abs(x - x.mean())**2)</code>.</p>
<p>The mean is normally calculated as <code>x.sum() / N</code>, where <code>N = len(x)</code>. If, however, <code>ddof</code> is specified, the divisor <code>N - ddof</code> is used instead. In standard statistical practice, <code>ddof=1</code> provides an unbiased estimator of the variance of a hypothetical infinite population. <code>ddof=0</code> provides a maximum likelihood estimate of the variance for normally distributed variables.</p>
<p>Note that for complex numbers, the absolute value is taken before squaring, so that the result is always real and nonnegative.</p>
<p>For floating-point input, the variance is computed using the same precision the input has. Depending on the input data, this can cause the results to be inaccurate, especially for <code>float32</code> (see example below). Specifying a higher-accuracy accumulator using the <code>dtype</code> keyword can alleviate this issue.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array(<a href="null">1, 2], [3, 4</a>) np.var(a) 1.25 np.var(a, axis=0) array([1., 1.]) np.var(a, axis=1) array([0.25, 0.25])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>In single precision, var() can be inaccurate:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.zeros((2, 512*512), dtype=np.float32) a[0, :] = 1.0 a[1, :] = 0.1 np.var(a) 0.20250003</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Computing the variance in float64 is more accurate:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.var(a, dtype=np.float64) 0.20249999932944759 # may vary ((1-0.55)**2 + (0.1-0.55)**2)/2 0.2025</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L7035">view source</a></div></div><div class="public anchor" id="var-vdot"><h3>vdot</h3><div class="usage"><code>(vdot &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>vdot(a, b)</p>
<p>Return the dot product of two vectors.</p>
<p>The vdot(<code>a</code>, <code>b</code>) function handles complex numbers differently than dot(<code>a</code>, <code>b</code>). If the first argument is complex the complex conjugate of the first argument is used for the calculation of the dot product.</p>
<p>Note that <code>vdot</code> handles multidimensional arrays differently than <code>dot</code>: it does <em>not</em> perform a matrix product, but flattens input arguments to 1-D vectors first. Consequently, it should only be used for vectors.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  If <code>a</code> is complex the complex conjugate is taken before calculation  of the dot product. b : array_like  Second argument to the dot product.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>output : ndarray  Dot product of <code>a</code> and <code>b</code>. Can be an int, float, or  complex depending on the types of <code>a</code> and <code>b</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>dot : Return the dot product without using the complex conjugate of the  first argument.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array([1+2j,3+4j]) b = np.array([5+6j,7+8j]) np.vdot(a, b) (70-8j) np.vdot(b, a) (70+8j)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Note that higher-dimensional arrays are flattened!</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array(<a href="null">1, 4], [5, 6</a>) b = np.array(<a href="null">4, 1], [2, 2</a>) np.vdot(a, b) 30 np.vdot(b, a) 30 1*4 + 4*1 + 5*2 + 6*2 30</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L140">view source</a></div></div><div class="public anchor" id="var-vectorize"><h3>vectorize</h3><div class="usage"><code>(vectorize self pyfunc &amp; [{otypes :otypes, doc :doc, excluded :excluded, cache :cache, signature :signature}])</code><code>(vectorize self pyfunc &amp; [{otypes :otypes, doc :doc, excluded :excluded, cache :cache}])</code><code>(vectorize self pyfunc &amp; [{otypes :otypes, doc :doc, excluded :excluded}])</code><code>(vectorize self pyfunc &amp; [{otypes :otypes, doc :doc}])</code><code>(vectorize self pyfunc &amp; [{otypes :otypes}])</code><code>(vectorize self pyfunc)</code></div><div class="doc"><div class="markdown"><p>vectorize(pyfunc, otypes=None, doc=None, excluded=None, cache=False,  signature=None)</p>
<p>Generalized function class.</p>
<p>Define a vectorized function which takes a nested sequence of objects or numpy arrays as inputs and returns a single numpy array or a tuple of numpy arrays. The vectorized function evaluates <code>pyfunc</code> over successive tuples of the input arrays like the python map function, except it uses the broadcasting rules of numpy.</p>
<p>The data type of the output of <code>vectorized</code> is determined by calling the function with the first element of the input. This can be avoided by specifying the <code>otypes</code> argument.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>pyfunc : callable  A python function or method. otypes : str or list of dtypes, optional  The output data type. It must be specified as either a string of  typecode characters or a list of data type specifiers. There should  be one data type specifier for each output. doc : str, optional  The docstring for the function. If None, the docstring will be the  <code>pyfunc.__doc__</code>. excluded : set, optional  Set of strings or integers representing the positional or keyword  arguments for which the function will not be vectorized. These will be  passed directly to <code>pyfunc</code> unmodified.</p>
<pre><code>.. versionadded:: 1.7.0
</code></pre>
<p>cache : bool, optional  If <code>True</code>, then cache the first function call that determines the number  of outputs if <code>otypes</code> is not provided.</p>
<pre><code>.. versionadded:: 1.7.0
</code></pre>
<p>signature : string, optional  Generalized universal function signature, e.g., <code>(m,n),(n)-&gt;(m)</code> for  vectorized matrix-vector multiplication. If provided, <code>pyfunc</code> will  be called with (and expected to return) arrays with shapes given by the  size of corresponding core dimensions. By default, <code>pyfunc</code> is  assumed to take scalars as input and output.</p>
<pre><code>.. versionadded:: 1.12.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>vectorized : callable  Vectorized function.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>frompyfunc : Takes an arbitrary Python function and returns a ufunc</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>The <code>vectorize</code> function is provided primarily for convenience, not for performance. The implementation is essentially a for loop.</p>
<p>If <code>otypes</code> is not specified, then a call to the function with the first argument will be used to determine the number of outputs. The results of this call will be cached if <code>cache</code> is <code>True</code> to prevent calling the function twice. However, to implement the cache, the original function must be wrapped which will slow down subsequent calls, so only do this if your function is expensive.</p>
<p>The new keyword argument interface and <code>excluded</code> argument support further degrades performance.</p>
<h2><a href="#references" name="references"></a>References</h2>
<p>.. [1] NumPy Reference, section <code>Generalized Universal Function API
       &lt;https://docs.scipy.org/doc/numpy/reference/c-api.generalized-ufuncs.html&gt;</code>_.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>def myfunc(a, b):  Return a-b if a&gt;b, otherwise return a+b  if a &gt; b:  return a - b  else:  return a + b</p>
      <p>vfunc = np.vectorize(myfunc) vfunc([1, 2, 3, 4], 2) array([3, 4, 1, 2])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The docstring is taken from the input function to <code>vectorize</code> unless it is specified:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>vfunc.__doc__ Return a-b if a&gt;b, otherwise return a+b vfunc = np.vectorize(myfunc, doc=Vectorized <code>myfunc</code>) vfunc.__doc__ Vectorized <code>myfunc</code></p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The output type is determined by evaluating the first element of the input, unless it is specified:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>out = vfunc([1, 2, 3, 4], 2) type(out[0]) &lt;class numpy.int64&gt; vfunc = np.vectorize(myfunc, otypes=[float]) out = vfunc([1, 2, 3, 4], 2) type(out[0]) &lt;class numpy.float64&gt;</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The <code>excluded</code> argument can be used to prevent vectorizing over certain arguments. This can be useful for array-like arguments of a fixed length such as the coefficients for a polynomial as in <code>polyval</code>:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>def mypolyval(p, x):  _p = list(p)  res = _p.pop(0)  while _p:  res = res*x + _p.pop(0)  return res vpolyval = np.vectorize(mypolyval, excluded=[p]) vpolyval(p=[1, 2, 3], x=[0, 1]) array([3, 6])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Positional arguments may also be excluded by specifying their position:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>vpolyval.excluded.add(0) vpolyval([1, 2, 3], x=[0, 1]) array([3, 6])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The <code>signature</code> argument allows for vectorizing functions that act on non-scalar arrays of fixed length. For example, you can use it for a vectorized calculation of Pearson correlation coefficient and its p-value:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>import scipy.stats pearsonr = np.vectorize(scipy.stats.pearsonr,  signature=(n),(n)-&gt;(),()) pearsonr(<a href="null">0, 1, 2, 3</a>, <a href="null">1, 2, 3, 4], [4, 3, 2, 1</a>) (array([ 1., -1.]), array([ 0., 0.]))</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>Or for a vectorized convolution:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>convolve = np.vectorize(np.convolve, signature=(n),(m)-&gt;(k)) convolve(np.eye(4), [1, 2, 1]) array(<a href="null">1., 2., 1., 0., 0., 0.],
       [0., 1., 2., 1., 0., 0.],
       [0., 0., 1., 2., 1., 0.],
       [0., 0., 0., 1., 2., 1.</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L15421">view source</a></div></div><div class="public anchor" id="var-version"><h3>version</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L21265">view source</a></div></div><div class="public anchor" id="var-VisibleDeprecationWarning"><h3>VisibleDeprecationWarning</h3><div class="usage"><code>(VisibleDeprecationWarning self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Visible deprecation warning.</p>
<p>By default, python will not show deprecation warnings, so this class can be used when a very visible warning is helpful, for example because the usage is most likely a user bug.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L25026">view source</a></div></div><div class="public anchor" id="var-void"><h3>void</h3><div class="usage"><code>(void self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L4380">view source</a></div></div><div class="public anchor" id="var-void0"><h3>void0</h3><div class="usage"><code>(void0 self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L2341">view source</a></div></div><div class="public anchor" id="var-vsplit"><h3>vsplit</h3><div class="usage"><code>(vsplit &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Split an array into multiple sub-arrays vertically (row-wise).</p>
<p>Please refer to the <code>split</code> documentation. <code>vsplit</code> is equivalent to <code>split</code> with <code>axis=0</code> (default), the array is always split along the first axis regardless of the array dimension.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>split : Split an array into multiple sub-arrays of equal size.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.arange(16.0).reshape(4, 4) x array(<a href="null"> 0.,   1.,   2.,   3.],
       [ 4.,   5.,   6.,   7.],
       [ 8.,   9.,  10.,  11.],
       [12.,  13.,  14.,  15.</a>) np.vsplit(x, 2) [array([[0., 1., 2., 3.],  [4., 5., 6., 7.]]), array([[ 8., 9., 10., 11.],  [12., 13., 14., 15.]])] np.vsplit(x, np.array([3, 6])) [array([[ 0., 1., 2., 3.],  [ 4., 5., 6., 7.],  [ 8., 9., 10., 11.]]), array([[12., 13., 14., 15.]]), array([], shape=(0, 4), dtype=float64)]</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>With a higher dimensional array the split is still along the first axis.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.arange(8.0).reshape(2, 2, 2) x array(<a href="null">[0.,  1.],
        [2.,  3.</a>,  <a href="null">4.,  5.],
        [6.,  7.</a>]) np.vsplit(x, 2) [array([[[0., 1.],  [2., 3.]]]), array([[[4., 5.],  [6., 7.]]])]</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L9223">view source</a></div></div><div class="public anchor" id="var-vstack"><h3>vstack</h3><div class="usage"><code>(vstack &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Stack arrays in sequence vertically (row wise).</p>
<p>This is equivalent to concatenation along the first axis after 1-D arrays of shape <code>(N,)</code> have been reshaped to <code>(1,N)</code>. Rebuilds arrays divided by <code>vsplit</code>.</p>
<p>This function makes most sense for arrays with up to 3 dimensions. For instance, for pixel-data with a height (first axis), width (second axis), and r/g/b channels (third axis). The functions <code>concatenate</code>, <code>stack</code> and <code>block</code> provide more general stacking and concatenation operations.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>tup : sequence of ndarrays  The arrays must have the same shape along all but the first axis.  1-D arrays must have the same length.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>stacked : ndarray  The array formed by stacking the given arrays, will be at least 2-D.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>stack : Join a sequence of arrays along a new axis. hstack : Stack arrays in sequence horizontally (column wise). dstack : Stack arrays in sequence depth wise (along third dimension). concatenate : Join a sequence of arrays along an existing axis. vsplit : Split array into a list of multiple sub-arrays vertically. block : Assemble arrays from blocks.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.array([1, 2, 3]) b = np.array([2, 3, 4]) np.vstack((a,b)) array(<a href="null">1, 2, 3],
       [2, 3, 4</a>)</p>
      <p>a = np.array(<a href="null">1], [2], [3</a>) b = np.array(<a href="null">2], [3], [4</a>) np.vstack((a,b)) array(<a href="null">1],
       [2],
       [3],
       [2],
       [3],
       [4</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L21212">view source</a></div></div><div class="public anchor" id="var-warnings"><h3>warnings</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Python part of the warnings subsystem.</p></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L23717">view source</a></div></div><div class="public anchor" id="var-where"><h3>where</h3><div class="usage"><code>(where &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>where(condition, [x, y])</p>
<p>Return elements chosen from <code>x</code> or <code>y</code> depending on <code>condition</code>.</p>
<p>.. note::  When only <code>condition</code> is provided, this function is a shorthand for  <code>np.asarray(condition).nonzero()</code>. Using <code>nonzero</code> directly should be  preferred, as it behaves correctly for subclasses. The rest of this  documentation covers only the case where all three arguments are  provided.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>condition : array_like, bool  Where True, yield <code>x</code>, otherwise yield <code>y</code>. x, y : array_like  Values from which to choose. <code>x</code>, <code>y</code> and <code>condition</code> need to be  broadcastable to some shape.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  An array with elements from <code>x</code> where <code>condition</code> is True, and elements  from <code>y</code> elsewhere.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>choose nonzero : The function that is called when x and y are omitted</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>If all the arrays are 1-D, <code>where</code> is equivalent to::</p>
<pre><code>[xv if c else yv
 for c, xv, yv in zip(condition, x, y)]
</code></pre>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.arange(10) a array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) np.where(a &lt; 5, a, 10*a) array([ 0, 1, 2, 3, 4, 50, 60, 70, 80, 90])</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>This can be used on multidimensional arrays too:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.where(<a href="null">True, False], [True, True</a>,  <a href="null">1, 2], [3, 4</a>,  <a href="null">9, 8], [7, 6</a>) array(<a href="null">1, 8],
       [3, 4</a>)</p>
    </blockquote>
  </blockquote>
</blockquote>
<p>The shapes of x, y, and the condition are broadcast together:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x, y = np.ogrid[:3, :4] np.where(x &lt; y, x, 10 + y) # both x and 10+y are broadcast array(<a href="null">10,  0,  0,  0],
       [10, 11,  1,  1],
       [10, 11, 12,  2</a>)</p>
      <p>a = np.array(<a href="null">0, 1, 2],
...               [0, 2, 4],
...               [0, 3, 6</a>) np.where(a &lt; 4, a, -1) # -1 is broadcast array(<a href="null"> 0,  1,  2],
       [ 0,  2, -1],
       [ 0,  3, -1</a>)</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L10439">view source</a></div></div><div class="public anchor" id="var-who"><h3>who</h3><div class="usage"><code>(who &amp; [{vardict :vardict}])</code><code>(who)</code></div><div class="doc"><div class="markdown"><p>Print the NumPy arrays in the given dictionary.</p>
<p>If there is no dictionary passed in or <code>vardict</code> is None then returns NumPy arrays in the globals() dictionary (all NumPy arrays in the namespace).</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>vardict : dict, optional  A dictionary possibly containing ndarrays. Default is globals().</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : None  Returns None.</p>
<h2><a href="#notes" name="notes"></a>Notes</h2>
<p>Prints out the name, shape, bytes and type of all of the ndarrays present in <code>vardict</code>.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a = np.arange(10) b = np.ones(20) np.who()</p>
      <h1><a href="#name-shape-bytes-type" name="name-shape-bytes-type"></a>Name Shape Bytes Type</h1>
      <p>a 10 80 int64 b 20 160 float64 Upper bound on total bytes = 240</p>
      <p>d = {x: np.arange(2.0), y: np.arange(3.0), txt: Some str,  idx:5} np.who(d)</p>
      <h1><a href="#name-shape-bytes-type" name="name-shape-bytes-type"></a>Name Shape Bytes Type</h1>
      <p>x 2 16 float64 y 3 24 float64 Upper bound on total bytes = 40</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L3141">view source</a></div></div><div class="public anchor" id="var-WRAP"><h3>WRAP</h3><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L22283">view source</a></div></div><div class="public anchor" id="var-zeros"><h3>zeros</h3><div class="usage"><code>(zeros self &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>zeros(shape, dtype=float, order=C)</p>
<p>Return a new array of given shape and type, filled with zeros.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>shape : int or tuple of ints  Shape of the new array, e.g., <code>(2, 3)</code> or <code>2</code>. dtype : data-type, optional  The desired data-type for the array, e.g., <code>numpy.int8</code>. Default is  <code>numpy.float64</code>. order : {C, F}, optional, default: C  Whether to store multi-dimensional data in row-major  (C-style) or column-major (Fortran-style) order in  memory.</p>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  Array of zeros with the given shape, dtype, and order.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>zeros_like : Return an array of zeros with shape and type of input. empty : Return a new uninitialized array. ones : Return a new array setting values to one. full : Return a new array of given shape filled with value.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>np.zeros(5) array([ 0., 0., 0., 0., 0.])</p>
      <p>np.zeros((5,), dtype=int) array([0, 0, 0, 0, 0])</p>
      <p>np.zeros((2, 1)) array(<a href="null"> 0.],
       [ 0.</a>)</p>
      <p>s = (2,2) np.zeros(s) array(<a href="null"> 0.,  0.],
       [ 0.,  0.</a>)</p>
      <p>np.zeros((2,), dtype=[(x, i4), (y, i4)]) # custom dtype array([(0, 0), (0, 0)],  dtype=[(x, &lt;i4), (y, &lt;i4)])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L2074">view source</a></div></div><div class="public anchor" id="var-zeros_like"><h3>zeros_like</h3><div class="usage"><code>(zeros_like &amp; [args {:as kwargs}])</code></div><div class="doc"><div class="markdown"><p>Return an array of zeros with the same shape and type as a given array.</p>
<h2><a href="#parameters" name="parameters"></a>Parameters</h2>
<p>a : array_like  The shape and data-type of <code>a</code> define these same attributes of  the returned array. dtype : data-type, optional  Overrides the data type of the result.</p>
<pre><code>.. versionadded:: 1.6.0
</code></pre>
<p>order : {C, F, A, or K}, optional  Overrides the memory layout of the result. C means C-order,  F means F-order, A means F if <code>a</code> is Fortran contiguous,  C otherwise. K means match the layout of <code>a</code> as closely  as possible.</p>
<pre><code>.. versionadded:: 1.6.0
</code></pre>
<p>subok : bool, optional.  If True, then the newly created array will use the sub-class  type of a, otherwise it will be a base-class array. Defaults  to True. shape : int or sequence of ints, optional.  Overrides the shape of the result. If order=K and the number of  dimensions is unchanged, will try to keep order, otherwise,  order=C is implied.</p>
<pre><code>.. versionadded:: 1.17.0
</code></pre>
<h2><a href="#returns" name="returns"></a>Returns</h2>
<p>out : ndarray  Array of zeros with the same shape and type as <code>a</code>.</p>
<h2><a href="#see-also" name="see-also"></a>See Also</h2>
<p>empty_like : Return an empty array with shape and type of input. ones_like : Return an array of ones with shape and type of input. full_like : Return a new array with shape of input filled with value. zeros : Return a new array setting values to zero.</p>
<h2><a href="#examples" name="examples"></a>Examples</h2>
<blockquote>
  <blockquote>
    <blockquote>
      <p>x = np.arange(6) x = x.reshape((2, 3)) x array(<a href="null">0, 1, 2],
       [3, 4, 5</a>) np.zeros_like(x) array(<a href="null">0, 0, 0],
       [0, 0, 0</a>)</p>
      <p>y = np.arange(3, dtype=float) y array([0., 1., 2.]) np.zeros_like(y) array([0., 0., 0.])</p>
    </blockquote>
  </blockquote>
</blockquote></div></div><div class="src-link"><a href="https://github.com/clj-python/libpython-clj/blob/master/src/python/numpy.clj#L28326">view source</a></div></div></div></body></html>